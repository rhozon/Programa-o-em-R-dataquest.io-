\documentclass{article}
\usepackage[usenames,dvipsnames]{color}
\usepackage[utf8]{inputenc}
\usepackage{lscape}
\usepackage{hyperref}
\usepackage{amsmath}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
}
\usepackage{tikz}
\newcommand{\roundpic}[4][]{
  \tikz\node [circle, minimum width = #2,
    path picture = {
      \node [#1] at (path picture bounding box.center) {
        \includegraphics[width=#3]{#4}};
    }] {};}
    
\usepackage{indentfirst}
\usepackage[a4paper,margin={1.2in,1.5in},vmargin={1.2in,1.5in}]{geometry}
\geometry{paperwidth=210mm,paperheight=297mm,
textwidth=150mm,textheight=210mm,
top=23mm,bottom=23mm,
left=23mm,right=23mm}
\usepackage[colorlinks,linkcolor=blue,hyperindex]{hyperref}
\usepackage[brazil]{babel}
\usepackage{graphicx,color,wrapfig}
\usepackage{multicol}
%\usetikzlibrary{mindmap}
%\pagestyle{empty}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead[]{}
\rhead{Data Analyst in \faRProject}
\lhead{\thepage}
\fancyfoot[]{}
\renewcommand{\headrulewidth}{0.1pt}
\usepackage{color,soul}
\usepackage{color}
\usepackage{listings}%pacote para literalizar os códigos do R no Latex
\usepackage{xcolor}

\usepackage[dvipsnames]{xcolor}

\definecolor{mygray}{gray}{0.9}

\definecolor{codegreen}{rgb}{0,0.5,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
%\definecolor{codeblue}{rgb}{0.48,0,0.72}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{mygray},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
%=========fim da instrução do listings
\usepackage{xcolor}
\usepackage[fixed]{fontawesome5}
\usepackage{tcolorbox}
\usepackage{comment}

\usepackage[framemethod=TikZ]{mdframed}
\mdfdefinestyle{MyFrame}{%
    linecolor=blue,
    outerlinewidth=1pt,
    roundcorner=40pt,
    innertopmargin=\baselineskip,
    innerbottommargin=\baselineskip,
    innerrightmargin=10pt,
    innerleftmargin=10pt,
    backgroundcolor=gray!50!white}
%============================================================
\usepackage{setspace}
%========================================================
\begin{document}


%============================================================

\title{Data Analyst in R \faRProject}}
\author{\href{https://rhozon.github.io/}{Rodrigo Hermont Ozon\footnote{Economista e Mestre em Desenvolvimento Econômico pela UFPR.}}}
\date{Maio, 2020}

\maketitle




\thispagestyle{empty}
%===========================================================
\newpage

\begin{mdframed}[style=MyFrame]

\fbox{%
\roundpic[xshift=-.00000095cm,yshift=-.0006cm]{3.8cm}{3cm}{me.jpg}%
}


\section*{Sobre o Autor:}


\textit{Rodrigo Hermont Ozon, economista e apaixonado por econometria, pelas aplicações de modelos econômicos a problemas reais e cotidianos vivenciados na sociedade e na realidade das empresas.}


\begin{flushleft}
Seus contatos podem ser acessados em:

\begin{itemize}
\item \href{https://rhozon.github.io/}{\faGithub} \href{https://rhozon.github.io/}{Github}

\item \href{https://www.linkedin.com/in/rodrigohermontozon/}{\faLinkedin} \href{https://www.linkedin.com/in/rodrigohermontozon/}{Linkedin} %
\end{itemize}
\end{flushleft}


\end{mdframed}

\vspace{9cm}


\begin{abstract}
Este documento apresenta a resolução dos exercícios do curso disponível no dataquest.io, onde utilizei o overleaf e o pacote knitr para rodar os chunks do \faRProject e apresentar os resultados com maior clareza.


Link do curso do na plataforma: \href{https://app.dataquest.io/m/332/introduction-to-programming-in-r/11/takeaways}{Introduction to Programming in R}
\end{abstract}




\thispagestyle{empty}
%==============================================================
\newpage

.

\vspace{22cm}
À minha amada esposa, Idiane \textit{"Não fui eu que ordenei a você? Seja forte e corajoso! Não se apavore nem desanime, pois o Senhor, o seu Deus, estará com você por onde você andar"."}

\vspace{.15cm}
\hspace{13cm}\href{https://www.bibliaon.com/versiculo/josue_1_9/}{Josué 1:9}

\thispagestyle{empty}

%==========================================================

\newpage
\tableofcontents
%\lstlistoflistings
%\listoffigures



%\hspace{12cm}\includegraphics[widht=1.5cm,height=1.5cm]{erasmussign.png}
\thispagestyle{headings}

\newpage
%====================================================
\onehalfspacing %Para um espaçamento de 1,5
%=====================================================
\section{Introduction to Programming in R}

Data science: It's one of the most exciting and fastest-growing fields out there. Data scientists bring value to all kinds of businesses and organizations, and we can thank data science for many of the technologies that make our lives easier, like web search engines and smartphone personal assistants.

There's no question that it's a great time to learn data science, but it can be tough to know where to start. To help you gain the skills you need, our courses are organized into a curriculum that you can follow without worrying about what comes next.

In this course, we'll begin your data science journey by introducing you to the basics of programming in R. In the courses that come next, we'll build on your new programming knowledge as you learn data visualization and analysis, querying databases, statistics, and more.



You don't need any prior technical knowledge to complete this course, so you can dive right in. By the time you're finished, you'll be analyzing data!

\subsection{Programming in \faRProject}

Data scientists extract information from data and use it to create valuable predictions, visualizations, and technologies. To learn from data, we often need to perform billions of computations over large data sets. We do this with the aid of computers, which need to be given a set of instructions. We refer to writing these instructions as programming.

There are a variety of computer languages that we can use for programming. We'll focus on learning R, a language that offers excellent support for data science work.

Let's get started by instructing the computer to perform a computation: 125 - 3. We'll need to write the instruction 125 - 3 in the code editor on the right, and then click the Run Code button. The computer will follow our instructions, and will return 122, the difference between 125 and 3, as the result. If we want to submit the result as our final answer, we click the Submit Answer button, and the computer will check if our answer is correct.


The instructions we write using a computer language are called code. The code we write to instruct the computer to perform a task is referred to as a program. In the example above, we wrote a program, consisting of one line of code, to instruct the computer to calculate the difference between 125 and 3. Now it's your turn to write a program! Our answer checker will evaluate your work.

Instructions

Write a program to instruct the computer to perform the calculation 125 - 3. Write your code in the code editor on the right, and then click the Run Code button. If your code runs and you think you have the correct answer, click the Submit Answer button.

When you're ready to move on to the next screen, click the Next button.

<<>>=
125-3
@
%======================================
\subsection{R Syntax Rules}

On the previous screen, we wrote a one-line program to perform a computation. In that instance, the code 125 - 3 was input to the computer, which performed the calculation. The result of that calculation, which was displayed after we clicked Run Code, is called output.


In R, we can perform computations using some common arithmetic operators, including:

Addition (+)

Subtraction (-)

Multiplication (*)

Division (/)

Let's say that instead of one computation, we want to perform multiple computations. If we type the following five lines of code into the code editor, the output will consist of the results of each computation:


What happens if instead we express our instructions as a single line of code?


As we can see, the result is very different. This is because our single line of code instructed the computer to do something quite different than our five lines of code did. Like other languages, computer languages have syntax rules that govern the arrangement of symbols, words, and phrases. In R, expressions are evaluated one line at a time following the order of operations rules of mathematics.

Let's get more practice writing code that adheres to R's syntax rules.

Instructions

Write code to instruct R to perform the following computations:

224 + 667

35 / 7

(22 * 5) + 3

<<>>=
224 + 667

35 / 7

(22 * 5) + 3
@

%========================================
\subsection{Exploring Data With R}
%=======================================

Now that we've practiced the basics, let's begin writing R programs to explore some data.

Let's say you're a student taking seven classes. Here's a table containing your exam, homework, and project grades for each class (out of 100 points):

What if we want to calculate your final grade in math class? If exam, project, and homework grades are given equal weight, we can write R code to instruct the computer to perform the computation:

<<>>=
(92 + 87 + 85) / 3
@

Remember that R follows the order of operations, and so the expression within parentheses is evaluated first.

To make it easier for others (including our future selves) to understand our code, we can add notes to it using comments. Code comments follow the # symbol, and the R interpreter does not evaluate them:

<<>>=
(92 + 87 + 85) / 3 # math final grade calculation
@

Let's write a program to calculate the final grade in the rest of the classes.

Instructions

Refer to the table of class data to calculate your final grade in each of your classes:

Chemistry

Writing

Art

History

Music

Physical Education

Use comments (remember, these follow #) to add notes to your code about which class grade we're calculating.

<<>>=
(92 + 87 + 85) / 3 # math
(90+81+92)/3 #chemistry
(84+95+79)/3 #writing
(95+85+90)/3#art    
(77+85+90)/3#history
(92+90+91)/3#music
(85+88+95)/3#physical

@

%===================================
\subsection{Assigning Values to Variables}
%==================================

On the previous screen, we wrote a program to calculate the final grade in each class. To keep track of which class went with which line of code, we used comments:

<<>>=
(92 + 87 + 85) / 3 # math
(90 + 81 + 92) / 3 # chemistry
(84 + 95 + 79) / 3 # writing
(95 + 86 + 93) / 3 # art
(77 + 85 + 90) / 3 # history
(92 + 90 + 91) / 3 # music
(85 + 88 + 95) / 3 # physical education
@


This worked well enough for a program with seven lines of code. As our programming tasks become more complex, however, assigning values to variables will improve our workflow. Using variables allows us to store values in computer memory with an associated name that we can use to access the values. For example, let's say we have a variable named human\_population that stores the value 7,000,000,000. When we type human\_population into the code editor, the computer accesses the value stored in the variable and returns it:

Creating a variable requires two steps:

Create the variable name

Assign values to the variable name using the assignment operator $<-$
If we want to assign the final grade for the math class to a variable called math, we would write:

<<>>=
math <- 88
@

If we type math, the output will consist of the value we assigned to the math variable:

[1] 88

We can also assign expressions to variables:

<<>>=
math <- (92 + 87 + 85)/3
@

If we type the variable named math into the code editor, the output will consist of the result of the expression we assigned to the variable:

[1] 88

When naming variables in R, there are some rules to follow:

Variable names consists of letters, numbers, a dot, or an underscore.
We can begin a variable name with a letter or a dot, but dots cannot be followed by a number.

We cannot begin a variable name with a number.

No special characters are allowed.

Here's a table showing examples of valid and invalid variable names:

We've stored your math grade in a variable. Now, let's store the other class grades as named variables.

Instructions

Store the following values as variables. Use the course names as the 
variable names:

chemistry: 87.66667

writing: 86

art: 91.33333

history: 84

music: 91

physical_education: 89.33333

<<>>=
math <- 88
math<-(92+87+85)/3
math
chemistry<-87.66667
writing<-86
art<-91.33333
history<-84
music<-91
physical_education<-89.33333
@

%=====================================================
\subsection{Programming With Variables}
%=====================================================

Storing values as variables can make them easier to track. We'll illustrate this by writing some code using the variables that we assigned class grade values to.

When performing a computation, R treats variables and values the same. For example, 88 + 87.66667 produces the same result as the following expressions:

<<>>=
math + 87.66667

88 + chemistry

math + chemistry
@

When we perform calculations using variables, order of operations rules still apply. For example, if we want to instruct the computer to compute the average of the math and chemistry grades, we can write an expression using the math and chemistry variables:

<<>>=
(math + chemistry) / 2
@

We can also store the output of expressions in variables. To store the average of math and chemistry in a variable called average, we would use the following syntax:

<<>>=
average <- (math + chemistry) / 2
@

Let's use variables to write a program to compute the average of all final class grades, a score known as the grade point average.

Instructions

On the previous screen, we stored the final grades for each class as variables.

math

chemistry

writing

art

history

music

physical\_education

Write code to compute the grade point average (the average of all grades), and store the expression as a variable named gpa.

<<>>=
math <- 88 
chemistry <- 87.66667
writing <-  86
art <- 91.33333
history <- 84
music <- 91
physical_education <- 89.33333

average<-(math+chemistry)/2

gpa<-(math+chemistry+writing+art+history+music+physical_education)/7
@

%=====================================================
\subsection{Vectors: Storage for Multiple Values}
%======================================================

In the previous example, we wrote a program to calculate grade point average using variables that contain single values (the final grade for each class):

<<>>=
gpa <- (math + chemistry + writing + art + history + music + physical_education)/7
@

This solution worked well enough for the small data set we're analyzing, but will not scale well as we begin to work with more data. To prepare to work with larger data sets, we'll work with storage objects that can hold multiple values: vectors.

In R, vectors contain a sequence of values that can be assigned to a single variable. For example, we could create a vector, math\_chem, that contains the math and chemistry final grades:


As we will learn much more about later in this course, storing values in vectors allows you to peform operations on all of them at once.

To create a vector, we will use use c(), which stands for "concatenate."

This is the first function we'll work with. Like mathematical functions, a function in computer programming takes in inputs and returns an output or an action.

The c() function takes multiple values as input and stores these values in one variable to create a vector.

To create a vector that contains the math and chemistry grades (88 and 87.66667), we would write this code:

<<>>=
math_chem <- c(88, 87.66667)
@

We can also create a vector by referring to variable names:

<<>>=
math_chem <- c(math, chemistry)
@

If we type math\_chem in the code editor, the output will consist of the values we assigned to the vector:

88.00000 87.66667

Remember that R has syntax rules that we need to follow in order for the computer to perform our instructions. If we try to store a sequence of values without the c() function:

<<>>=
math_chem <- 88, 87.66667
@

We will recieve the following error message: Error: unexpected ',' in "math\_chem <- 88,"

Now, let's create a vector containing all the class grades so that we can perform some additional analysis.

Instructions

Create a vector containing the final grades for each class using the variable names.

Store this vector as a new variable named final\_scores.

<<>>=
math <- 88 
chemistry <- 87.66667
writing <- 86
art <- 91.33333
history <- 84
music <- 91
physical_education <- 89.33333

math_chem<-c(88,87.66667)
math_chem<-c(math,chemistry)
writ_hist<-c(86,91.3333)
writ_hist<-c(writing,art)
mus_phy<-c(91,89.33333)
mus_phy<-c(music,physical_education)
final_scores<-c(88,87.6667,86,91.33333,84,91,89.33333)
final_scores<-c(math,chemistry,writing,art,history,music,physical_education)
@

%=================================================
\subsection{Efficient Programming with Functions and Vectors}
%=================================================

On the previous screen, we discussed how programming with vectors will allow us to work with large data sets, since we can perform the same operation on all elements of a vector at once.

Let's take a look at how working with vectors can improve data analysis efficiency.

Earlier, we used arithmetic operators to calculate the grade point average:

<<>>=
gpa <- (math + chemistry + writing + art + history + music + physical_education)/7
@

Now that we have stored the grades in a vector, we can calculate the gpa more efficiently. We will do this using one of R's built-in functions: mean(). Like the c() function, mean() takes inputs, performs an action, and returns an output. The input to mean() is a vector, and the output is the average of the values contained in the vector.

To demonstrate, let's apply the mean() function to the math\_chem vector from the previous screen's example. Instead of writing this code:

<<>>=
(math + chemistry) / 2
@

We can write:

<<>>=
mean(math_chem)
@

The output from calling the mean() function on the math\_chem vector is the average of the math and chemistry grades stored in the vector:

87.83334

Let's use the mean() function to calculate your grade point average.

Instructions

Use the mean() function to calculate your grade point average from the final\_scores vector that we created earlier. Store the result of your calculation in the variable gpa.

<<>>=
final_scores <- c(math, chemistry, writing, art, history, music, physical_education)
gpa<-mean(final_scores)
@
%=============================================
\subsection{Practice with Functions and Vectors}
%=============================================

On the last screen, we calculated the grade point average using the mean() function. Now, let's learn about some additional built-in R functions that we can use to ask more questions about our grades data set:

What was the highest score?

What was the lowest score?

How many classes did we take?

To answer these questions and more, let's introduce some useful R functions.

min(): Takes a vector as input, output is the smallest value in the vector.

max(): Takes a vector as input, output is the largest value in the vector.

length(): Takes a vector as input, output is the total number of values in the vector.

sum():: Takes a vector as input, output is the sum of all values in the vector.

As with the mean() function, these functions allow you to quickly perform the operation across all elements of a vector.

For example, to find the highest score in the math\_chem vector, you can use the max() function:

<<>>=
max(math_chemistry)
@

Let's use some of these functions to answer more questions about our class grades data.

Instructions

Use the max() function to identify the highest final grade in the final\_scores vector.

Use the min() function to identify the lowest final grade in the final\_scores vector.

Use the length() function to calculate the total number of classes.

<<>>=
final_scores <- c(math, chemistry, writing, art, history, music, physical_education)
max(final_scores)
min(final_scores)
length(final_scores)
@

\subsection{Next Steps}

Congratulations! You have completed the first mission of the Introduction to Programming in R course. At Dataquest, our courses are organized into missions, each of which focuses on teaching you a specific collection of skills that you'll build upon as you move forward.

In this mission, you got a feel for working in our interface and learned some key basics of the R language as you analyzed data:

Writing expressions
Creating and working with variables
Creating and working with vectors
On the next screen, you'll find a summary of what you've learned so far: A handy list of "takeaways" for you to refer back to as you continue learning R for data science. Each of our missions features takeaways, which you can choose to download as a PDF file.

In the next mission, we'll delve deeper into working with vectors for data analysis. You'll learn more skills crucial for using R to work with data, like performing operations on multiple vectors and using them in conditional expressions.




%===============================================================
\section{Working with vectors}
%==================================================================================
\subsection{Indexing Vectors by Position}
%==================================================================================

Learning to work with vectors is critical for programming in R. In this mission, we'll build on the skills we learned in the previous one as we dive deeper into creating, manipulating, and performing calculations with vectors.

In the last mission, we learned some basics of R programming as we analyzed class grade data:

\begin{lstlisting}[language=R]
Class	Exams	Homework	Projects
Math	92	87	85
Chemistry	90	81	92
Writing	84	95	79
Art	95	86	93
History	77	85	90
Music	92	90	91
Physical Education	85	88	95
\end{lstlisting}

We calculated final grades for each class and assigned them to variables:

\begin{lstlisting}[language=R]
math <- 88 
chemistry <- 87.66667
writing <-  86
art <- 91.33333
history <- 84
music <- 91
physical_education <- 89.33333
\end{lstlisting}

<<>>=
math <- 88 
chemistry <- 87.66667
writing <-  86
art <- 91.33333
history <- 84
music <- 91
physical_education <- 89.33333
@

Then, we created a vector of final class grades:

\begin{lstlisting}[language=R]
final_scores <- c(math, chemistry, writing, art, history, music, physical_education)
\end{lstlisting}

<<>>=
final_scores <- c(math, chemistry, writing, art, history, music, physical_education)
@

Finally, we used the mean() function to calculate grade point average:

\begin{lstlisting}[language=R]
mean(final_scores)
\end{lstlisting}

<<>>=
mean(final_scores)
@

We've seen how useful working with vectors and functions is for quickly performing calculations in R. In this mission, we'll get a more in-depth look at manipulating vectors for data analysis:

Working with a subset of values in a vector.

Assigning names to elements of a vector.

Using comparison operators to answer questions about data stored in vectors.

Let's continue working with the data on class grades we introduced in the previous mission. We'll begin by investigating how our grades in STEM (science, technology, engineering, and math) classes compare with those in non-STEM classes.

First, we'll need to extract subsets of the data stored in our final\_scores vector: STEM classes and non-STEM classes.

We can index vectors to select a subset of the elements they contain. Within a vector, every element has a position. R is a 1-indexed programming language, which means that the first element in a vector is assigned a position of one.

indexing by position

We can extract values from the vector by specifying their position in brackets $([])$. To return the value in the third position of final_scores, we can write:

\begin{lstlisting}[language=R]
final_scores[3]
\end{lstlisting}

<<>>=
final_scores[3]
@

which returns:

\begin{lstlisting}[language=R]
86
\end{lstlisting}

We can also extract multiple values of a vector by specifying more than one position. We may want to extract a range of vector elements, which we can specify using a colon (:). To select the first through fourth elements of the final\_scores vector, we would write:

\begin{lstlisting}[language=R]
final_scores[1:4]

88.00000 87.66667 86.00000 91.33333
\end{lstlisting}

<<>>=
final_scores[1:4]
@


If we want to select vector elements that are not next to each other, we can specify them using c(). To select elements in the first, third, and seventh position of the final\_scores vector, we would write:

\begin{lstlisting}[language=R]
final_scores[c(1,3,7)]

88.00000 86.00000 89.33333
\end{lstlisting}

<<>>=
final_scores[c(1,3,7)]
@


Let's index the final\_scores vector to see how grades in STEM and non-STEM classes compare.

Instructions

Write code to create a new vector, stem\_grades, containing only the math and chemistry final grades.

Create a new vector, non\_stem\_grades, containing the final grades in the other classes.

Calculate the mean of each vector and save their values in avg\_stem\_grades and avg\_non\_stem\_grades.

<<>>=
final_scores <- c(88, 87.66667, 86, 91.33333, 84, 91, 89.33333)
stem_grades<-final_scores[c(1,2)]
stem_grades
non_stem_grades<-final_scores[c(3:7)]
non_stem_grades
avg_stem_grades<-mean(stem_grades)
avg_stem_grades
avg_non_stem_grades<-mean(non_stem_grades)
avg_non_stem_grades
@


%===============================================================================
\subsection{Numeric and Character Data Types}
%===============================================================================

On the previous screen, you indexed the final\_grades vector to create two new vectors, and calculated the average of the grades in each new vector:

\begin{lstlisting}[language=R]
stem_grades <- final_scores[c(1,2)]
non_stem_grades <- final_scores[c(3:7)]
mean(stem_grades) # 87.83334
mean(non_stem_grades) # 88.33333
\end{lstlisting}

<<>>=
stem_grades <- final_scores[c(1,2)]
non_stem_grades <- final_scores[c(3:7)]
mean(stem_grades) # 87.83334
mean(non_stem_grades) # 88.33333
@

The results of the calculation show that grades are, on average, higher in the non-STEM classes in this data set.

When you indexed the final\_grades vector by position, was it difficult to match the element positions to the classes? Since there are only seven classes in the data set, we could simply refer to the table of data. However, if there were grades for more classes stored in final\_grades, indexing by position would become tedious.

Assigning names to elements of a vector can make indexing easier.

As we delve into naming elements of vectors, let's take a moment to talk about the types of data contained in the vectors we're working with. In R, there are several main types of data. Understanding these different types is key to making the best use of the R language. In this mission, we'll work with numeric and character data.

Numeric Data

In this course, we've been working with class grade data; the data has consisted entirely of numbers. In R, this data type is referred to as numeric. Numeric data may include integer data, or whole numbers (88), and double data, or decimals (87.666667).

As we begin working with multiple data types, the type of data we're working with won't always be clear. Because some operations we'll perform are only useful for some data types, we need to be sure of the type you're working with.

To display the data type of a vector, we'll use the typeof() function. Let's display the data type of final\_scores.

\begin{lstlisting}[language=R]
typeof(final_scores)
\end{lstlisting}

<<>>=
typeof(final_scores)
@


This will display:
\begin{lstlisting}[language=R]
"double"
\end{lstlisting}

Character Data

In R, "characters" refer to all symbols that are used to make up a language, including letters, special characters like "\%", "\&", or "\$", and numbers. Some functions you'll use to perform calculations, such as min() and max(), will not work on character data.

To create a vector containing character data, you can use the c() function as you did when you added grades to the final\_scores vector. However, you need to specify the elements you are including consist of characters by surrounding them with quotation marks (either '' or "").

To create a vector containing the names of two of your classes, we would write:

\begin{lstlisting}[language=R]
math_chemistry <- c("math", "chemistry")
\end{lstlisting}

<<>>=
math_chemistry <- c("math", "chemistry")
@


To check that the vector we've created contains character data, we'll use the typeof() function, which returns the data type of a vector:

\begin{lstlisting}[language=R]
typeof(math_chemistry)

"character"
\end{lstlisting}

<<>>=
typeof(math_chemistry)
@

Now that we've learned about character and numeric data types, let's return to assigning names to elements of the final\_grades vector. As a first step, let's create a character vector of the names of your classes.

Instructions

Create a vector of character data called class\_names containing your classes in the following order:

math

chemistry

writing

art

history

music

physical\_education

<<>>=
class_names<-c("math","chemistry","writing","art","history","music","physical_education")
class_names
@


\subsection{Naming elements of vector}

We have now created two vectors:

final\_scores, containing your class grades (numeric data).

class\_names, containing the class names (character data).

In R, vectors may have attributes assigned to them. Attributes provide information, such as names, about the values stored in the vector. To assign names to vector elements, we can use the names() function.

To illustrate how to use the names() function, let's create two vectors.

One vector contains the math and chemistry grades:

\begin{lstlisting}[language=R]
math_chemistry <- c(88, 87.66667)
\end{lstlisting}

<<>>=
math_chemistry <- c(88, 87.66667)
@


The other contains the names of the two classes:

\begin{lstlisting}[language=R]
class_names <- c("math", "chemistry")
\end{lstlisting}

<<>>=
class_names <- c("math", "chemistry")
@


To assign the values stored in class\_names as attributes of the grade values contained in the math\_chemistry vector, we would write:

\begin{lstlisting}[language=R]
names(math_chemistry) <- class_names
\end{lstlisting}

<<>>=
names(math_chemistry) <- class_names
@


Now, if we type math\_chemistry, R returns:
\begin{lstlisting}[language=R]
math       chemistry                       
88.00000   87.66667
\end{lstlisting}

We can also use the names() function to return the names of elements in a vector. If we type:
\begin{lstlisting}[language=R]
names(math_chemistry)
\end{lstlisting}

<<>>=
names(math_chemistry)
@

R returns the names that you assigned to the elements of math\_chemistry:

\begin{lstlisting}[language=R]
"math"   "chemistry"
\end{lstlisting}

If we try to apply the names() function to a vector with no names assigned to its elements, R will return NULL.

Let's assign the class name to each grade in your final_scores vector.

Instructions

Use the class\_names vector to assign names to elements of the final\_scores vector.

<<>>=
class_names <- c("math", "chemistry", "writing", "art", "history", "music", "physical_education")

final_scores <- c(88, 87.66667, 86, 91.33333, 84, 91, 89.33333)

names(final_scores)<-class_names

final_scores
@

%==============================================================================

\subsection{Indexing vectors using names}

We have now assigned names to elements of the final\_scores vector:

\begin{lstlisting}[language=R]
math	chemistry	writing	art	history	music	physical_education
88.00000	87.66667	86.00000	91.33333	84.00000	91.00000	89.33333
\end{lstlisting}

Earlier in this mission, we learned to index vectors using the positions of elements we wanted to extract. Now that we have assigned names to elements of the vector, we can index using the names.

Let's return to the math\_chemistry vector. We assigned names to the grades contained in this vector on the last screen:
\begin{lstlisting}[language=R]
math_chemistry

math       chemistry                       
88.00000   87.66667
\end{lstlisting}

<<>>=
math_chemistry
@

If we want to return the score in chemistry class, we can index math\_chemistry by the class name chemistry:
\begin{lstlisting}[language=R]
math_chemistry["chemistry"]

chemistry 
87.66667
\end{lstlisting}

<<>>=
math_chemistry
@


Remember, since the names attributes consist of character data, "chemistry" needs to be in quotes.

Indexing the math\_chemistry vector by the name chemistry returns the grade (87.66667). We'd get the same result if we indexed by position.

\begin{lstlisting}[language=R]
math_chemistry[2]

chemistry 
87.66667
\end{lstlisting}

<<>>=
math_chemistry[2]
@


As with indexing by position, we can index by name to return multiple elements using c():

\begin{lstlisting}[language=R]
math_chemistry[c("math","chemistry")]

math       chemistry                       
88.00000   87.66667
\end{lstlisting}

<<>>=
math_chemistry[c("math","chemistry")]
@

Let's index the final\_scores vector by name as we analyze a subset of the class grades.

Earlier in this mission, we calculated the averages of grades in STEM and non-STEM classes. Now, we're interested in comparing the average grades in your fine arts (art, music) and liberal arts (writing, history) classes.

Instructions

Index the final\_scores vector by name to create two new vectors:
liberal\_arts: Containing your writing and history final grades.
fine\_arts: Containing your art and music final grades.
Calculate the average of each new vector.

<<>>=
liberal_arts<-final_scores[c(3,5)]
fine_arts<-final_scores[c(4,6)]
mean(liberal_arts)
mean(fine_arts)
@

%========================================================================

\subsection{Comparing Values And Logical Data Types}

We have now indexed the final\_scores vector to visually compare averages of the grades in a few subsets of classes:

STEM vs. non-STEM

Liberal arts vs. fine arts

This method worked well with the small data set we've been working with, but there are other methods that will scale more effectively as our data sets grow in size and complexity.

Instead visually comparing pairs of grades, we can write code using comparison operators to compare values based on specific conditions, such as "greater than," "less than," or "equal to."

When we compare two values using a comparison operator, if the values satisfy the condition, the R interpreter will return TRUE. If the values do not satisfy the condition, the R interpreter will return FALSE.

Below, we illustrate a comparison of your math final grade (88) against your chemistry grade (87.6667) using all the comparison operators:

comparison operators

These TRUE and FALSE values are of another data type in R: boolean, or logical. The logical data type can only consist of two values, TRUE and FALSE.

To answer the question, "Did I get a better grade in chemistry than I did in math?" you could write:

\begin{lstlisting}[language=R]
stem_grades <- final_scores[c(1,2)]
non_stem_grades <- final_scores[c(3:7)]
math_chemistry["chemistry"] > math_chemistry["math"]
\end{lstlisting}

<<>>=
stem_grades <- final_scores[c(1,2)]
non_stem_grades <- final_scores[c(3:7)]
math_chemistry["chemistry"] > math_chemistry["math"]
@

This expression returns FALSE, since your chemistry grade is actually lower than your math grade.

Let's use comparison operators to answer more questions about the final grades.

Instructions

Write an expression using a comparison operator to answer the question: Is the average of liberal arts final grades greater than the average of fine arts final grades?

<<>>=
mean(liberal_arts)>mean(fine_arts)
@

%=============================================================================
\subsection{Comparing Values And Logical Data Types}
%=============================================================================

On the previous screen, we compared the averages of liberal arts and fine arts grades. We wrote an expression using a comparison operator to see if the liberal arts average grade was higher:

\begin{lstlisting}[language=R]
stem_grades <- final_scores[c(1,2)]
non_stem_grades <- final_scores[c(3:7)]
mean(liberal_arts) > mean(fine_arts) # FALSE
\end{lstlisting}

<<>>=
stem_grades <- final_scores[c(1,2)]
non_stem_grades <- final_scores[c(3:7)]
mean(liberal_arts) > mean(fine_arts) # FALSE
@

Now, let's ask a different question: "Is the final math grade higher than the grade in my other classes?"

The syntax in R makes this comparison straightforward to write an expression for:

\begin{lstlisting}[language=R]
final_scores["math"] > final_scores
\end{lstlisting}

<<>>=
final_scores["math"] > final_scores
@

The output consists of comparisons of the math grade with each other class grade:

\begin{lstlisting}[language=R]
math	chemistry	writing	art	history	music	physical_education
FALSE	TRUE	TRUE	FALSE	TRUE	FALSE	FALSE
\end{lstlisting}

To understand why this code results in the output shown above, we need to understand how R works with vectors of different lengths. When comparing the math grade (a vector containing a single value) to a vector containing all grades, R replicates the shorter vector until it is the same length as the longer vector. Then it performs the operation, as illustrated below:

compare vectors of different lengths

We will see more detailed examples of this behavior in a few screens.

Like numeric and character data, logical data can be stored in vectors. If we want to store the results of comparing the math grade with the other grades as a variable called math_comparison, we can write:

\begin{lstlisting}
math_comparison <- final_scores["math"] > final_scores
\end{lstlisting}

<<>>=
math_comparison <- final_scores["math"] > final_scores
math_comparison
@

If we then use the typeof() function to check the data type of math\_comparison, the output tells us that the data type is logical:

\begin{lstlisting}
typeof(math_comparison)

"logical"
\end{lstlisting}

<<>>=
typeof(math_comparison)
@

Let's figure out how each class grade compares to the grade point average.

Instructions

Use the mean() function to calculate the grade point average from final\_scores. Store this in a variable named gpa.

Compare final\_scores to gpa to see whether the grade in each class is higher than the gpa. Store the logical output in a vector named above\_average.

<<>>=
gpa<-mean(final_scores)
gpa
above_average<-final_scores>gpa
above_average
@

%==================================================================
\subsection{Logical Indexing}
%==================================================================

We've now created a logical vector, above\_average, that tells us whether or not each of the grades is higher than the gpa:

\begin{lstlisting}[language=R]
math	chemistry	writing	art	history	music	physical_education
FALSE	FALSE	FALSE	TRUE	FALSE	TRUE	TRUE
\end{lstlisting}

The art, music, and physical education grades were higher than our grade point average. What if we want to create a new vector containing only grades from those classes in which your grade was higher than your gpa?

In the previous exercises, we indexed by position and by name. Here, we'll introduce a new type of indexing called logical indexing.

Logical indexing will compare each value in a target vector against the corresponding value in a logical vector.

If the corresponding value is TRUE, the resulting vector will contain that value.

If the corresponding value is FALSE, the resulting vector will not contain that value.

Earlier in this mission, we compared the math grade with grades in other classes to see if it was higher. Let's store the result of this comparison in a vector of logical values:

\begin{lstlisting}[language=R]
stem_grades <- final_scores[c(1,2)]
non_stem_grades <- final_scores[c(3:7)]
logical_vector <- final_scores["math"] > final_scores
math	chemistry	writing	art	history	music	physical_education
FALSE	TRUE	TRUE	FALSE	TRUE	FALSE	FALSE
\end{lstlisting}

<<>>=
stem_grades <- final_scores[c(1,2)]
non_stem_grades <- final_scores[c(3:7)]
logical_vector <- final_scores["math"] > final_scores
@


We can now index final\_scores using logical\_vector. This will allow us to create a new vector containing only class grades that are lower than the math grade:

\begin{lstlisting}[language=R]
final_scores[logical_vector]
\end{lstlisting}

<<>>=
final_scores[logical_vector]
@

Let's use logical indexing to create a vector containing only class grades that are higher than the GPA.

Instructions

By indexing above\_average into final\_scores, create a new vector named best\_grades that contains only class grades that are higher than your GPA.

<<>>=
best_grades<-(final_scores>gpa)
best_grades<-final_scores[best_grades]
best_grades
@

%=============================================================================
\subsection{Performing Arithmetic with Vectors}

We have now learned to perform operations on single vectors. We'll frequently use single-vector operations, such as calculating the average of values (or a subset of values) in a vector, as we analyze data.

For the rest of this mission, we'll learn to make use of a very powerful feature of R: The ability to perform arithmetic operations on every element of multiple vectors at once.

As we illustrate how this works, let's consider an example.

You've been making great progress learning to use R to write programs to analyze your grades. Your friends have noticed your good work and have expressed interest in using your program to calculate their final grades, too.

Your friend, Johnny, who has the same classes as you this year, emailed you all his average exam, homework, and project grades in the following format:

Tests: 76, 89, 78, 88, 79, 93, 89

Homework: 85, 90, 88, 79, 88, 95, 74

Projects: 77, 93, 87, 90, 77, 82, 80

Johnny is a bit disorganized, but he assures you the grades are listed in the same order for each assignment category:

math, chemistry, writing, art, history, music, physical\_education

You start by creating three vectors, one for each assignment category, to work with:

\begin{lstlisting}[language=R]
stem_grades <- final_scores[c(1,2)]
non_stem_grades <- final_scores[c(3:7)]
tests <- c(76, 89, 78, 88, 79, 93, 89)
homework <- c(85, 90, 88, 79, 88, 95, 74)
projects <- c(77, 93, 87, 90, 77, 82, 80)
\end{lstlisting}

<<>>=
stem_grades <- final_scores[c(1,2)]
non_stem_grades <- final_scores[c(3:7)]
tests <- c(76, 89, 78, 88, 79, 93, 89)
homework <- c(85, 90, 88, 79, 88, 95, 74)
projects <- c(77, 93, 87, 90, 77, 82, 80)
@

First, Johnny would like help calculating the final scores for each class. You could calculate each class grade individually:

\begin{lstlisting}[language=R]
math <- (76 + 85 + 77) /3
chemistry <- (89 + 90 + 93)/3 # etc.
\end{lstlisting}

<<>>=
math <- (76 + 85 + 77) /3
chemistry <- (89 + 90 + 93)/3 # etc.
@

However, you're learning to use R with larger data sets. Instead of calculating each final grade, you can use vector arithmetic to perform these calculations.

Vector arithmetic is similar to the arithmetic you performed to make calculations using individual values earlier in the course. When performing arithmetic on vectors, operations are performed between values in order of position.

To illustrate how adding two vectors together works, let's add Johnny's tests and homework vectors and save the output as a new vector called sum:

\begin{lstlisting}[language=R]
sum <- tests + homework
\end{lstlisting}

<<>>=
sum <- tests + homework

@

The operation and the resulting vector would look like:

vector addition

Let's use vector arithmetic to calculate Johnny's final grades in each class.

Instructions

Calculate Johnny's average scores for each class by adding the tests, homework, and projects vectors and dividing by 3.

Store the resulting vector in a variable named johnny\_scores.

Use the mean() function to calculate Johnny's grade point average from johnny\_scores.


<<>>=
math<-(76+85+77)/3
math
chemistry<-(89+90+93)/3
chemistry
writing<-(78+88+87)/3
writing
art<-(88+79+90)/3
art
history<-(79+88+77)/3
history
music<-(93+95+82)/3
music
physical_education<-(89+74+80)/3
physical_education
johnny_scores<-c(math,chemistry,writing,art,history,music,physical_education)
mean(johnny_scores)
@

%===========================================================================
\subsection{Vector Recycling}

In the previous example, we calculated Johnny's scores by performing vector arithmetic. In that scenario, the three vectors we're working with were of the same length. Each had seven values for the seven classes Johnny took. This isn't always the case, though. For example, what if Johnny forgot to give you a homework grade for one of the classes?

missing\_values

Earlier in this mission, we saw that whenever there's a mismatch in the length of two vectors that you're comparing, the shorter vector is recycled (or repeated) until it matches the length of the longer one. Let's learn more about this feature of working with vectors in R.

To illustrate how R's recycling behavior works when we perform operations on vectors of different lengths, let's shorten your homework vector to only two values:

\begin{lstlisting}[language=R]
stem_grades <- final_scores[c(1,2)]
non_stem_grades <- final_scores[c(3:7)]
tests <- c(76, 89, 78, 88, 79, 93, 89)
homework <- c(85, 90)
recycling rule
\end{lstlisting}

<<>>=
stem_grades <- final_scores[c(1,2)]
non_stem_grades <- final_scores[c(3:7)]
tests <- c(76, 89, 78, 88, 79, 93, 89)
homework <- c(85, 90)
@

recycling rule

The R interpreter will determine that the homework vector is shorter than the tests vector and will automatically recycle the values in the homework vector until the two vectors are the same length:

recycling rule 2

Once the vector lengths match, the R interpreter will perform the specified arithmetic operation.

When we perform operations on vectors of unequal lengths in R, we will receive the following warning message:

\begin{lstlisting}[language=R]
Warning message:
In tests + homework :

  longer object length is not a multiple of shorter object length
\end{lstlisting}
  
R will still perform the calculation. The warning message is intended to alert us to the possibility that the different vector lengths were not intended.

Let's return to our scenario of writing programs to calculate your friends' grades. You have a very disorganized friend, Kate, who provides you with incomplete data: She is missing test averages for four of her classes. Let's see what will happen if you try to calculate her grades as you did for Johnny.

Instructions

Here are Kate's test, homework and project grades:

Tests: 76, 89, 78

Homework: 85, 90, 88, 79, 88, 95, 74

Projects: 77, 93, 87, 90, 77, 82, 80

Calculate the sum of Kate's test, homework, and project grades and store the resulting vector as a variable named recycling. Note the resulting warning message.

<<>>=
recycling<-(tests+homework+projects)
@

%=============================================================================
\subsection{Appending Elements To A Vector}

On the previous screen, you calculated the sum of Kate's test, homework, and project grade vectors despite knowing that the data she gave you was incomplete. Although R recycled the incomplete tests vector and calculated an average grade for each class, these averages do not accurately reflect Kate's grade.

Luckily, while cleaning her room, Kate found the four tests she was missing and was able to give you her grades:

88

79

93

89

Rather than re-typing the tests vector, you can append, or add, Kate's test scores to it.

Recall from earlier in the course that we used the c() function to create vectors:

\begin{lstlisting}[language=R]
stem_grades <- final_scores[c(1,2)]
non_stem_grades <- final_scores[c(3:7)]
tests <- c(76, 89, 78)
\end{lstlisting}


To add additional elements to a vector, you can use c() to create a new vector consisting of the existing vector plus the new elements you want to add to it:

\begin{lstlisting}[language=R]
tests <- c(tests, 99, 67)
\end{lstlisting}

<<>>=
tests <- c(tests, 99, 67)
tests
@


Kate has asked you to help her figure out which of her classes were her weakest so that she can improve. Let's add Kate's test scores to the tests vector and help her figure out which of her classes need more effort.

This exercise has several steps, and is meant to be a challenge. Get ready to show off all that you've learned in this course so far!

Instructions

Add the rest of Kate's test grades (88, 79, 93, 89) to the tests vector. Save the new vector containing all Kate's grades as tests, which will overwrite the incomplete tests variable.

Use vector arithmetic to calculate Kate's final average grade for each class from the tests, homework, and projects vectors. Save the resulting vector as kate\_grades.

Assign class names to the elements of kate_grades.

Calculate Kate's gpa from kate_grades using the mean() function and save the result as a variable named kate\_gpa.

Use comparison operators and logical indexing to create a new vector, kate\_low_grades, containing final grades for classes in which Kate earned a grade lower than kate\_gpa.

<<>>=
tests<-c(tests,88, 79, 93, 89)
kate_grades<-(tests+homework+projects)/3
names(kate_grades)<-class_names
kate_gpa<-mean(kate_grades)
kate_low_grades<-kate_grades<kate_gpa
kate_low_grades<-kate_grades[kate_low_grades]
@

%================================================================================
\subsection{Next steps}

In this mission, we've learned to create, manipulate, add attributes to, index, and perform calculations using vectors. Vectors are a key data structure in R, and the skills we've learned in this mission will be ones we build on as we begin analyzing more complex data.

In the next mission, we'll dig deeper into analysis as we work with real-world data on university rankings. Now that we've learned the basics of working with vectors, we'll expand our R capabilities as we work with two-dimensional data structure: matrices.

%===============================================================================
\section{Working with matrices}

In the previous missions, we put our programming skills to use as we analyzed class grade data. We got practice working with vectors, which will serve as a foundation for the knowledge we build as we continue to learn R.

In this mission, we'll analyze real-world data on university rankings. We'll expand our knowledge of R's data structures as we explore how to create, index, and perform operations on matrices.

Let's say you've been accepted a number of top universities. To decide which to attend, you want to find a way to score them using data on education quality, influence, cost, and other factors. The data we'll be working with come from the Times Higher Education World University Ranking data set. The top 100 universites in the world are ranked using various criteria on education quality and influence around the world. We've created a smaller data set containing data you'll need during this mission. Here are the first few rows:

\begin{lstlisting}
University	world_rank	quality_of_education	influence	broad_impact	patents
Harvard	1	1	1	1	3
Stanford	2	9	3	4	10
MIT	3	3	2	2	1
Cambridge	4	2	6	13	48
Oxford	5	7	12	9	15
Columbia	6	13	13	12	4
\end{lstlisting}

The data is arranged into rows and columns. Each row corresponds to a specific university, and each column contains information about a different ranking for each university. Higher rankings are represented by lower numbers. For example, Harvard's ranking for world\_rank is higher than Stanford's.

To work with the data in R, we could create a vector for each university. Instead, we'll learn to use a matrix to hold all university data in one place. While vectors are one-dimensional, matrices are two-dimensional and consist of rows and columns in a rectangular layout:

vector and matrix comparison

Like vectors, matrices hold data of one type (such as numeric or logical). A matrix can contain as many rows and columns as needed, so we can create one containing rankings for all the universities you've been accepted to.

In this mission, we'll work with data stored in a matrix as we analyze university ranking and tuition data to decide on a university to attend. Let's get started!

%============================================================================

\subsection{Working with lists}

In the last mission, we worked with matrices to analyze university rankings and choose a university for you to attend. Now that you're about to begin your first year at Harvard, you're deciding on clubs to join so that you can make friends with similar interests. You have many diverse interests in sports, art, and music, and decide to explore a variety of activities.

In this mission, we'll learn how to work with data stored in lists as you organize the results of your investigation of different university clubs.

In the first three missions of this course, we learned about two different data structures:

Vectors: One-dimensional data structures that hold a single data type.
vector

Matrices: Two-dimensional data structures that hold a single data type.
matrix

In this mission, we'll learn about lists, which can contain multiple types of objects. The objects may consist of different data structures, including single data elements, vectors, and matrices.

list

Why would we want to create lists of objects in R? The answer is that storing objects in lists allows us to make use of some very powerful R features for performing the same operation on each object in your list, which can let you avoid repetitively typing the same function.

mean of list

We'll learn how to harness the power of lists for performing tasks such as those illustrated above in the next course. For now, we'll provide you with a strong foundation in creating, manipulating, and understanding the structure of lists.

To create a list, we'll use the list() function. The list() function takes elements you want to include in your list as inputs. You can then assign your list a variable name. In the following example, we are storing three club names in a list:

\begin{lstlisting}[language=R]
clubs <- list("tennis", "film", "outdoors")
\end{lstlisting}

<<>>=
clubs <- list("tennis", "film", "outdoors")
clubs
@

To get used to using the list() function, let's store a few of the clubs you're interested in as a list.

Instructions

Store the following club names in a list called uni\_clubs:

"ballroom dancing"

"rugby"

"bird watching"

"pottery"

<<>>=
uni_clubs<-list("ballroom dancing","rugby","bird watching","pottery")
uni_clubs
@

%===========================================================================
\subsection{Anatomy of a List}
%===========================================================================


Let's look at the list of clubs you created:

\begin{lstlisting}
[[1]]
[1] "ballroom dancing"

[[2]]
[1] "rugby"

[[3]]
[1] "bird watching"

[[4]]
[1] "pottery"
\end{lstlisting}


Note that each club you stored in the list appears on its own line, and its position within the list in shown brackets above it ([[1]]). In this list, the numbers one through four tell you the order of the objects stored in the list.

The uni\_clubs list contains only single elements of character data type. Recall, however, that lists may contain objects of any data type. You're able to use them to store other information from your club search including club descriptions, types of activities, the cost of club dues, and the times when the club meets.

Here are some of the data you've gathered for the chess club:

\begin{lstlisting}

club_title <- c("Chess Club")

club_description <- c("Meets two nights a week for members to play chess. Snacks are provided.")

club_dues <- c(50, 20, 15)

meeting_days <- c("Monday", "Wednesday")

meeting_times <- c("6:00 pm", "8:00 pm")

\end{lstlisting}

<<>>=
club_title <- c("Chess Club")

club_description <- c("Meets two nights a week for members to play chess. Snacks are provided.")

club_dues <- c(50, 20, 15)

meeting_days <- c("Monday", "Wednesday")

meeting_times <- c("6:00 pm", "8:00 pm")
@

Let's save the chess club data in a list. The pieces of information we have are:

Club title (vector of character data)

Club description (vector of character data)

Club dues (vector of numeric data)

Meeting days (vector of character data)

Meeting times (vector of character data)

We've created the vectors for you. Let's organize the data in a list.

Instructions

Create a matrix, called club\_meetings, containing the meeting\_days and meeting\_times. Organize the matrix so that meeting\_days is the first row.

Store the following objects, in this order, in a list called chess\_club:

club\_title

club\_description

club\_dues

club\_meetings

<<>>=
club_title <- c("Chess Club")
club_description <- c("Meets two nights a week for members to play chess. Snacks are provided.")
club_dues <- c(50, 20, 15)
meeting_days <- c("Monday", "Wednesday")
meeting_times <- c("6:00 pm", "8:00 pm")

club_meetings<-rbind(meeting_days,meeting_times)
club_meetings

chess_club<-list(club_title,club_description,club_dues,club_meetings)
chess_club
@
%===========================================================================
\subsection{Assigning Names to List Objects}
%===========================================================================

We've now created the list chess\_club to organize the information you gathered about the club:

\begin{lstlisting}[language=R]
[[1]]
[1] "Chess Club"

[[2]]
[1] "Meets two nights a week for members to play chess. Snacks are provided."

[[3]]
[1] 50 20 15

[[4]]
              [,1]      [,2]       
meeting_days  "Monday"  "Wednesday"
meeting_times "6:00 pm" "8:00 pm"
\end{lstlisting}

<<>>=
chess_club
@

Note that names of the objects are not retained in the list, but the original data types of each object are.

To specify names for list objects within the list() function, you can use =. For example, let's create a list containing data you've gathered about the rugby club:

\begin{lstlisting}
rugby_club <- list(club_title = c("Rugby Club"), club_description = c("Plays matches against clubs from local universities"), club_dues = c(100, 50))
\end{lstlisting}

<<>>=
rugby_club <- list(club_title = c("Rugby Club"), club_description = c("Plays matches against clubs from local universities"), club_dues = c(100, 50))
rugby_club
@

The resulting list, rugby_club, contains three objects with names assigned to them

\begin{lstlisting}[language=R]
$club_title
[1] "Rugby Club"

$club_description
[1] "Plays matches against clubs from local universities"

$club_dues
[1] 100  50
\end{lstlisting}

Often, we'll want to use a vector of character data to assign names to objects of a list. Assigning names to list objects is similar to assigning names to vector elements: We'll use the names() accessor function.

To illustrate this, let's create a list containing data for the ballroom dancing club:

\begin{lstlisting}[language=R]
ballroom_dancing <- list(c("Ballroom Dancing Club"), c("Practices waltz, salsa, and tango dancing for competitions with local university dance teams"), c(150))
\end{lstlisting}

<<>>=
ballroom_dancing <- list(c("Ballroom Dancing Club"), c("Practices waltz, salsa, and tango dancing for competitions with local university dance teams"), c(150))
@

Here's the list:

\begin{lstlisting}[language=R]
[[1]]
[1] "Ballroom Dancing Club"

[[2]]
[1] "Practices waltz, salsa, and tango dancing for competitions with local university dance teams"

[[3]]
[1] 150
\end{lstlisting}

Now, let's assign a name to each object in ballroom_dancing:

\begin{lstlisting}[language=R]
names(ballroom_dancing) <- c("club_title", "club_description", "club_dues")
\end{lstlisting}

<<>>=
names(ballroom_dancing) <- c("club_title", "club_description", "club_dues")
@

If you display ballroom\_dancing, you'll see that each object is named:

\begin{lstlisting}[language=R]
$club_title
[1] "Ballroom Dancing Club"

$club_description
[1] "Practices waltz, salsa, and tango dancing for competitions with local university dance teams"

$club_dues
[1] 150
\end{lstlisting}

As with vectors, if you call the names() function in a list without assigned names, the function will return NULL.

Let's assign names to objects of the chess\_club list that you created earlier.

Instructions

We have created a vector, chess\_club\_names, of names for the objects of the chess\_club list. Use the names() function to assign the names as attributes to elements of the chess\_club list.


<<>>=
chess_club <- list(club_title, club_description, club_dues, club_meetings)
chess_club_names <- c("club_title", "club_description", "club_dues", "club_meetings")
# Type your code below
names(chess_club)<-c("club_title", "club_description", "club_dues", "club_meetings")
@

%===================================================================
\subsection{Indexing Lists}

In previous missions, we learned to index vectors and matrices to extract a subset of values. Similarly, we can index lists.

We'll generally use two different indexing operations on lists:

Single brackets to return a list of selected elements ([])

Double brackets to return a single element ([[]])

Let's take the rugby\_club list as an example:

\begin{lstlisting}[language=R]
[[1]]
[1] "Chess Club"

[[2]]
[1] "Meets two nights a week for members to play chess. Snacks are provided."

[[3]]
[1] 50 20 15

[[4]]
              [,1]      [,2]       
              
meeting_days  "Monday"  "Wednesday"
meeting_times "6:00 pm" "8:00 pm"
$club_title
[1] "Rugby Club"

$club_description
[1] "Plays matches against clubs from local universities"

$club_dues
[1] 100  50
\end{lstlisting}

If we want to extract the second object in the list and we write the following code:

\begin{lstlisting}[language=R]
rugby_club <- list(club_title = c("Rugby Club"), club_description = c("Plays matches against clubs from local universities"), club_dues = c(100, 50))
rugby_club[2]
\end{lstlisting}

<<>>=
rugby_club <- list(club_title = c("Rugby Club"), club_description = c("Plays matches against clubs from local universities"), club_dues = c(100, 50))
rugby_club[2]
@

We'll get the following output:

\begin{lstlisting}[language=R]
$club_title
[1] "Rugby Club"

$club_description
[1] "Plays matches against clubs from local universities"

$club_dues
[1] 100  50
$club_description
[1] "Plays matches against clubs from local universities"
\end{lstlisting}

If we check the type of the object, we see that it is a list:

\begin{lstlisting}[language=R]
ballroom_dancing <- list(c("Ballroom Dancing Club"), c("Practices waltz, salsa, and tango dancing for competitions with local university dance teams"), c(150))
typeof(rugby_club[2])
[1] "list"
\end{lstlisting}

<<>>=
ballroom_dancing <- list(c("Ballroom Dancing Club"), c("Practices waltz, salsa, and tango dancing for competitions with local university dance teams"), c(150))
typeof(rugby_club[2])
@

Let's try performing this operation using double brackets:

\begin{lstlisting}[language=R]
[[1]]
[1] "Ballroom Dancing Club"

[[2]]
[1] "Practices waltz, salsa, and tango dancing for competitions with local university dance teams"

[[3]]
[1] 150
rugby_club[[2]]
[1] "Plays matches against clubs from local universities"

typeof(rugby_club[[2]])
[1] "character"
\end{lstlisting}


This time, the output is a single element of the data type character.

To better illustrate when you'd choose to use single or double brackets to index a list, let's extract multiple list elements.

Recall from earlier missions that we can extract multiple elements using c(). Let's use single brackets to extract the first and third objects in the rugby\_club list:

\begin{lstlisting}[language=R]
names(ballroom_dancing) <- c("club_title", "club_description", "club_dues")
rugby_club[c(1,3)]
The output consists of a list of the first and third vectors that we stored in rugby_club:
$club_title
[1] "Ballroom Dancing Club"

$club_description
[1] "Practices waltz, salsa, and tango dancing for competitions with local university dance teams"

$club_dues
[1] 150
$club_title
[1] "Rugby Club"

$club_dues
[1] 100
\end{lstlisting}

What happens if we use double brackets to index rugby\_club?

\begin{lstlisting}[language=R]
rugby_club[[c(3,2)]]
\end{lstlisting}

<<>>=
rugby_club[[c(3,2)]]
@

Now, the output consists of the second element in the third object of the list:

\begin{lstlisting}
[1] 50
\end{lstlisting}

When objects in a list have names associated with them, you can use them for indexing.

The following two lines of code will both extract the elements contained in the third object in the rugby\_club list:

\begin{lstlisting}[language=R]
rugby_club$club_dues

[1] 100  50
rugby_club[[3]]

[1] 100  50
\end{lstlisting}

<<>>=
rugby_club$club_dues
rugby_club[[3]]
@

Let's practice indexing the chess\_club list.

Instructions

Here is the chess\_club list:

\begin{lstlisting}[language=R]
$club_title
[1] "Chess Club"

$club_description
[1] "Meets two nights a week for members to play chess. Snacks are provided."

$club_dues
[1] 50 20 15

$club_meetings
              [,1]      [,2]       
meeting_days  "Monday"  "Wednesday"
meeting_times "6:00 pm" "8:00 pm"  
\end{lstlisting}

Index the chess\_club list to return the second element in club\_dues.

<<>>=
chess_club[[c(3,2)]]
@

%=======================================================================
\subsection{Modifying List Elements}
%=======================================================================

In addition to extracting elements, we can also index lists to change specific list components.

For example, let's say you spoke with a new friend who is a member of the rugby club. She tells you that the club dues paid by members at the start of the fall and spring semesters have increased by 10 USD each.

As a result, you'd like to change the values of club\_dues you have stored in your rugby\_club list.

\begin{lstlisting}[language=R]
[[1]]
[1] "Chess Club"

[[2]]
[1] "Meets two nights a week for members to play chess. Snacks are provided."

[[3]]
[1] 50 20 15

[[4]]
              [,1]      [,2]   
meeting_days  "Monday"  "Wednesday"
meeting_times "6:00 pm" "8:00 pm"
$club_title
[1] "Rugby Club"

$club_description
[1] "Plays matches against clubs from local universities"

$club_dues
[1] 100  50
\end{lstlisting}
    

To replace the club\_dues values in the rugby\_club list with the new costs you've learned about, we would write:

\begin{lstlisting}[language=R]
rugby_club$club_dues <- c(110, 60)
\end{lstlisting}

<<>>=
rugby_club$club_dues <- c(110, 60)
rugby_club$club_dues
@

We can also replace only one of the dues values. Let's say that another friend in the rugby club explained that the club captains are considering discounting the fall semester dues by 50 USD to encourage more freshmen to join this year. To replace 110 with 60, you would write:

\begin{lstlisting}[language=R]
rugby_club[[c(3, 1)]] <- 60
\end{lstlisting}

<<>>=
rugby_club[[c(3, 1)]] <- 60
@

Remember that use of the double brackets here specifies the first value of the third object in the list.

Let's modify the chess\_club list to reflect new information your research has turned up. Currently, chess club members pay dues during the fall semester (50 USD), spring semester (20 USD), and during summer (15 USD) if they are staying on campus. Since few students stay on campus and snack costs are low, the club captain is reducing summer club dues to 5 USD.

Instructions

Here is the chess\_club list:

\begin{lstlisting}[language=R]
$club_title
[1] "Chess Club"

$club_description
[1] "Meets two nights a week for members to play chess. Snacks are provided."

$club_dues
[1] 50 20 15

$club_meetings
              [,1]      [,2]       
meeting_days  "Monday"  "Wednesday"
meeting_times "6:00 pm" "8:00 pm"  
\end{lstlisting}


Write code to replace the third element of club\_dues to 5.

Display the third element of club\_dues in the chess\_club list to check that you have replaced it properly.

<<>>=
chess_club$club_dues<-c(50,20,5)
chess_club[[c(3,3)]]
@

%============================================================================
\subsection{Adding Elements to Lists}
%============================================================================

As we continue to research clubs, you'll acquire more information that you may want to incorporate into your existing lists.

Since one of the reasons you're looking to join clubs is to meet new friends, you'd like to join clubs that have lots of members who are also in their first year of university.

As you've researched the clubs you're interested in, you've found some information on the number of first-, second-, third-, and fourth-year university students who participated in the club during fall and spring semesters last year.

For the rugby club, you've organized the information in the form of numeric data in a matrix named member\_years\_rugby:

\begin{lstlisting}[language=R]
fall <- c(8, 12, 13, 2)
spring <- c(6, 11, 14, 3)

member_years_rugby <- rbind(fall, spring)
colnames(member_years_rugby) <- c("first_yr", "second_yr", "third_yr", "fourth_yr")
\end{lstlisting}

<<>>=
fall <- c(8, 12, 13, 2)
spring <- c(6, 11, 14, 3)

member_years_rugby <- rbind(fall, spring)
colnames(member_years_rugby) <- c("first_yr", "second_yr", "third_yr", "fourth_yr")
@

Here is the matrix:

\begin{lstlisting}
_      first_yr second_yr third_yr fourth_yr
fall          8        12       13         2
spring        6        11       14         3
\end{lstlisting}

We'd like to add this matrix as an object to the rugby\_club list, which currently contains three objects

\begin{lstlisting}[language=R]
$club_title
[1] "Rugby Club"

$club_description
[1] "Plays matches against clubs from local universities"

$club_dues
[1] 80 60
\end{lstlisting}

Let's add member\_years\_rugby as a fourth object of the list. To add an element to a list, we can specify the position we want the new element to occupy using double brackets:

\begin{lstlisting}[language=R]
rugby_club[[4]] <- member_years_rugby
\end{lstlisting}

<<>>=
rugby_club[[4]] <- member_years_rugby
@

The resulting rugby\_club list contains the member\_years\_rugby matrix as a fourth object:

\begin{lstlisting}[language=R]
$club_title
[1] "Rugby Club"

$club_description
[1] "Plays matches against clubs from local universities"

$club_dues
[1] 80 60

[[4]]
       first_yr second_yr third_yr fourth_yr
fall          8        12       13         2
spring        6        11       14         3
\end{lstlisting}

Recall that elements added to a list do not have names associated with them unless we specify them.

We could assign a name to the object as we learned earlier in this mission. If we want to append member\_years\_rugby to rugby\_club and give it a name, we would write:

\begin{lstlisting}[language=R]
rugby_club[["member_years_rugby"]] <- member_years_rugby
\end{lstlisting}

<<>>=
rugby_club[["member_years_rugby"]] <- member_years_rugby
@

We've researched chess club membership and found the following numbers of first-year members that joined during the fall and spring semesters last year:

Fall Semester: 12 Spring Semester: 15

Let's add this information to our chess\_club list.

Instructions

We have created a vector, first\_years, that contains the number of first-year chess club members for last year's fall and spring semesters.

Add the first\_years vector as an object, of the same name, to the end of the chess\_club list.

Use the syntax chess\_club[["object\_name"]] <- object to add the vector with an assigned name.

Index chess\_club to display the number of first-year students that participated in chess club during last year's spring semester.

<<>>=
first_years <- c(12, 15)
names(first_years) <- c("fall", "spring")

first_years
chess_club
chess_club[["first_years"]]<-first_years
chess_club
@

%============================================================================
\subsection{Combining Lists}
%============================================================================

In this mission, we've been creating lists of data for several clubs:

rugby\_club

ballroom\_dancing

chess\_club

Perhaps we'd like to combine them into a single list.

Syntax for combining multiple lists is similar to that for combining vectors. To combine the rugby\_club and ballroom\_dancing lists into a new list called uni\_club\_data, we can use the c() function:

\begin{lstlisting}[language=R]
uni_club_data <- c(rugby_club, ballroom_dancing)
\end{lstlisting}

<<>>=
uni_club_data <- c(rugby_club, ballroom_dancing)
uni_club_data
@

The new uni\_club\_data list contains all of the objects present in the two lists we combined.

\begin{lstlisting}[language=R]
$club_title
[1] "Rugby Club"

$club_description
[1] "Plays matches against clubs from local universities"

$club_dues
[1] 80 60

$member_years_rugby
       first_yr second_yr third_yr fourth_yr
fall          8        12       13         2
spring        6        11       14         3

$club_title
[1] "Ballroom Dancing Club"

$club_description
[1] "Practices waltz, salsa, and tango dancing for competitions with local university dance teams"

$club_dues
[1] 150
\end{lstlisting}

Combining lists using c() attaches lists to one another, end-to-end, to create a single list. We can use it to combine as many lists as we need to.

The uni\_club\_data list is confusing because some of the elements, like club\_description, have the same name. We need a way to combine lists that preserves the organization of each list.

Recall that lists can contain any type of data object, including other lists. Instead of combining elements of the three lists into a single list as you did using c(), you can use list() to create a new list of lists. Let's create a list of lists, uni\_club\_list, to illustrate how this works.

Recall the syntax for creating a list of named objects from earlier in this mission:

\begin{lstlisting}[language=R]
uni_club_list <- list(rugby_club = rugby_club, ballroom_dancing = ballroom_dancing)
\end{lstlisting}

<<>>=
uni_club_list <- list(rugby_club = rugby_club, ballroom_dancing = ballroom_dancing)
uni_club_list
@

The resulting list contains the two lists, rugby_club and ballroom_dance, as objects:

\begin{lstlisting}[language=R]
$rugby_club
$rugby_club$club_title
[1] "Rugby Club"

$rugby_club$club_description
[1] "Plays matches against clubs from local universities"

$rugby_club$club_dues
[1] 80 60

$rugby_club[[4]]
\end{lstlisting}

Notice that the name of each object in uni_club_list follows the name of the list it belongs to (either rugby\_club or ballroom\_dancing).

Creating a list of lists will be a technique we use when you want to perform the same operation on multiple lists at the same time in future courses.

For now, let's practice by creating a list of the three lists of club data we've worked with in this mission.

Instructions

Create a new list, uni\_clubs, that contains the following lists:

rugby\_club

ballroom\_dancing

chess\_club

Instead of combining the list objects into a single list, create a list of lists by using the list() function.

Write your code so that each list within uni\_clubs is named. Keep the original list names.

<<>>=
uni_clubs<-list(rugby_club=rugby_club,ballroom_dancing=ballroom_dancing,chess_club=chess_club)
uni_clubs
@
%==============================================================================
\subsection{Next steps}\label{chunkrecent_grads}
%==============================================================================

So far in this course, you've made great strides in learning basic R syntax and becoming familiar with some of the language's important data structures: vectors, matrices, and lists. You've used these skills to work with and analyze several data sets as you've calculated grades, ranked universities, and organized club data.

In the next mission, you'll import data into R, store it as a data frame, and take a deeper dive into analysis.

<<>>=
recent_grads<-read.csv(file="recent_grads.csv",head=TRUE,sep=',')
str(dataset)
@


\newpage

%================================================================
\section{Working with Dataframes}
\subsection{Introduction to Data Frames}
%================================================================

In the last few missions, we've worked with vectors, matrices, and lists as we calculated final grades, ranked universities, and organized club data. In this mission, we'll analyze data on college (university) majors (areas of study) as we learn to work with another of R's data structures: data frames.

Data frames are probably the most common structures you'll work with when analyzing data in R, so we'll help you to build a strong foundational understanding of how to manipulate then. Like lists, data frames can contain multiple data types. Unlike lists, though, all elements of a data frame are vectors of equal length.

In this mission, we'll also introduce you to some R packages designed to make doing data science with data frames maximally efficient. In R, packages consist of user-contributed functions, code, and data that extend R's capabilities.

In this course so far, you have learned how to program using "base R", which is how we refer to the basic functions of R that are available without installing any additional packages.

In this mission, we'll learn about two packages, readr and dplyr, that are part of a "family" of packages collectively referred to by the R community as "the tidyverse". We'll learn more about the tidyverse, its principles, and how using its packages can improve your data science workflow in future courses.

Choosing a Major

Earlier in this course, we selected a university to attend (Harvard). In this mission, we'll identify majors that would be a good fit for you.

To understand pros and cons of various majors, we obtained data on recent graduates from FiveThirtyEight's GitHub account and saved a subset of it for you to work with in this mission.

Here's a description of the variables in the data set:

Rank: Rank by median earnings

Major\_code: Major code

Major: Major description

Total: Total number of people with major

Men: Male graduates

Women: Female graduates

Major\_category: Category of major

Sample\_size: Sample size (unweighted) of full-time, year-round

ONLY (used for earnings)

Employed: Number employed

Full\_time: Employed 35 hours or more

Part\_time: Employed less than 35 hours

Full\_time\_year\_round: Employed at least 50 weeks and at least 35 hours

Unemployed: Number unemployed

Unemployment\_rate: Unemployed / (Unemployed + Employed)

Median: Median earnings of full-time, year-round workers

College\_jobs: Number with job requiring a college degree

Non\_college\_jobs: Number with job not requiring a college degree

Low\_wage\_jobs: Number in low-wage service jobs

As we prepare to choose a major, we've decided on three main criteria:

You're interested in the physical and life sciences.

You'd like a decent salary. Recent graduates must have a median salary above 40,000 USD.

You'd like to avoid male-dominated majors. More than 40 percent of graduates must be women.

In this mission, as we identify the majors that satisfy our criteria, we'll perform the following steps:

Import the data into R as a data frame and explore it.

Select college major data that meet our criteria.

Create a new data frame containing data on majors for you to consider.

%=====================================================================
\subsection{Installing packages}

To work with the data, we'll import it into R and save it as a data frame. This is a very common first step in a data analysis workflow, and one that will probably become very familiar to you as you get more practice analyzing data.

Instead of using base R functions for data import, we'll learn to use a package called readr that contains functions for importing data of various formats into R.

The readr package is part of the tidyverse collection of packages. It is designed to improve the data science workflow in a few ways:

Speed: Importing larger data files with readr functions is generally faster than using base R functions.

Code reproducibility: While base R function behavior depends in part on your operating system and environment variables, this is not the case for readr. When you use readr to import files, code that works on your computer will work on someone else’s.

Consistency: The readr package shares a common syntax and design philosophy with other tidyverse packages that we'll introduce in upcoming courses.
To install an R package, we use the function install.packages().

\begin{lstlisting}
install.packages("readr")
\end{lstlisting}

This function installs our desired packages from the Comprehensive R Archive Network (CRAN) repository. Note that you need to surround the package name with quotation marks.

Once we've installed packages once, we won't need to do so with each new R session (something we'll get more context for in an upcoming course, where we'll install an environment for R programming on your own computer).

We will, however, need to load packages we want to work with when beginning a new session. To load packages, we'll use the function library():

\begin{lstlisting}
library(readr)
\end{lstlisting}

We do not need to surround package names with quotation marks to load them using the library() function.

Let's load the readr package.

Instructions

Use the library() function to load the readr package.

%============================================================================
\subsection{Importing data into R}
%===========================================================================

Now that we've loaded the readr package, let's import our college majors data into R.

The data set is stored in a file format called .csv, which stands for "comma separated value". Files in CSV format contain characters with spacing indicated by commas. If we open the file with a text editing program, the first few rows are difficult to understand:

\begin{lstlisting}
Rank,Major_code,Major,Total,Men,Women,Major_category,ShareWomen,Sample_size,Employed,Full_time,Part_time,Full_time_year_round,Unemployed,Unemployment_rate,Median,P25th,P75th,College_jobs,Non_college_jobs,Low_wage_jobs
1,2419,PETROLEUM ENGINEERING,2339,2057,282,Engineering,0.120564344,36,1976,1849,270,1207,37,0.018380527,110000,95000,125000,1534,364,193
2,2416,MINING AND MINERAL ENGINEERING,756,679,77,Engineering,0.101851852,7,640,556,170,388,85,0.117241379,75000,55000,90000,350,257,50
3,2415,METALLURGICAL ENGINEERING,856,725,131,Engineering,0.153037383,3,648,558,133,340,16,0.024096386,73000,50000,105000,456,176,0
\end{lstlisting}

To import the data into R in the format of a table that we can more easily read, we'll need to use a function that's appropriate for working with data stored in a CSV.

The readr package contains a function, read\_csv(), that's specifically for importing data in CSV format into R. We can store the imported data as a data frame by assigning it to a variable name, as we learned to do for vectors and matrices in previous missions.

\begin{lstlisting}
new_data_frame <- read_csv("filename.csv")
\end{lstlisting}

When we use the read\_csv() function, R will return a message letting us know the data types it assigned to each column. This is not an error message, and not a cause for concern. We'll talk more about data types included in data frames as we continue through this mission.

The data we'll analyze in this mission are stored in file called "recent\_grads.csv". Let's import these data into R and store them in a data frame called recent\_grads.

Instructions

Use the read\_csv() function to import the file "recent\_grads.csv" into R.

Store this in a data frame called recent\_grads.

Ver solução da \ref{chunkrecent_grads}

\begin{lstlisting}[language=R]
library(readr)
recent_grads<-read_csv("recent_grads.csv")
\end{lstlisting}

%===============================================================================
\subsection{Tibbles: Specialized Data Frames}
%===============================================================================

Let's investigate the data we've imported and saved as a data frame.

Here are the first ten rows of the recent\_grads data frame:

[tabela aqui]

The data frame also contains additional information:

Data Types: Under each column name, the type of data contained in the column is indicated as an abbreviation: chr, int, and dbl stand for "character", "integer", and "double".

Identity and Dimensions: At the top left of the output you'll see this line: A tibble: 173 x 18, which tells us that we have imported and stored our data as a tibble, which is a specific type of data frame in R. The following numbers specify the tibble dimensions (rows x columns).

Let's talk more about tibbles. When you use the readr package to import your data into R, the result is a special type of data frame called a tibble. Tibbles are the same as data frames in base R in a few ways: They are two-dimensional data structures and can store data of multiple types.

We are introducing the readr package and tibbles because they have several important advantages for doing data science:

Conservative printing: You can type the name of a tibble and R will only print the first 10 rows; this prevents accidentally wasting time as thousands of rows of data print, as can happen with base R data frames.

Clarity: When you print a tibble, the data type for each column is conveniently listed alongside the name.

Consistency: Unlike base R data frames, tibbles will never change the type of the inputs, the names of variables, or the row names. This will be important when you share your code with colleagues.

Since tibbles are specialized data frames, we can refer to them as "tibbles" or "data frames" interchangeably. In this course and future ones, we will simply refer to them as "data frames".

%==========================================================================
\subsection{Indexing dataframes}
%=========================================================================

When we want to return a specific column, row, or value from a data frame, we can index them. The syntax for indexing data frames is very similar to the syntax we used to index matrices.

Let's say we want to return the column of the data frame containing Major. We can perform this operation using several techniques.

We could index the data frame by position.

\begin{lstlisting}[language=R]
recent_grads[, 3]
\end{lstlisting}

<<>>=
recent_grads[, 3]
@

We could index by column name:

\begin{lstlisting}[language=R]
recent_grads[, "Major"]
\end{lstlisting}

<<>>=
recent_grads[, "Major"]
@

We can also use the \$ symbol to specify a column:

\begin{lstlisting}[language=R]
recent_grads$Major
\end{lstlisting}

<<>>=
recent_grads$Major
@

Let's say that instead of a certain column, we want to extract a row of a data frame.

To return the fifth row of the data frame, we could write:

\begin{lstlisting}[language=R]
recent_grads[5,]
\end{lstlisting}

<<>>=
recent_grads[5,]
@


We can also index to extract a subset of values, as we learned to do for matrices.

If we wanted to extract the fifth row of the Major column in the recent_grads data frame, we can write:

\begin{lstlisting}[language=R]
recent_grads[5,3]
\end{lstlisting}

<<>>=
recent_grads[5,3]
@

We can also write the following code, which specifies the column using \$ and the row number in brackets:


\begin{lstlisting}[language=R]
recent_grads$Major[5]
\end{lstlisting}

<<>>=
recent_grads$Major[5]
@

As with matrices, we can specify multiple elements to extract from a data frame. Let's extract the first ten rows of the Major and Major\_category columns.

\begin{lstlisting}[language=R]
recent_grads[c(1:10), c("Major", "Major_category")]
\end{lstlisting}

<<>>=
recent_grads[c(1:10), c("Major", "Major_category")]
@

Let's practice indexing the recent\_grads data frame.

Instructions

Extract the Major column of the recent\_grads data frame and save the output in a variable named college\_majors.

Extract the first, third, and fifth rows of the Unemployment\_rate column and save the output dataframe in a variable named unemployment\_subset.


<<>>=
college_majors <- recent_grads$Major
unemployment_subset <- recent_grads[c(1,3,5), "Unemployment_rate"]
@

%=======================================================================
\subsection{Selecting Data Columns}

Now that we've imported our data into R as a data frame and learned about data frame indexing, let's continue with our goal of choosing a college major.

As a reminder, our three criteria for choosing a major are:

You're interested in the physical and life sciences.

You'd like a decent salary. Recent graduates must have a median salary above 40,000 USD.

You'd like to avoid male-dominated majors. More than 40 percent of graduates must be women.

When we look at the recent\_grads data frame, we can see that each row contains information about a college major, and each column contains data about a different aspect of each college major. These different aspects, like Major\_category, Full\_time, and Unemployment\_rate, are called variables.

Let's start by simplifying our data frame to contain only variables that are important for our analysis. We'll do this by selecting a subset of the columns.

While we could index the data frame to return a subset of columns, we'll introduce tools in a tidyverse package designed specifically for analyzing data in data frames: dplyr.

Here's the code we would write to install and load the package:

\begin{lstlisting}
install.packages("dplyr")
library(dplyr)
\end{lstlisting}

Next, let's use the dplyr function select() to create a new data frame with only columns containing the variables we want to keep for our analysis:

Using the select() function, we'll specify the data frame we want to work with and the columns we want to select. To save the output as a new data frame, we'll use the same notation we learned in previous missions to assign function output to a variable.

To perform the operation depicted in the diagram, we would write the following code:

\begin{lstlisting}[language=R]
recent_grads_select <- recent_grads %>%
    select(Major, Total, Men, Women, Major_category)
\end{lstlisting}

<<>>=
library(magrittr)
library(dplyr)
recent_grads_select <- recent_grads %>%
    select(Major, Total, Men, Women, Major_category)
@

Notice the \%$>$\% symbol, which we haven't seen before: This is called the "the pipe operator," and its purpose is to help you write code that's easier to write, read, and understand. When you load packages in the tidyverse family of functions, \%$>$\% is loaded automatically.

The pipe lets you write code that chains series of operations together; in the case of the code above, we could read the code as, "take the recent\_grads data frame and select the Major, Total, Men, Women, and Major\_category columns."

We'll learn more about the pipe and how it can simplify and streamline your code in upcoming courses. For now, we introduce it so that we can start to get used to using it in our code.

Let's select the columns of our recent\_grads data frame that will be relevent to our analysis of college majors.

Instructions

Create a new data frame, recent\_grads\_select, that contains only the following variables from recent\_grads:

Major


Major\_category


Total


Men


Women


Median


Unemployment\_rate

<<>>=
#para passar o pipe utilize library(magrittr)
#para fazer o select use library(dplyr)
recent_grads_select <- recent_grads %>%
    select(Major, Major_category, Total, Men, Women, Median, Unemployment_rate)
    
recent_grads_select
@

%===========================================================================
\subsection{Adding a New Column}
%==========================================================================

Now that we've created a simplified data frame containing only variables we'll need for our analysis, let's consider whether there are any variables we need to add to our data frame to help us choose college majors based on your criteria. To make this decision, let's read through the criteria and look at the data we have available in recent\_grads\_select.

1. You're interested in the sciences.

The Major\_category variable contains information about the field of study. We can use this information to identify majors in the physical and life sciences.

2. Recent graduates must have a median salary above 40,000 USD.

The Median variable provides median salaries for each major. We can use this information to identify majors with median salaries greater than 40,000 USD.

3. More than 40 percent of graduates must be women.

There is not a variable that tells us the percentage of graduates for each major that are women. However, we do have information about the total number of graduates (Total), the number of graduates who are men (Men), and the number of graduates who are women (Women).

We can create a new variable in a new column that contains the percentage of women graduates. Let's learn how!

To create new variables and add them to our data frame as columns, we'll use a function in the dplyr package called mutate(). We can use the mutate function to create a new column based on information contained in existing columns.

Let's say we wanted to know the percentage of men graduating in each major. Since we know the total number of graduates (Total) and the total number of those graduates who are men (Men), we can write an expression to calculate the percentage of male graduates:

\begin{lstlisting}
(`Men` / `Total`) * 100
\end{lstlisting}

<<>>=
(`Men` / `Total`) * 100
@

How do we create a new column containing the percentage of men for each major? This is where mutate() comes in. The mutate function lets us specify the creation of a new column, as well as how the values contained in that new column are calculated:

Here's the syntax for creating a data frame with a new column, Men\_percent, that contains the percentage of men graduating in each major:

\begin{lstlisting}
data_frame_2 <- data_frame_1 %>%
    mutate(Men_percent = (Men/Total)*100)
\end{lstlisting}


Within the mutate() function, we'll specify a name for our new column and then use "=" to indicate how you want the values that fill it to be calculated.

Remember to use the pipe operator to specify the data frame we're working on and then the function we want to apply.

Now, let's change our recent\_grads\_select data frame so that it contains a new column with the variable Women\_percent.

Instructions

Use the mutate() function to create a new column (Women\_percent) containing the percent of women graduating in each major.

To replace the existing recent\_grads\_select data frame, save your data frame with the name recent\_grads\_select.

<<>>=
recent_grads_select <- recent_grads %>%
    select(Major, Major_category, Total, Men, Women, Median, Unemployment_rate)

recent_grads_select<-recent_grads_select %>%
mutate(Women_percent=(Women/Total)*100)
str(recent_grads_select)
@

%=================================================================
\subsection{Filtering by a Single Condition}
%================================================================

So far, we've made progress toward selecting college majors by:

Simplifying our data set to contain only columns with relevent variables.

Creating a new column with a variable to help us assess which majors aren't male-dominated.

Now, we'll further narrow down the majors in our data frame to identify those that meet your criteria.

Let's have a look at the first few rows of recent\_grads\_select:

<<>>=
#so mostro as primeiras cinco linhas do dataset
recent_grads_select[1:5,]
@

By looking through the data in the Women\_percent column, we can see that many of the values are lower than our minimum criteria for a major's percentage of women graduates (40 percent). We know that these majors don't suit our criteria, so we'd like to remove them from our data frame.

To remove majors with percentages of women graduates below 40 percent, we'll use another dplyr function: filter().

We can use filter() to specify conditions that values of a variable must meet in order to be retained in a data frame.

Let's look at some examples. We could to use filter() to create a new data frame containing only majors where less than 70 percent of graduates are men:

Within the filter() function, we'll use the comparison operators we learned about earlier in this course to specify criteria. In this case, we'd specify that we want to retain rows where Men\_percent is less than 70 by writing the expression Men\_percent $<$ 70:

\begin{lstlisting}[language=R]
data_frame_2 <- data_frame_1 %>%
  filter(Men_percent < 70)
\end{lstlisting}

In this case, we used filter() to specify criteria involving numeric data values. We can also use filter() to work with character data. For example, we could filter by rows of data\_frame\_1 where the Major\_category was Physical Science:

To filter our data frame by elements of variables that consist of character data, we'll only be using the == comparison operator in this mission:

\begin{lstlisting}[language=R]
data_frame_2 <- data_frame_1 %>%
    filter(Major_category == "Physical Science")
\end{lstlisting}

Remember to use quotation marks around the character data we're specifying.

Let's practice filtering our college major data by criteria.

Instructions

Filter the recent\_grads\_select data frame to create a new data frame called recent\_grads\_health that contains only data on majors in the Health field (the Major\_category variable).

Filter the recent\_grads\_select data frame to create a new data frame called recent\_grads\_money that contains only data on majors where recent graduates' median (the Median variable) salary is greater than 70,000 USD.

<<>>=
recent_grads_health<-recent_grads_select %>%
    filter(Major_category=="Health")
recent_grads_money<-recent_grads_select %>%
filter(Median>70000)

recent_grads_health[1:5,]
recent_grads_money[1:5,]
@

%===========================================================================
\subsection{Filtering by Multiple Conditions: Meeting At Least One Criterion}
%==========================================================================


Filtering by individual criteria can be effective. However, we have several criteria we want our selected majors to meet. We can also use the filter() function to retain rows of a data frame that fit multiple criteria.

What if we wanted to create a new data frame containing college majors that met either of the following criteria:

Majors in the Engineering catagory (Major\_category == "Engineering")
Majors with over 1,000 total graduates (Total $>$ 1000)

In the example above, all college majors in data\_frame\_1 meet at least one of the criteria you specified. We can think of the criteria you want our college majors to meet as being described by the following statement:

"Majors that are either in the engineering category or have over 1,000 graduates"

When we write code to specify that we are filtering for rows of our data frame that meet these criteria, we will use an operator to denote the "or" in the statement above: |. When we are filtering by multiple criteria, the | operator specifies we want to retain rows of our data frame that meet at least one of the criteria we specify.

To use filter() to create a new data frame containing college majors that are either in the engineering category or have more than 1,000 total graduates, we would write:

\begin{lstlisting}[language=R]
data_frame_2 <- data_frame_1 %>% 
    filter(Major_category == "Engineering" | Total > 1000)
\end{lstlisting}

As we work on identifying possible college majors, we need to filter our data frame to select majors that meet our criteria for being in the science categories. Let's use the filter() function to create a new data frame that contains only college majors in the Biology \& Life Science and Physical Sciences categories.


Instructions

Create a new data frame that contains only data on college majors that are either in the Biology \& Life Science OR Physical Sciences categories (Major\_category). Name the new data frame recent\_grads\_science.

<<>>=
recent_grads_science<-recent_grads_select %>%
filter(Major_category=="Biology & Life Science"|Major_category=="Physical Sciences")

recent_grads_science[1:5,]
@
%========================================================================
\subsection{Filtering by Multiple Conditions}

We have now created a new data frame containing only data for college majors in the life and physical sciences. Now we'll filter that data frame, recent\_grads\_science, to retain only college majors that meet our remaining two criteria:

Recent graduates must have a median salary above 40,000 USD More than 40 percent of graduates must be women We'll use filter() and write an expression that will allow us to specify our two criteria. However, in this case, we'll want the college majors you retain in a new data frame to meet both the criteria rather than at least one of them.

For example, we may want to filter data\_frame\_1 to retain only college majors that meet both of the following criteria:

Majors in the Engineering catagory (Major_category $==$ "Engineering")
Majors with over 1,000 total graduates (Total $>$ 1000)

To include both expressions in the filter() function, we will introduce another operator: \&

As illustrated in the figure shown above, the \& operator specifies that both criteria in an expression must be met.

To use filter() to create a new data frame containing only engineering college majors with more than 1,000 total graduates, we'd write:

\begin{lstlisting}
data_frame_2 <- data_frame_1 %>% 
    filter(Major_category == "Engineering" & Total > 1000)
\end{lstlisting}

Let's create a new data frame containing only college majors that meet all three of our criteria for college majors. To accomplish this, we'll use filter() and the \& operator to filter rows in the recent\_grads\_science data frame to retain only majors that have women as greater than 40 percent of total graduates and median salaries above 40,000 USD.

Instructions

Filter the recent\_grads\_science data frame to create a new data frame containing only data on college majors meeting both the following criteria:

Median $>=$ 40000

Women\_percent $>$ 40

Name the new data frame potential\_majors.


<<>>=
potential_majors<-recent_grads_science %>%
filter(Median>=40000&Women_percent>40)

potencial_majors[1:5,]
@
%===================================================================================
\subsection{Arranging Data Frames by Variables}
%==================================================================================

We now have a data frame, potential\_majors, containing data for seven college majors that fit our criteria:

Physical and life sciences

Recent graduates must have a median salary above 40,000 USD
More than 40 percent of graduates must be women

The full names of the majors, which are abbreviated in the data frame printout to save space, are:

ASTRONOMY AND ASTROPHYSICS

NUCLEAR, INDUSTRIAL RADIOLOGY, AND BIOLOGICAL TECHNOLOGIES

PHARMACOLOGY

OCEANOGRAPHY

COGNITIVE SCIENCE AND BIOPSYCHOLOGY

MOLECULAR BIOLOGY

GENETICS

These are all good options, but we want to refine our list of college majors further. You've heard from friends who recently graduated college that some of them are struggling to find jobs. To maximize your chances of finding employment after graduation, let's investigate the Unemployment\_rate variable in.

Unemployment\_rate is calculated by dividing the total number of unemployed graduates by the total number of graduates. Values range from zero to one.

Let's arrange our data frame in order of ascending unemployment rate. We'll want entire rows of the data frame arranged in order of unemployment rate, from lowest to highest.

To arrange our data frame rows by Unemployment\_rate, we'll use another function in the dplyr package: arrange().

The arrange() function lets you specify a variable we want to use to re-order the rows of your data frame. Let's say we want to arrange data\_frame\_1 by Total:

To perform the operation indicated in the diagram above, we'd use the arrange() function to specify the column we wanted to use to re-order data\_frame\_1:

\begin{lstlisting}[language=R]
data_frame_2 <- data_frame_1 %>% 
  arrange(Total)
\end{lstlisting}

By default, arrange() orders the rows of a data frame by the specified variable in ascending order, from lowest to highest.

We can also use arrange() to order rows of a data frame by a variable in descending instead of ascending order; that is, from largest to smallest. To specify that we want to arrange rows by a variable in descending order, we can surround variables with desc(), short for "descending".

For example, if we want to re-order data\_frame\_1 in order of Total from largest to smallest, we can write:


\begin{lstlisting}
data_frame_2 <- data_frame_1 %>% 
  arrange(desc(Total))
\end{lstlisting}

We can arrange data frames by multiple numeric variables as well. If we specify multiple variables, R will reorder rows of the data frame by each variable in order, moving from left to right.

To arrange data\_frame\_1 in order of ascending Total and descending Men\_percent, we could write:

\begin{lstlisting}
data_frame_2 <- data_frame_1 %>% 
  arrange(Total, desc(Men_percent))
\end{lstlisting}

Let's arrange the potential_majors data frame so that majors with the lowest unemployment rates and the highest median salaries are at the top.

Create a new data frame, my\_majors, containing the data in the potential\_majors data frame arranged in order of increasing Unemployment\_rate and decreasing Median (in that order).

<<>>=
my_majors<-potential_majors %>%
 arrange(Unemployment_rate,desc(Median))
 
my_majors[1:5,]
@
%====================================================================
\subsection{Next Steps}
%===================================================================

In this mission, we completed a typical data analysis workflow: Importing data into R, investigating it, simplifying our data frame, and performing some analysis.

We've created a new data frame that contains data on seven college majors that suit our criteria, and arranged the majors for maximizing median salary and minimizing unemployment rates of recent graduates:

Based on our analysis, your top three choices for college majors are:

ASTRONOMY AND ASTROPHYSICS

GENETICS

OCEANOGRAPHY

You've come a long way. In this course, you've learned basics of R programming, started working with packages to maximize R's functionality, and analyzed real-world data.

The next mission is the last in this course, and it's organized a bit differently. We'll walk you through installing RStudio, a popular environment for R programming, on your own computer.

Then, you'll be able to start practicing analyzing data in R on your own!


%================================================================

\newpage









\newpage
%===============================================================================
\subsection{Combining vectors into matrices}
%===============================================================================

Let's start by creating a matrix containing the university ranking data so we can begin analyzing it to find your ideal university.

We'll begin with vectors containing the rankings for each university. Recall from earlier in the course that we use the c() function to create vectors:

\begin{lstlisting}[language=R]
harvard <- c(1,1,1,1,3)
stanford <- c(2,9,3,4,10)
MIT <- c(3,3,2,2,1)
cambridge <- c(4,2,6,13,48)
oxford <- c(5,7,12,9,15)
columbia <- c(6,13,13,12,4)
\end{lstlisting}

<<>>=
harvard <- c(1,1,1,1,3)
stanford <- c(2,9,3,4,10)
MIT <- c(3,3,2,2,1)
cambridge <- c(4,2,6,13,48)
oxford <- c(5,7,12,9,15)
columbia <- c(6,13,13,12,4)
@


Combining vectors into matrices is straightfoward because of similarities in the two data structures. Both consist of a single data type (here, numeric). In this case, we can picture creating a matrix by stacking university ranking vectors one on top of the other with elements lined up by position:

vectors to matrix

To combine vectors into a matrix, we can use the function rbind(). The "r" in rbind() stands for rows — this function allows us to combine multiple vectors by row. To demonstrate, let's combine the harvard and stanford vectors using rbind():

\begin{lstlisting}[language=R]
harv_stan <- rbind(harvard, stanford)
\end{lstlisting}

<<>>=
harv_stan <- rbind(harvard, stanford)
harv_stan
@


The resulting matrix contains rankings for Harvard and Stanford:

\begin{lstlisting}
[,1]	[,2]	[,3]	[,4]	[,5]
harvard	1	1	1	1	3
stanford	2	9	3	4	10
\end{lstlisting}

We can also use rbind() to add a single row to an existing matrix, or to combine two matrices by stacking them. For example:

\begin{lstlisting}[language=R]
rbind(harv_stan, MIT)
\end{lstlisting}

<<>>=
rbind(harv_stan, MIT)
@

Using rbind(), we have added the MIT vector to harv\_stan as a new row:

\begin{lstlisting}
[,1]	[,2]	[,3]	[,4]	[,5]
harvard	1	1	1	1	3
stanford	2	9	3	4	10
MIT	3	3	2	2	1
\end{lstlisting}

Let's create a matrix containing all the university data.

Instructions

We have vectors containing ranking data for each university. Create a matrix, named uni\_matrix, from these vectors using the rbind() function:

harvard

stanford

MIT

cambridge

oxford

columbia

<<>>=
harvard <- c(1,1,1,1,3)
stanford <- c(2,9,3,4,10)
MIT <- c(3,3,2,2,1)
cambridge <- c(4,2,6,13,48)
oxford <- c(5,7,12,9,15)
columbia <- c(6,13,13,12,4)
uni_matrix<-rbind(harvard,stanford,MIT,cambridge,oxford,columbia)
uni_matrix
@

%==============================================================================
\subsection{Naming Matrix Rows and Columns}
%==============================================================================

The matrix we created contains ranking data for each university:

\begin{lstlisting}
[,1]	[,2]	[,3]	[,4]	[,5]
harvard	1	1	1	1	3
stanford	2	9	3	4	10
MIT	3	3	2	2	1
cambridge	4	2	6	13	48
oxford	5	7	12	9	15
columbia	6	13	13	12	4
\end{lstlisting}

When we use the rbind() function to create a matrix from vectors with name attributes, the vector names are retained as row name attributes. However, our columns don't have any name attributes associated with them. Adding names to rows or columns of a matrix is similar to naming elements of a vector.

Keep in mind that attributes are different from elements of vectors or matrices — they are not stored in these data structures, and you cannot perform operations on them. Attributes make interpreting the contents of vectors and matrices easier.

In the previous mission, we learned to add name attributes to vectors using the attribute accessor function names(). Since matrices have both rows and columns, there are separate functions for adding name attributes to each:

Rows: rownames()

Columns: colnames()

We already have university names for rows of uni\_matrix, but we need to add column names so that we can see the categories for each university's rankings.

To illustrate how this works, let's name the columns in the harv\_stan matrix we created in an earlier example:

\begin{lstlisting}
harv_stan <- rbind(harvard, stanford)

colnames(harv_stan) <-c("world_rank","quality_of_education","influence","broad_impact","patents")
\end{lstlisting}

<<>>=
harv_stan <- rbind(harvard, stanford)

colnames(harv_stan) <-c("world_rank","quality_of_education","influence","broad_impact","patents")
@

If we inspect harv\_stan, we can see the columns are named:

world\_rank

quality\_of\_education

influence

broad\_impact

patents

harvard	1	1	1	1	3

stanford	2	9	3	4	10


Naming rows using rownames() uses the same syntax.

Let's assign names to all columns of uni\_matrix.


<<>>=
uni_matrix <- rbind(harvard, stanford, MIT, cambridge, oxford, columbia)
categories <- c("world_rank", "quality_of_education", "influence", "broad_impact" ,"patents")
colnames(uni_matrix)<-c("world_rank", "quality_of_education", "influence", "broad_impact" ,"patents")
uni_matrix
@

%===============================================================================
\subsection{Finding Matrix Dimensions}
%==============================================================================

Now uni\_matrix has names associated with its rows and columns:

\begin{lstlisting}
world_rank
quality_of_education
influence	broad_impact	patents
harvard	1	1	1	1	3
stanford	2	9	3	4	10
MIT	3	3	2	2	1
cambridge	4	2	6	13	48
oxford	5	7	12	9	15
columbia	6	13	13	12	4
\end{lstlisting}

Let's return to our initial goal: Deciding which university to attend. As you look at your data, you notice that while you have information to help you assess education quality and impact of the six universities, you also would like to have information on the cost.

To address this, we've done some research and come up with data on annual tuition, in U.S. dollars, for each university:

Harvard \$43,280

Stanford \$45,000

MIT \$45,016

Cambridge \$49,350

Oxford \$28,450

Columbia \$55,161

We'll want to add this tuition data to our matrix so that we can proceed with analyzing the data to maximize your university choice.

First, let's create a vector containing the tuition data:

\begin{lstlisting}
tuition <- c(43280, 45000, 45016, 49350, 28450, 55161)
\end{lstlisting}

<<>>=
tuition <- c(43280, 45000, 45016, 49350, 28450, 55161)
@

Next, we need to add the tuition vector to uni\_matrix as a column. First, we should make sure that the new vector is of the right dimensions before combining it with our matrix. Recall that R's "recycling" behavior can result in unintended repeated values if objects are not the same length.

add a vector to a matrix

Since we're working with a small data set, it's easy to visualize the vector length and compare it to the number of rows in the matrix. However, as we work with larger data sets, this won't be the case.

In Mission 1, we learned how to use the length() function to identify the number of elements in a vector. Now, we'll learn how to identify the dimensions (numbers of rows and columns) of a matrix using the dim() function.

When a matrix is passed to the dim() function, the function output is a vector that contains two numbers: the number of rows and the number of columns in the matrix:

\begin{lstlisting}
dim(harv_stan)

2 5 # two rows, five columns
\end{lstlisting}

<<>>=
dim(harv_stan)
@

In the example above, the matrix harv\_stan has two rows and five columns.

Since the dim() function ouputs a vector, we can build on what we learned in the last mission about indexing vectors by position. We can write an expression to compare the length of a vector and the number of rows or columns in a matrix to determine if they are the same.

If we want to add the vector harv\_stan\_tuition as a new column to the harv\_stan matrix, we'll want the length of harv\_stan\_tuition to equal the number of rows in harv\_stan. Recall that the order of dimensions in the dim() output is always: rows, columns.

We can pass the harv\_stan matrix to the dim() function, and then used brackets to index the resulting vector of rows and columns. We will use [1] to return the number of rows, which is the element in the first position of the vector. We can write one line of code:

\begin{lstlisting}
dim(harv_stan)[1]
\end{lstlisting}

<<>>=
dim(harv_stan)[1]
@

To test whether the number of rows in the harv\_stan matrix is equal to the length of the harv\_stan\_tuition vector, we can write an expression to return a logical value (either TRUE or FALSE):

\begin{lstlisting}
dim(harv_stan)[1] == length(harv_stan_tuition)
\end{lstlisting}

<<>>=
dim(harv_stan)[1] == length(harv_stan_tuition)
@

Recall that the operator $==$ denotes "is equal to". Since the number of rows in harv\_stan is equal to the length of harv\_stan\_tuition, the output of this expression is:

TRUE
Let's write an expression to confirm that the tuition vector is as long as uni_matrix is tall.

Instructions

Write an expression to return TRUE if the number of rows in uni\_matrix is equal to the length of tuition.

<<>>=
tuition <- c(43280,45000,45016,49350,28450,55161)
dim(uni_matrix)==length(tuition)
@

%==============================================================================
\subsection{Adding Columns to Matrices}
%==============================================================================

Now that we have confirmed that the tuition vector is the same length as the number of rows in uni\_matrix, we can add it to the matrix as a column.

Earlier in this mission, we used the rbind() function to combine the university rankings vectors into a single matrix. The rbind() functions combines vectors or matrices by row.

rbind

To add a vector to a matrix as a column or to join two matrices together by column, we'll use the cbind() function. The cbind() function combines vectors or matrices by column.

cbind

Let's add tution data to our example matrix that contains only Harvard and Stanford rankings. To add the harv\_stan\_tuition vector to the harv\_stan matrix as a new column, we would write:

\begin{lstlisting}
cbind(harv_stan, harv_stan_tuition)
\end{lstlisting}

<<>>=
cbind(harv_stan, harv_stan_tuition)
@

The resulting matrix contains rankings for Harvard and Stanford, as well as tuition information for the two schools:

\begin{lstlisting}
world_rank	qual_of_ed	influence	broad_impact	patents	harv_stan_tuition

harvard	1	1	1	1	3	43280
stanford	2	9	3	4	10	45000
\end{lstlisting}

Note that the name attribute of the harv\_stan\_tuition vector is retained when it is appended to the matrix.

Let's add tuition data to our matrix.

Instructions

Add the tuition vector as a new column to uni\_matrix.
Save the new matrix containing rankings and tuition for each university as complete\_matrix.

<<>>=
complete_matrix<-cbind(uni_matrix,tuition)
complete_matrix
@
%====================================================================
\subsection{Adding Columns to Matrices}
%==============================================================================

Now that we have confirmed that the tuition vector is the same length as the number of rows in uni\_matrix, we can add it to the matrix as a column.

Earlier in this mission, we used the rbind() function to combine the university rankings vectors into a single matrix. The rbind() functions combines vectors or matrices by row.

rbind

To add a vector to a matrix as a column or to join two matrices together by column, we'll use the cbind() function. The cbind() function combines vectors or matrices by column.

cbind

Let's add tution data to our example matrix that contains only Harvard and Stanford rankings. To add the harv\_stan\_tuition vector to the harv\_stan matrix as a new column, we would write:

\begin{lstlisting}
cbind(harv_stan, harv_stan_tuition)
\end{lstlisting}

<<>>=
cbind(harv_stan, harv_stan_tuition)
@

The resulting matrix contains rankings for Harvard and Stanford, as well as tuition information for the two schools:

\begin{lstlisting}
world_rank	qual_of_ed	influence	broad_impact	patents	harv_stan_tuition
harvard	1	1	1	1	3	43280
stanford	2	9	3	4	10	45000
\end{lstlisting}

Note that the name attribute of the harv\_stan\_tuition vector is retained when it is appended to the matrix.

Let's add tuition data to our matrix.

Instructions

Add the tuition vector as a new column to uni\_matrix.
Save the new matrix containing rankings and tuition for each university as complete\_matrix.

<<>>=
complete_matrix<-cbind(uni_matrix,tuition)
complete_matrix
@

%=================================================================
\subsection{Indexing Matrices By Element}
%==============================================================================

Earlier in this course, we learned to index vectors to extract specfic elements. We can also index matrices. Since they are two-dimensional objects, we can either:

Index to select specific values

Index to select rows or columns

Let's look at the harv\_stan matrix as an example:

\begin{lstlisting}
world_rank	qual_of_ed	influence	broad_impact	patents	harv_stan_tuition
harvard	1	1	1	1	3	43280
stanford	2	9	3	4	10	45000
\end{lstlisting}

Let's say we want to extract the patents ranking for Stanford. Since matrices are two-dimensional, we'll need to specify the location of the element we want to extract in terms of its row and its column. In this matrix, Stanford is row 2 and patents is column 5.

index by position

Syntax for indexing matrices is similar to that for indexing vectors. You'll use brackets to specify row and column positions that define the location of the element you want to extract.

To index harv\_stan to extract Stanford's patent ranking, we can index by row (2) and column (5) positions:

\begin{lstlisting}
harv_stan[2, 5]

10
\end{lstlisting}

<<>>=
harv_stan[2,5]
@

Notice that, as with the output of the dim() function, row always comes before column for indexing operations.

We can also index matrices by row and column names instead of positions:

\begin{lstlisting}
harv_stan["stanford", "patents"]

10
\end{lstlisting}

<<>>=
harv_stan["stanford", "patents"]
@

When indexing by name, be sure to remember to surround row and column names with quotes.

What if you want to select more than one element of a matrix? Let's index to select broad\_impact and patents for Harvard and Stanford:

index a range

Since the broad\_impact and patents columns are next to each other in the matrix, we can specify the range of columns (4:5) in your indexing syntax:

\begin{lstlisting}
harv_stan[2, 4:5]

broad_impact      patents 
           4           10
\end{lstlisting}

<<>>=
harv_stan[2, 4:5]
@

We can also index matrices to extract elements that aren't next to each other. Let's say we're interested in extracting world\_rank and influence for Harvard and Stanford:

index multiple positions

In this case, we'll use c() to specify vectors containing the rows and columns in our indexing syntax:

\begin{lstlisting}
harv_stan[c(1,2), c(1,3)]
world_rank	influence
harvard	1	1
stanford	2	3
\end{lstlisting}

<<>>=
harv_stan[c(1,2), c(1,3)]
@

As was the case for extracting single elements, we can also index to extract multiple elements using names instead of positions:

\begin{lstlisting}
harv_stan[c("harvard", "stanford"), c("world_rank", "influence")]
world_rank	influence
harvard	1	1
stanford	2	3
\end{lstlisting}

<<>>=
harv_stan[c("harvard", "stanford"), c("world_rank", "influence")]
@

Let's practice indexing complete\_matrix.

Instructions

Index by name attributes to extract the following values from complete\_matrix:

Oxford's influence rank

Store the output as oxford\_influence

Cambridge's and Stanford's patents rank´

Store the output as cam\_stan\_patents

<<>>=
oxford_influence<-complete_matrix[5,3]
cam_stan_patents<-complete_matrix[c("cambridge","stanford"),c("patents")]
@

%===========================================================
\subsection{Subsetting Matrices by Rows and Columns}

We're now able to extract subsets of values from matrices. In some instances, though, it makes sense to index a matrix to extract entire rows or columns, such as all the rankings for a particular university.

For example, let's index harv\_stan to extract all the rankings for Harvard:

index by row

All the Harvard rankings are in row 1 of our matrix. To indicate that we want to index to extract all elements in row 1, leave the column position in the indexing expression blank:

\begin{lstlisting}
harv_stan["harvard",]
world_rank	quality_of_education	influence	broad_impact	patents
1	1	1	1	3
\end{lstlisting}

<<>>=
harv_stan["harvard",]
@

If we want to select the quality of education rankings for each university in our matrix, we'll index to select all elements in that column (column 2).

index by column

When we write an expression to extract an entire row or column from a matrix, we only need to specify the name of that row or column. The other position in the expression is left blank. Since column number always comes after row number, we would write:

\begin{lstlisting}
harv_stan[,"quality_of_education"]
\end{lstlisting}

<<>>=
harv_stan[,"quality_of_education"]
@

We can index to select multiple rows and columns from a matrix.

To select quality\_of\_education, influence, and broad\_impact rankings for all universities, we would index by those columns:

index by multiple columns

We can write an expression to specify selection of the columns using c():

\begin{lstlisting}
harv_stan[,c("quality_of_education", "influence", "broad_impact")]
\end{lstlisting}

<<>>=
harv_stan[,c("quality_of_education", "influence", "broad_impact")]
@

Note that, since we selected columns, c("quality\_of\_education", "influence", "broad\_impact") comes after the comma. If we were indexing to select multiple rows, they would come before the comma.

Let's get some practice extracting rows and columns from complete\_matrix.

Instructions

Index complete\_matrix to extract the following:

Oxford's rankings

Store the output as oxford\_rank

Influence ranks for all universities

Store the output as influence

All of Harvard's and MIT's rankings

Store the output as harv\_mit\_rank

Influence and patents rankings for all universities
Store the output as influence\_patents

<<>>=
complete_matrix
oxford_rank<-complete_matrix["oxford",]
oxford_rank
influence<-complete_matrix[,"influence"]
influence
harv_mit_rank<-complete_matrix[c("harvard","MIT"),c(1:6)]
harv_mit_rank
influence_patents<-complete_matrix[,c("influence","patents")]
influence_patents
@
%===================================================================
\subsection{Ranking Universites}
%==============================================================================

Now that we've learned to combine vectors into matrices and to extract elements, let's return to our initial goal: Analyzing the university ranking data to decide on a university to attend.

To answer this question, let's develop a score for each university that is an aggregate of the rankings and tuition information available in complete\_matrix. We'll rank the universities for each category we have data for: world_rank, quality\_of\_education, influence, broad\_impact, patents, and tuition.

Then, we can calculate a score for each university from the sum of its rankings.

Let's rank each university relative to others in the data set.

\begin{lstlisting}
complete_matrix
world_rank	quality_of_education	influence	broad_impact	patents	tuition
harvard	1	1	1	1	3	43280
stanford	2	9	3	4	10	45000
MIT	3	3	2	2	1	45016
cambridge	4	2	6	13	48	49350
oxford	5	7	12	9	15	28450
columbia	6	13	13	12	4	55161
\end{lstlisting}

<<>>=
complete_matrix
@

We'll use the rank() function, along with an expression that indexes the matrix, to specify the category we want to rank the universities by. The rank() function returns a vector of numeric values. For example, to rank universities by quality\_of\_education, we'd write:

\begin{lstlisting}
rank(complete_matrix[,"quality_of_education"])
harvard	stanford	MIT	cambridge	oxford	columbia
1	5	3	2	4	6
\end{lstlisting}

<<>>=
rank(complete_matrix[,"quality_of_education"])
@

Let's rank the universities in complete\_matrix by each category and save each ranking for each category as a new vector.

Instructions

Use rank() to rank the universities for each of the following categories:

world\_rank

quality\_of\_education

influence

broad\_impact

patents

tuition

Save the ranking vectors generated for each category with the following names:

world\_rank\_rank

quality\_of\_education\_rank

influence\_rank

broad\_impact\_rank

patents\_rank

tuition\_rank


<<>>=
world_rank_rank<-rank(complete_matrix[,"world_rank"])
world_rank_rank
quality_of_education_rank<-rank(complete_matrix[,"quality_of_education"])
quality_of_education_rank
influence_rank<-rank(complete_matrix[,"influence"])
influence_rank
broad_impact_rank<-rank(complete_matrix[,"broad_impact"])
broad_impact_rank
patents_rank<-rank(complete_matrix[,"patents"])
patents_rank
tuition_rank<-rank(complete_matrix[,"tuition"])
tuition_rank
@
%=====================================================================
\subsection{Scoring and Ranking Universities}
%==============================================================================

Now that we've ranked the six universities by each category, let's combine the vectors containing the ranks into a single matrix (ranks\_matrix) using rbind():

\begin{lstlisting}
ranks_matrix <- rbind(world_rank_rank, quality_of_education_rank, influence_rank, broad_impact_rank, patents_rank, tuition_rank)
harvard	stanford	MIT	cambridge	oxford	columbia
world_rank_rank	1	2	3	4	5	6
quality_of_education_rank	1	5	3	2	4	6
influence_rank	1	3	2	4	5	6
broad_impact_rank	1	3	2	6	4	5
patents_rank	2	4	1	6	5	3
tuition_rank	2	3	4	5	1	6
\end{lstlisting}

<<>>=
ranks_matrix <- rbind(world_rank_rank, quality_of_education_rank, influence_rank, broad_impact_rank, patents_rank, tuition_rank)
ranks_matrix
@

Note that because we used rbind(), we combined the vectors by rows. The new matrix contains the vectors for each category stacked one on top of the other. Each university's rankings are in a different column.

Now, we can calculate a score for each university. Smaller scores indicate higher rankings. Let's assume that we value every category in our university selection equally. In future courses, we'll learn what to do if, say, low tuition matters more to you than a university's rank for generating patents.

To calculate an aggregate score for each university, let's calculate the sum of its rankings in every category. We'll use indexing to specify the university column we want to calculate a score for using sum().

For example, we'll calculate the sum of the rankings for Harvard:

\begin{lstlisting}
sum(ranks_matrix[,"harvard"])

8
\end{lstlisting}

<<>>=
sum(ranks_matrix[,"harvard"])
@

Because the university rankings are arranged in columns of ranks\_matrix, we place harvard after the comma in the indexing expression.

Let's calculate a score for each university by taking the sum of its rankings in each category of ranks\_matrix.

Instructions

Calculate the sums of each university's rankings in ranks\_matrix:

harvard

stanford

MIT

cambridge

oxford

columbia

<<>>=
sum(ranks_matrix[,"harvard"])
sum(ranks_matrix[,"stanford"])
sum(ranks_matrix[,"MIT"])
sum(ranks_matrix[,"cambridge"])
sum(ranks_matrix[,"oxford"])
sum(ranks_matrix[,"columbia"])
@

%==============================================================================
\begin{Next steps}
%==============================================================================

In this mission, we analyzed data to answer a question: Which university should you attend? As you practiced working with data stored in matrices and vectors, you also got experience thinking about ways to manipulate data to answer questions. We'll build on these skills as we dig deeper into analysis during the rest of the course.

Let's review what we learned from our analysis. We've calculated aggregate ranking scores for each university:

\begin{lstlisting}
sum(ranks_matrix[,"harvard"])
# 8
sum(ranks_matrix[,"stanford"])
# 20
sum(ranks_matrix[,"MIT"])
# 15
sum(ranks_matrix[,"cambridge"])
# 27
sum(ranks_matrix[,"oxford"])
# 24
sum(ranks_matrix[,"columbia"])
# 32
\end{lstlisting}

Based on our analysis, Harvard earns the top score. Let's say you decide to enroll there. In the next mission, we'll work with lists, another of R's data structures, to help us organize your research on clubs to join at your new university.



%===================================================================
\section{Intermediate R Programming}

\subsection{Working with control structures}
%==============================================================================

In the Introduction to Programming in R course, we learned how to work with different data types in the R programming language. In this course, we'll move beyond the basics of R programming and learn how to use built-in functions, write our own functions, and wrangle challenging data types like character strings along with many other skills essential to data scientists. In later courses, we'll build on this programming knowledge to learn data visualization, statistics, machine learning, and more.

In the first course, you wrote code that ran sequentially, one line after the other. This is the "default" mode in which code is executed in R and other programming languages.

As a data scientist, however, you won't always want your code to be run sequentially. You'll want to perform a calculation only if a condition is met, or you'll want to repeatedly apply a function to elements of an object.

In this mission, you'll use control structures, methods for directing the order in which operations are performed, to manipulate and analyze FiveThirtyEight's data on the 2014 FIFA World Cup.

Here are the first few rows of the data:

\begin{lstlisting}
match_id	match_date	match_time	home_country	home_code	home_goals	away_country	away_code	away_goals	win_country	win_code
1	12 June	21:00:00	Brazil	BRA	3	Croatia	CRO	1	Brazil	BRA
2	13 June	17:00:00	Mexico	MEX	1	Cameroon	CMR	0	Mexico	MEX
3	13 June	20:00:00	Spain	ESP	1	Netherlands	NED	5	Netherlands	NED
4	13 June	23:00:00	Chile	CHI	3	Australia	AUS	1	Chile	CHI
5	14 June	17:00:00	Colombia	COL	3	Greece	GRE	0	Colombia	COL
\end{lstlisting}

The data set provides information about when the matches were scheduled, the countries that played in each match, the goals scored, and the teams that won.

Have you ever heard of "home-field advantage", a common excuse when a friend's favorite sports team loses when playing an away match? In this mission, we'll explore the 2014 World Cup data to see if home teams had an advantage over away teams.

First, let's start by importing the data into R using the read\_csv() function from the readr package. You can store the imported data as a data frame, a data structure consisting of vectors of equal lengths, by assigning it to a variable name like below:

\begin{lstlisting}[language=R]
new_data_frame <- read_csv("filename.csv")
\end{lstlisting}

In the code above, we imported a file named "filename.csv" and saved it as a data frame named new\_data\_frame.

When you use the read\_csv() function, R will return a message letting you know the data types it assigned to each column. This is not an error message, so don't be concerned when you see it!

Next, let's import the 2014 World Cup data set into R as a data frame. On the right is the 'script.py' code editor, where you'll complete your coding exercises in this course. If you get stuck, you can view a hint by using the 'Get Help' menu below.

Instructions

We have already loaded the readr package for you.
Use read\_csv() to import the "scores.csv" file and save it as a data frame named scores.

Remember, when you import data using read\_csv(), R returns a message telling you the column names and inferred data types of the new data frame.

<<>>=
library(readr)
scores<-read.csv(file="scores.csv",head=TRUE,sep=',')
str(scores)
scores
@

%======================================================================
\subsection{Introduction to the Data}
%==============================================================================

In the last screen, we imported data on the 2014 FIFA World Cup into a data frame, the most common data structure you'll use for analyzing data in R. You can picture a data frame as storing data in a table format like below:

\begin{lstlisting}
match_id	match_date	match_time	home_country	home_code	home_goals	away_country	away_code	away_goals	win_country	win_code
1	12 June	21:00:00	Brazil	BRA	3	Croatia	CRO	1	Brazil	BRA
2	13 June	17:00:00	Mexico	MEX	1	Cameroon	CMR	0	Mexico	MEX
3	13 June	20:00:00	Spain	ESP	1	Netherlands	NED	5	Netherlands	NED
4	13 June	23:00:00	Chile	CHI	3	Australia	AUS	1	Chile	CHI
5	14 June	17:00:00	Colombia	COL	3	Greece	GRE	0	Colombia	COL
\end{lstlisting}

Our goal is to add a new variable to the data frame that provides information about whether the home team won each match. To first get some practice, let's work with just the first two rows of the scores dataframe and follow the steps below:

Analyze the data to determine whether the home team won each match.

Create a vector containing either "home team won" or "home team did not win" for each row based on the analysis.

Add this vector to the data frame as a new column.

First, let's assign the first two rows of scores to a dataframe named scores\_two:

\begin{lstlisting}
scores_two <- scores[1:2,]

match_id	match_date	match_time	home_country	home_code	home_goals	away_country	away_code	away_goals	win_country	win_code
1	12 June	21:00:00	Brazil	BRA	3	Croatia	CRO	1	Brazil	BRA
2	13 June	17:00:00	Mexico	MEX	1	Cameroon	CMR	0	Mexico	MEX
\end{lstlisting}

<<>>=
scores_two <- scores[1:2,]
scores_two
@

In the first row, the value in the home\_goals column equals 3 and the value in away\_goals column equals 1, so we can determine that the home team won. Likewise, in the second row, the home\_goals value equals 1 and the away\_goals value equals 0, so the home team also won this match. Let's create a new vector containing two "home team won" values indicating that the home team won both matches in the scores\_two dataframe:

\begin{lstlisting}
home_team_won <- c("home team won", "home team won")
\end{lstlisting}

<<>>=
home_team_won <- c("home team won", "home team won")
home_team_won
@

Finally, let's add the home\_team\_won vector to the scores\_two dataframe as a new column. Recall that we can use the mutate() function from the dplyr package to add the new column as follows:

\begin{lstlisting}
library(dplyr)
require(dplyr)
scores_two <- scores_two %>%
    mutate(home_team_won = home_team_won)
\end{lstlisting}

<<>>=
library(dplyr)
scores_two <- scores_two %>%
    mutate(home_team_won = home_team_won)
@

Below is the result. If you scroll to the right, you'll see the new home\_team\_won column we just created:

\begin{lstlisting}
match_id	match_date	match_time	home_country	home_code	home_goals	away_country	away_code	away_goals	win_country	win_code	home_team_won
1	12 June	21:00:00	Brazil	BRA	3	Croatia	CRO	1	Brazil	BRA	home team won
2	13 June	17:00:00	Mexico	MEX	1	Cameroon	CMR	0	Mexico	MEX	home team won
\end{lstlisting}

Next, you'll perform the same exercise with the first five rows of the scores dataframe below:

\begin{lstlisting}
scores_five <- scores[1:5,]

match_id	match_date	match_time	home_country	home_code	home_goals	away_country	away_code	away_goals	win_country	win_code
1	12 June	21:00:00	Brazil	BRA	3	Croatia	CRO	1	Brazil	BRA
2	13 June	17:00:00	Mexico	MEX	1	Cameroon	CMR	0	Mexico	MEX
3	13 June	20:00:00	Spain	ESP	1	Netherlands	NED	5	Netherlands	NED
4	13 June	23:00:00	Chile	CHI	3	Australia	AUS	1	Chile	CHI
5	14 June	17:00:00	Colombia	COL	3	Greece	GRE	0	Colombia	COL
\end{lstlisting}

<<>>=
scores_five <- scores[1:5,]
scores_five
@

Instructions

We have already saved the first five rows of scores to a new data frame called scores\_five and loaded the dplyr package.

Create a new vector called home\_team\_won that contains either "home team won" or "home team did not win" for each match in scores\_five (in order).
Use the mutate() function to add the home\_team\_won vector to the scores\_five data frame. Name the column home\_team\_won.

<<>>=
library(magrittr)
library(dplyr)
scores_five <- scores[1:5,]
home_team_won <- c("home team won", "home team won", "home team did not win", "home team won", "home team won")
scores_five <- scores_five %>%
    mutate(home_team_won = home_team_won)
    
scores_five
@

%=====================================================================
\subsection{Selection: Writing Conditional Statements}
%==============================================================================

In the last exercise, you visually compared the home team and away team goals, created a new vector containing information on whether the home team won each match, and added the vector to the data frame. However, not only is this approach time-consuming, but it's also prone to mistakes.

Instead, you can automate the comparison of home team and away team goals by including a type of selection control structure called a conditional statement in your code. That way, your code will return "home team won" only if the home team has won the match.

In this case, the condition will be the home team scoring more goals than the away team. A condition is a statement that resolves to a logical value, either TRUE or FALSE. You can express conditions using conditional operators, which you learned about in the previous course. To express the condition in this case, you would write home\_goals $>$ away\_goals.

The action will be printing "home team won". In this mission, you'll use the print() function to display output generated by your code. This will allow you to make sure your code is performing the operations you want it to. If you type the following code:

\begin{lstlisting}

print("this is some text")

\end{lstlisting}

The following will appear:

\begin{lstlisting}

"this is some text"

\end{lstlisting}

To return "home team won" if home\_goals $>$ away\_goals, you can use a type of conditional statement called an if statement. An if statement is used to write code to perform an operation only if the specified condition is TRUE.

Let's write an if statement to return "home team won" if home\_goals $>$ away\_goals during the first match.

Remember, you can index a data frame to specify the column (\$) and the element of the column $([])$.

\begin{lstlisting}
scores_two <- scores_two %>%
    mutate(home_team_won = home_team_won)
if (scores$home_goals[1] > scores$away_goals[1]) {  
  print("home team won")
}

"home team won"
\end{lstlisting}

<<>>=
scores_two <- scores_two %>%
    mutate(home_team_won = home_team_won)
if (scores$home_goals[1] > scores$away_goals[1]) {  
  print("home team won")
}

"home team won"
@

Since the number of goals scored in the first match by Brazil, the home team, is larger than the number scored by Croatia, the away team, the code returns "home team won".

What about when the home team loses, though? In the example above, if the away team scored more goals than the home team, nothing would be returned.

You can incorporate into your code an alternative operation to be performed if the condition, match\_1$]\$$home\_goals > match\_1\$away\_goals, is not met.

To return "home team did not win" if the home team did not score more goals than the away team, you can add a type of conditional statement called an else statement to your code. Conditional statements that include both if and else statements are referred to as if-else statements.

\begin{lstlisting}
if (scores$home_goals[1] > scores$away_goals[1]) {
  print("home team won")
} else {
  print("home team did not win")
}

"home team won"
\end{lstlisting}

<<>>=
if (scores$home_goals[1] > scores$away_goals[1]) {
  print("home team won")
} else {
  print("home team did not win")
}
@

Notice the way we indented the two print statements above, but not the other lines of code. With control structures, it is considered good style and helps keep code readable to write blocks of code that will be executed together with the same indentation level. R executes all lines of code between curly braces together, but visually matching up each opening brace with its closing brace can be tricky. Indents, on the other hand, do not affect how the code is executed but are easy to keep track of visually. For that reason, indenting all code that appears between braces as a block helps keep everything understandable.

Let's write an if-else statement to return a result telling us whether the home team won or lost the third match.

Instructions

Write an if-else statement to return:

"home team won" if the number of goals scored by the home team is greater than the number of goals scored by the away team in the third match

"home team did not win" if the condition specified above is not met

<<>>=
#primeiro inspeciono novamente o dataset
str(scores)

#Como ele soh quer a terceira linha entao uso [3]
if (scores$home_goals[3]>scores$away_goals[3]){
    print("home team won")
    }else{
    print("home team did not win")
} 
@

%==========================================================================
\subsection{Repetition: Writing for loops}
%==========================================================================

You've now successfully used selection control structures in your code.

Let's return to your initial goal of adding a new variable to the World Cup data set that provides information about whether the home team won or lost each match. To return "home team won" or "home team did not win" for each match, we could write an if-else expression for each match:

\begin{lstlisting}[language=R]
if (scores$home_goals[1] > scores$away_goals[1]) {
  print("home team won")
} else {
  print("home team did not win")
}

if (scores$home_goals[2] > scores$away_goals[2]) {
  print("home team won")
} else {
  print("home team did not win")
}
\end{lstlisting}

However, this would be horribly inefficient. Generally, in programming, it's best to minimize repetition in your code as much as possible. If you find yourself copying and pasting blocks of code several times, it's time to seek a better solution.

To address the problem of inefficiently copying and pasting blocks of code, let's learn about a type of control structure for repetition: For-loops.

For-loops perform an operation a given number of times, enabling you to execute a piece of code repeatedly on elements in a sequence.

First, let's look at a few examples to understand how for-loops work and practice writing them. Then, you'll learn to use a for-loop to create a new variable containing information about the home team's performance in each match.

As a first example, let's write a for-loop to print every number in a sequence of numbers from one to 10.

\begin{lstlisting}[language=R]
home_team_won <- c("home team won", "home team won")
for (i in 1:10) {
  print(i)
}
\end{lstlisting}

The index variable i represents an element of a sequence. You can read the code above as, "For every element in the sequence of the numbers one to 10, print the element".

You can use any variable name you want instead of i for the index, and should consider using a name that describes what the variable actually represents to make complex code more readable.

The output is:

\begin{lstlisting}
[1] 1
[1] 2
[1] 3
[1] 4
[1] 5
[1] 6
[1] 7
[1] 8
[1] 9
[1] 10
\end{lstlisting}

Next, let's write a for-loop to print the date of each match in in the World Cup scores data frame:

\begin{lstlisting}[language=R]
for (d in scores$match_date) {
  print(d)
}
\end{lstlisting}

You can read this statement as, "for each element in the match\_date column of the scores data frame, print the element".

Notice we used the variable name d instead of i to remind ourselves it's a date. We could have used the word date as the variable, but be careful about using common words as variable names; if R already has a variable or function with that name, it can lead to problems later on. For example, assigning the maximum of a vector to the variable max is a bad idea, since if you use try to the function max() later on, your code won't behave properly.

The first few rows of the output are:

\begin{lstlisting}
[1] "12 June"
[1] "13 June"
[1] "13 June"
[1] "13 June"
[1] "14 June"
[1] "14 June"
\end{lstlisting}

Let's practice writing a for-loop to print elements of the scores data frame.

Instructions

Write a for-loop to print each element in the column home\_country of the scores data frame.

<<>>=
for(h in scores$home_country) {
print(h)}
@

%=========================================================================
\subsection{Looping Over Rows of a Data Frame}
%==========================================================================

When you write a for-loop, the elements you specify can be values, vectors, lists, or other data structures. Since you are working with a data frame (scores), let's write a for-loop to execute an operation on elements that are rows of the data frame.

The for-loop will calculate the total number of goals (away\_goals $+$ home\_goals) for each match.

In the scores data frame, each match has its own row. Since you want to perform the addition operation for each row of the data frame, the first part of the for-loop will consist of defining i as an element of the sequence of numbers from one to the number of rows in the data frame. Here's how you'll specify the sequence:

\begin{lstlisting}[language=R]
for (i in 1:nrow(scores))
\end{lstlisting}

<<>>=
for (i in 1:nrow(scores))
@

In the code above, nrow(scores) returns the number of rows in the scores data frame. Since scores has 59 rows, you can read it as, "for each element in the sequence one to 59".

You could acheive the same result by writing for (i in 1:59). However, in programming, it's good practice to refer to data objects instead of including numbers in your code. This ensures that your code makes sense to you and others when you look at it later on, and that the code will be useful in the future if changes to data structures are made.

To write the rest of the for-loop, you'll index home\_goals and away\_goals by i to add the two values together for each row:

\begin{lstlisting}[language=R]
home_team_won <- c("home team won", "home team won")
for (i in 1:nrow(scores)) { 
  print(scores$home_goals[i] + scores$away_goals[i]) }
\end{lstlisting}

<<>>=
home_team_won <- c("home team won", "home team won")
for (i in 1:nrow(scores)) { 
  print(scores$home_goals[i] + scores$away_goals[i]) }
@

Using the print() function to display the results is a useful tool as you learn to write for-loops so you can make sure the loop is performing the way you want it to.

The first few lines of output are:

\begin{lstlisting}[language=R]
[1] 4
[1] 1
[1] 6
[1] 4
[1] 3
\end{lstlisting}

Let's write a for-loop to see how much the home team won or lost by for each match.

Instructions

Write a for-loop to subtract away\_goals from home\_goals for each match in scores. In your for-loop, include code to print the results of your calculations.

<<>>=
for (i in 1:nrow(scores)) { 
  print(scores$away_goals[i] - scores$home_goals[i]) 
}
@
%=======================================================================

\subsection{Nested Control Structures}

Control structures are powerful tools, and can do even more when combined together. For example, the actions repeated by a for-loop don't need to be sequential code — they could be conditional statements. This pattern of executing one or more control structures inside another one is called nesting.

Originally, you wanted to create a new variable that provides information about whether the home team won or lost each match.

You've already written an expression, using an if-else statement, that produces different output depending on whether the home team won or lost a specific match:

\begin{lstlisting}[language=R]
if (scores$home_goals[1] > scores$away_goals[1]) {
  print("home team won")
} else {
  print("home team did not win")
}
\end{lstlisting}

<<>>=
if (scores$home_goals[1] > scores$away_goals[1]) {
  print("home team won")
} else {
  print("home team did not win")
}
@

Now, you'll perform that operation for each match in the scores data frame, which you already know how to do: Use a for-loop! To do this, you'll use an index variable that ranges from one to the number of rows in the data frame, as you did earlier in this mission. Then, you'll apply the if-else statement to each element of that sequence.

The syntax is similar to what you've seen so far: You'll place the if-else statement between the braces ({}) in the for-loop:

\begin{lstlisting}[language=R]
for (i in 1:nrow(scores)) { 
  print(scores$home_goals[i] + scores$away_goals[i]) 
}
for (i in 1:nrow(scores)) {  
  if (scores$home_goals[i] > scores$away_goals[i]) {
    print("home team won")
  } else {
    print("home team did not win") 
  }
}
\end{lstlisting}

<<>>=
for (i in 1:nrow(scores)) { 
  print(scores$home_goals[i] + scores$away_goals[i]) 
}
for (i in 1:nrow(scores)) {  
  if (scores$home_goals[i] > scores$away_goals[i]) {
    print("home team won")
  } else {
    print("home team did not win") 
  }
}
@

The first few lines of the output are:

\begin{lstlisting}
[1] "home team won"
[1] "home team won"
[1] "home team did not win"
[1] "home team won"
[1] "home team won"
\end{lstlisting}

Again, notice how the indentation helps visually organize the code. The outer set of braces correspond with the for-loop, and everything in that loop between the braces is indented once. Inside that, there are braces for the if statement (with the code inside them indented a second time), and braces for the else statement (with the code inside them indented a second time).

Nested control structures are very powerful, but can be tricky to get used to and can make finding errors in your code harder. The workflow in the previous examples is a good way to avoid problems when writing nested control structures: Start by writing the inner operation and make sure it works correctly, and then wrap the outer operation around it.

Next, you'll learn to store the output of a loop in a variable. Let's write a for-loop that outputs logical data, TRUE and FALSE, that would make a useful variable.

Instructions

Write a for-loop that, for each row in the scores data frame, prints TRUE if home\_goals is greater than away\_goals and FALSE if not.

<<>>=
for (i in 1:nrow(scores)){
    if (scores$home_goals[i]>scores$away_goals[i]){
    print("TRUE")
    } else {
    print("FALSE")
 }
} 
@

%=======================================================================

\subsection{Storing For-Loop Output in Objects}

In the previous for-loop examples in this mission, you've printed the output of the for-loop. Printing for-loop output to make sure your loop is doing what you want it to can be useful. Ultimately, though, you'll want to use the output of a for-loop instead of just printing it.

Let's write a for-loop and store its output in a vector. To illustrate how this works, let's return to an example from earlier in this mission where you calculated the total goals scores in each match:

\begin{lstlisting}[language=R]
for (i in 1:nrow(scores)) { 
  print(scores$home_goals[i] + scores$away_goals[i]) 
}
\end{lstlisting}

<<>>=
for (i in 1:nrow(scores)) { 
  print(scores$home_goals[i] + scores$away_goals[i]) 
}
@

To modify the for-loop to store the total goals scored in each match in a vector instead of printing it, you'll need to first create an empty vector to add values to:

\begin{lstlisting}[language=R]
for (i in 1:nrow(scores)) { 
  print(scores$home_goals[i] + scores$away_goals[i]) 
}
total_goals <- c()
\end{lstlisting}

<<>>=
for (i in 1:nrow(scores)) { 
  print(scores$home_goals[i] + scores$away_goals[i]) 
}
total_goals <- c()
@

Then, you'll write the for-loop to include the following code (recall this syntax from the previous course) to add new elements to the vector:

\begin{lstlisting}[language=R]
total_goals <- c(total_goals, "new element")
\end{lstlisting}

<<>>=
total_goals <- c(total_goals, "new element")
@

The new elements you'll add to the vector are the sums of home\_goals and total\_goals for each match.

\begin{lstlisting}[language=R]
for (i in 1:nrow(scores)) {
  total_goals <- c(total_goals, scores$home_goals[i] + scores$away_goals[i])
}
\end{lstlisting}

<<>>=
for (i in 1:nrow(scores)) {
  total_goals <- c(total_goals, scores$home_goals[i] + scores$away_goals[i])
}
@

After running the for-loop, the total\_goals vector contains a sum of home\_goals and away\_goals for each match:

\begin{lstlisting}[language=R]
[1] 4 1 6 4 3 4 3 3 3 3 4 3 3 2 0 4 2 5 3 0 3 1 7 1 1 4 4 1 5 4 3 2 5 3 1 0 3 0 5 4 3 1 2 2 2 3 2 2 3 1 3 3 1 0 1 8 0 3 1
\end{lstlisting}

When you write a for-loop to repeat an if-else statement, you'll need to specify the addition of two types of output to the vector.

Let's look at the for-loop you wrote to print either TRUE or FALSE depending on whether the home team won each match:

\begin{lstlisting}[language=R]
for (i in 1:nrow(scores)) {  
  if (scores$home_goals[i] > scores$away_goals[i]) {
    print(TRUE)
  } else {
    print(FALSE) 
  }
}
\end{lstlisting}

<<>>=
for (i in 1:nrow(scores)) {  
  if (scores$home_goals[i] > scores$away_goals[i]) {
    print(TRUE)
  } else {
    print(FALSE) 
  }
}
@

Let's create a new, empty vector, home\_team\_won, to store the logical output of the for-loop:

\begin{lstlisting}[language=R]
home_team_won <- c()
\end{lstlisting}

<<>>=
home_team_won <- c()
@

In place of the print() functions in the for-loop, you can include code to store output in home\_team\_won:

\begin{lstlisting}[language=R]
home_team_won <- c(home_team_won, TRUE)

home_team_won <- c(home_team_won, FALSE)
\end{lstlisting}

<<>>=
home_team_won <- c(home_team_won, TRUE)

home_team_won <- c(home_team_won, FALSE)
@


Let's use what you've learned so far to create a new vector containing logical data: TRUE if the home team won and FALSE if it lost.

Instructions

Write a for-loop that, for each row in the scores data frame, outputs TRUE if home\_goals is greater than away\_goals and FALSE if not. Store the output in a vector called home\_team\_won.

<<>>=
home_team_won<-c()
for (i in 1:nrow(scores)) {  
  if (scores$home_goals[i] > scores$away_goals[i]) {
    home_team_won <- c(home_team_won, TRUE)
  } else {
    home_team_won <- c(home_team_won, FALSE)
  }
}
home_team_won
@

%=======================================================================
\subsection{More than two cases}
%=======================================================================

You've now created a new variable, home\_team\_won, that provides information about whether the home team won each match in the data set. You can use this new information to begin exploring whether teams playing in the 2014 World Cup experienced a home advantage.

Let's add the home\_team\_won vector as a new column to the scores data frame. Remember that you learned how to do this using the mutate() function in the dplyr package in the previous course. Here, we will overwrite the scores data frame with a new one containing the home\_team\_won variable:

\begin{lstlisting}[language=R]
library(dplyr)

scores <- scores %>%
  mutate(home_team_won = home_team_won)
\end{lstlisting}

<<>>=
library(dplyr)

scores <- scores %>%
  mutate(home_team_won = home_team_won)
  
scores  
@

The resulting data frame contains a new column, home\_team\_won:

\begin{lstlisting}[language=R]
match_id	match_date	match_time	home_country	home_code	home_goals	away_country	away_code	away_goals	win_country	win_code	home_team_won
1	12 June	21:00:00	Brazil	BRA	3	Croatia	CRO	1	Brazil	BRA	TRUE
2	13 June	17:00:00	Mexico	MEX	1	Cameroon	CMR	0	Mexico	MEX	TRUE
3	13 June	20:00:00	Spain	ESP	1	Netherlands	NED	5	Netherlands	NED	FALSE
4	13 June	23:00:00	Chile	CHI	3	Australia	AUS	1	Chile	CHI	TRUE
5	14 June	17:00:00	Colombia	COL	3	Greece	GRE	0	Colombia	COL	TRUE
\end{lstlisting}

As you scroll through the table, though, you notice something. As written, your code only accounts for two outcomes:

The home team scored more goals than the away team (TRUE)

The home team did not score more goals than the away team (FALSE)

Therefore, some of the FALSE values in the new variable actually represent ties.

It would be more informative to have a variable containing three outcomes for the home team:

Won

Lost

Tied

Instead of writing code to specify two possible outcomes, in this case, you'll need to specify three:


You can use selection control structures to specify more than two outcomes by adding else if statements to your code.

Consider the following example, which prints one of three possible match outcomes for the first match in the scores data frame:

\begin{lstlisting}[language=R]
if (scores$home_goals[1] > scores$away_goals[1]) {
    print("win")
} else if (scores$home_goals[1] < scores$away_goals[1]) {
    print("lose")
} else if (scores$home_goals[1] == scores$away_goals[1]) {
    print("tie")
}
\end{lstlisting}

<<>>=
if (scores$home_goals[1] > scores$away_goals[1]) {
    print("win")
} else if (scores$home_goals[1] < scores$away_goals[1]) {
    print("lose")
} else if (scores$home_goals[1] == scores$away_goals[1]) {
    print("tie")
}
@

You can chain together as many else if statements in your code as needed.

In the scores data set, there are only three possible match outcomes. However, if you needed to specify a default action to perform if none of the prior conditions are met, you can include an else statement in your code:

\begin{lstlisting}[language=R]
if (scores$home_goals[1] > scores$away_goals[1]) {
    print("win")
} else if (scores$home_goals[1] < scores$away_goals[1]) {
    print("lose")
} else if (scores$home_goals[1] == scores$away_goals[1]) {
    print("tie")
} else {
    print ("no action")
}
\end{lstlisting}

<<>>=
if (scores$home_goals[1] > scores$away_goals[1]) {
    print("win")
} else if (scores$home_goals[1] < scores$away_goals[1]) {
    print("lose")
} else if (scores$home_goals[1] == scores$away_goals[1]) {
    print("tie")
} else {
    print ("no action")
}
@

Let's practice using else if statements to perform actions based on more than two conditions.

Instructions

For the third match in scores, use if and else if statements to write code to print "win", "lose", or "tie" based on comparisons of home\_goals and away\_goals.

<<>>=
if (scores$home_goals[3] > scores$away_goals[3]) {
    print("win")
} else if (scores$home_goals[3] < scores$away_goals[3]) {
    print("lose")
} else if (scores$home_goals[3] == scores$away_goals[3]) {
    print("tie")
} else {
    print ("no action")
}
@

%==========================================================================
\subsection{More Than Two Cases: Writing a For-Loop}
%==========================================================================

You've used selection control structures to specify three potential outcomes for the third match in the scores data frame. Now, you'll need to perform the same operation for each row in scores to create your new variable.

Recall from earlier in this mission that you can write a for-loop to apply the same operations on each row in a data frame:

\begin{lstlisting}[language=R]
for (i in 1:nrow(scores)) {  
  if (scores$home_goals[i] > scores$away_goals[i]) {
    print("win")
  } else if (scores$home_goals[i] < scores$away_goals[i]) {
    print("lose")
  } else if (scores$home_goals[i] == scores$away_goals[i]) {
    print("tie")
  }
}
\end{lstlisting}

<<>>=
for (i in 1:nrow(scores)) {  
  if (scores$home_goals[i] > scores$away_goals[i]) {
    print("win")
  } else if (scores$home_goals[i] < scores$away_goals[i]) {
    print("lose")
  } else if (scores$home_goals[i] == scores$away_goals[i]) {
    print("tie")
  }
}
@

Remember, also, you can create a new vector and add new elements generated in your for-loop to it rather than printing them.

Let's create a new vector containing information about the home team's performance in each match.

Instructions

Create a new vector, home\_team\_result, that contains "win", "lose", or "tie" for the home team for each match in scores.

Overwrite the scores data frame with a new scores data frame containing the home\_team\_result variable. You can use the mutate() function. We have loaded the dplyr() package for you.

<<>>=
home_team_result <- c()

for (i in 1:nrow(scores)) {  
  if (scores$home_goals[i] > scores$away_goals[i]) {
    home_team_result <- c(home_team_result, "win")
  } else if (scores$home_goals[i] < scores$away_goals[i]) {
    home_team_result <- c(home_team_result, "lose")
  } else if (scores$home_goals[i] == scores$away_goals[i]) {
    home_team_result <- c(home_team_result, "tie")
  }
}

scores <- scores %>%
    mutate(home_team_result = home_team_result)
    
scores
@
\newpage

%===============================================================================
\subsection{Next Steps}
%==========================================================================

In this mission, you've learned to use two types of control structures to direct the flow of your code:

If-else statements

For-loops

You've been empowered to write code that saves time and provides you with increased flexibility for solving data analysis problems.

If-else statements and for-loops are programming tools common to practically all programming languages, and it's important to understand how they work and when to use them.

However, R is characterized by some special features you'll often find superior to for-loops when it comes to repeating the same operation on multiple elements.

In the next mission, we'll introduce you to vectorized functions and show you how using them can help you streamline your R code and gain speed when working with large data sets.

\newpage
%==========================================================================
\section{Working with Vectorized functions}
\subsection{R Functions as Alternatives to Loops}
%==========================================================================

Earlier in this course, you learned how to repeat operations on multiple elements of a data frame or list using for-loops. Loops are a common feature of programming languages — the process of looping over an object, repeating operations on each element, and saving the result is a common programming task. Understanding how for-loops work is important as you build your programming foundation.

When working with R, though, you won't write for-loops as often as you would if you were using other programming languages. In R, many built-in functions contain for-loops. This makes it possible to call a function instead of directly using a for-loop. Remember from earlier courses that functions take an input, perform an operation, and return an output.

Many R functions are vectorized, meaning you can use them to operate on all elements of a vector quickly. You've seen some of them, including mean(), min(), max(), and sum(), in action already.

In this mission, we'll delve deeper into some of R's vectorized functions, why they will help you write fast and efficient code, and explain why and when you should use them. We'll also show you how to use the pipe operator (\%$>$\%) to write efficient code by chaining functions together.

We'll continue exploring FiveThirtyEight's data on the 2014 FIFA World Cup. You'll learn how to use vectorized functions to perform common data manipulation and analysis tasks, including summarizing match results and identifying the top-scoring matches.

Let's import the World Cup data into R using read\_csv() and save it as a data frame named scores. Remember that we need to first load the readr package.

Instructions

Use read\_csv to import the scores.csv file into R. Save the data as a data frame called scores.

<<>>=
scores<-read.csv(file="scores.csv",head=TRUE,sep=",")
scores[1:5,]#mostra as primeiro cinco linhas do dataset
@

%======================================================================================
\subsection{How Does Vectorization Make Code Faster?}
%======================================================================================

Let's begin by talking about how using vectorized functions in R helps you write more efficient code.

R is a high-level, interpreted programming language. This means that, in contrast to low-level, compiled languages, R performs many basic computer tasks "behind the scenes." For example, if you create the following vector:

\begin{lstlisting}[language=R]
vector <- c(1, 3, 5, 6, 7, 9, 11)
\end{lstlisting}

<<>>=
vector <- c(1, 3, 5, 6, 7, 9, 11)
@

R will:

"Guess" that the vector elements are numeric

Find space in memory for the vector

Assign vector as the name that directs R to the stored values of the vector

Most R functions are written in a compiled language (like Fortran or C) and have an R "wrapper" that users interact with.

If you apply a function to each element of the vector repeatedly, R has to interpret the input of the function and pass it to the compiled code for each element:

However, if you apply the function to the entire vector, R only needs to interpret the input and pass it to the compiled code once:

Therefore, the vectorized solution is faster, and the code is usually easier to understand.

Consider the following example. Let's calculate the sum of all the numbers from zero to 100,000,000 using non-vectorized and vectorized methods and compare the amount of time it takes the R interpreter to run the code for each.

We will measure the running time of the code using the function system.time(), which outputs the time elapsed (in seconds) while the function is executed.

We can calculate the sum of all the numbers from zero to 100,000,000 using a non-vectorized solution (a for-loop):

\begin{lstlisting}[language=R]
system.time({

sum_nums <- 0

for (i in 1:10000000){
  sum_nums <- sum_nums + i
}
})

elapsed 
0.398
\end{lstlisting}

<<>>=
system.time({

sum_nums <- 0

for (i in 1:10000000){
  sum_nums <- sum_nums + i
}
})
@

Or we could perform the calculation using the built-in R function sum().

\begin{lstlisting}[language=R]
system.time({

sum(1:10000000)

})

elapsed 
0.029
\end{lstlisting}


As you can see from the results of the runtime analysis, using the sum() function is substantially faster than using the for-loop.

While using for-loops isn’t necessarily a bad choice, using vectorized functions is often faster and can make code easier to read and understand.


%=======================================================================================
\subsection{A Vectorized Function for If-Else Statements}
%=======================================================================================

Here are the first few rows of the 2014 World Cup data:

<<>>=
scores[1:5,]
@

In the last mission, you learned to use selection control structures (if-else statements) to write code to perform an action if a certain condition was met. For example, you wrote a statement to print "home team won" if home\_goals was greater than away\_goals for a row of the scores data frame:

\begin{lstlisting}[language=R]
if (scores$home_goals[1] > scores$away_goals[1]) {
  print("home team won")
} else {
  print("home team did not win")
}
\end{lstlisting}

<<>>=
if (scores$home_goals[1] > scores$away_goals[1]) {
  print("home team won")
} else {
  print("home team did not win")
}
@


The code above performs an operation on individual column elements of the scores data frame instead of on entire columns. For that reason, when you wanted to perform the specified operation on all the elements of the home\_goals and away\_goals columns of the data frame, you used a for-loop:

\begin{lstlisting}[language=R]
for (i in 1:nrow(scores)) {  
  if (scores$home_goals[i] > scores$away_goals[i]) {
    print("home team won")
  } else {
    print("home team did not win") 
  }
}
\end{lstlisting}

<<>>=
for (i in 1:nrow(scores)) {  
  if (scores$home_goals[i] > scores$away_goals[i]) {
    print("home team won")
  } else {
    print("home team did not win") 
  }
}
@

While the code above performed the operation you intended, using a vectorized function achieves the same result and is usually more efficient.

Let's look at a vectorized function for applying if-else statements. The if\_else() function is part of the dplyr package and requires the following input:

A vector or multiple vectors

A condition

An action to perform if the condition is true

An action to perform if the condition is false

You could replace the for-loop above with the if\_else() function.

You would write:

\begin{lstlisting}[language=R]
if_else(scores$home_goals > scores$away_goals, "home team won", "home team did not win")
\end{lstlisting}

The code inputs are labeled below:

You could read the expression above as, "If home\_goals is greater than away\_goals, return 'home team won'. If not, return 'home team did not win.''"

Let's practice using if\_else() to write vectorized if-else statements.

Instructions

Using if\_else(), write an expression to return "tie" if scores\$home\_goals is equal to scores\$away\_goals and "did not tie" if home and away goals are not equal.

Save the resulting vector as tied\_matches.

<<>>=
tied_matches<-if_else(scores$home_goals==scores$away_goals,"tie","did not tie")
@

%=====================================================================================
\subsection{Multiple Cases: Nesting Functions to Chain If-Else Statements}
%====================================================================================

In the previous mission, you learned to chain multiple conditional statements to specify actions to be taken depending on more than two possible outcomes.

Let's say you wanted to print a classification for each number between one and 1,000:

Less than 100: "small"

Between 100 and 500: "medium"

Greater than 500: "large"

In this case, there are three cases:

You could write a for-loop to apply the conditional statements to each value in the numeric vector 1:1000:

\begin{lstlisting}[language=R]
for (i in 1:1000) {  
  if (i <= 100) {
    print("small")
  } else if (i > 100 & i <= 500) {
    print("medium")
  } else if (i > 500) {
    print("large")
  }
}
\end{lstlisting}

Alternatively, you can take a vectorized approach by nesting if\_else() functions.

You would write the following code:

\begin{lstlisting}[language=R]
if_else(1:1000 < 100, "small", 
  if_else(1:1000 > 100 & 1:1000 <= 500, "medium",
    if_else(1:1000 > 500, "large", "")))
\end{lstlisting}

Remember the if\_else() function requires you to provide it with a vector, a condition, an action to perform if the condition is true, and an action to perform if the condition is false.

When nesting if\_else() functions, you specify a different if\_else() function to perform as the action to take if the first condition is not met:

For each if\_else() function in the chain, if the condition is not met, the interpreter moves on to the next if\_else() function:

Each if\_else() function requires you to specify two actions to take (based on whether the condition is true or false). Note that since we were only using three classifications, we used an empty pair of quotes ("") as the second action in the last if\_else() function.

Outside a loop, output will print automatically, so we did not need to explicitly use print() in the code above.

In the previous mission, you wrote the following code to create a vector, home\_team\_result, conaining the results of each match:

\begin{lstlisting}[language=R]
home_team_result <- c()

for (i in 1:nrow(scores)) {  
  if (scores$home_goals[i] > scores$away_goals[i]) {
    home_team_result <- c(home_team_result, "win")
  } else if (scores$home_goals[i] < scores$away_goals[i]) {
    home_team_result <- c(home_team_result, "lose")
  } else if (scores$home_goals[i] == scores$away_goals[i]) {
    home_team_result <- c(home_team_result, "tie")
  }
}
\end{lstlisting}

<<>>=
home_team_result <- c()

for (i in 1:nrow(scores)) {  
  if (scores$home_goals[i] > scores$away_goals[i]) {
    home_team_result <- c(home_team_result, "win")
  } else if (scores$home_goals[i] < scores$away_goals[i]) {
    home_team_result <- c(home_team_result, "lose")
  } else if (scores$home_goals[i] == scores$away_goals[i]) {
    home_team_result <- c(home_team_result, "tie")
  }
}
@

Now, let's instead use nested if\_else() functions to create the home\_team_result vector.

Instructions

Using nested if\_else() statements, create a vector named home\_team\_result containing the following:

"win" if home\_goals $>$ away\_goals

"lose" if home\_goals $<$ away\_goals

"tie" if home\_goals $==$ away\_goals

Use the mutate() function to add home\_team\_result as a new column (also called home\_team\_result) to the scores data frame.

Save the scores data frame with the new variable as scores\_2.

<<>>=
home_team_result<-if_else(scores$home_goals > scores$away_goals,"win",
                  if_else(scores$home_goals < scores$away_goals,"lose",
                  if_else(scores$home_goals == scores$away_goals,"tie","")))
scores_2<-scores %>%
        mutate(home_team_result=home_team_result)

home_team_result

scores_2[1:3,]
@
%==============================================================================
\subsection{Functions for Solving "Split-Apply-Combine" Problems}
%=============================================================================

In the last mission, you investigated the 2014 World Cup data to see whether home teams appeared to have an advantage. You created a new variable, home\_team\_result, that contained "win", "lose", or "tie" for each match. You then used a for-loop to add up the number of home team wins, losses, and ties to get a total for each match outcome:


\begin{lstlisting}[language=R]
win_total <- 0
lose_total <- 0
tie_total <- 0

for (i in 1:nrow(scores)) {  
  if (scores$home_team_result[i] == "win") {
    win_total <- win_total + 1 
  } else if (scores$home_team_result[i] == "lose") {
    lose_total <- lose_total + 1 
  } else if (scores$home_team_result[i] == "tie") {
    tie_total <- tie_total + 1
  }
}
\end{lstlisting}

<<>>=
win_total <- 0
lose_total <- 0
tie_total <- 0

for (i in 1:nrow(scores)) {  
  if (scores$home_team_result[i] == "win") {
    win_total <- win_total + 1 
  } else if (scores$home_team_result[i] == "lose") {
    lose_total <- lose_total + 1 
  } else if (scores$home_team_result[i] == "tie") {
    tie_total <- tie_total + 1
  }
}
@

Let's explore vectorized functions as an alternative to the for-loop you wrote for adding up the number of matches in the "win", "lose", and "tie" categories of home\_team\_result.

You could use sum(), which you have learned is a vectorized built-in R function, to calculate the number of instances of "win", "lose", and "tie" in the home\_team\_result column of scores:

\begin{lstlisting}
sum(scores$home_team_result == "win")
sum(scores$home_team_result == "lose")
sum(scores$home_team_result == "tie")
\end{lstlisting}

<<>>=
sum(scores$home_team_result == "win")
sum(scores$home_team_result == "lose")
sum(scores$home_team_result == "tie")
@


While this approach certainly is more efficient than the for-loop example above, it still leaves you writing out very similar lines of code several times. Remember: If you're copying and pasting code, it's probably time to seek a better solution.

Before we present solutions for the problem at hand, let's dive deeper into what we actually want to accomplish.

Here's a subset of the scores\_2 data frame that you just created, with the new column, home\_team\_result, that you added. Home team wins and losses are highlighted in different colors.

To calculate the total home team wins and losses, you need to split the data into two groups:

Then, you can apply the n() function, which you'll learn about on the next screen, to count the number of rows in each group:

This type of problem is known as a split-apply-combine problem in R — the data is split into groups, a function is performed on each group, and the results are summarized.

You'll find that the workflow you're about to learn will be useful for solving many data analysis problems that require the calculation of summary statistics like averages.


%===================================================================================
\subsection{Grouping and Summarizing Data Frames}
%===================================================================================

There are two functions in the dplyr package that are useful for working on split-apply-combine problems:

group\_by() lets you group a data frame based on a variable, such as home\_team\_result.
summarize() lets you apply a function, like n() or sum(), to each group.

We'll begin with the group\_by() function, which is used to group a data frame based on one or more variables. In this case, we will group the scores data frame based on the home\_team\_result variable:

For working with functions from tidyverse packages, we can use the pipe operator (\%$>$\%) you learned about in R Fundamentals. You'll learn more specifics about how to use the pipe operator to chain functions later in this mission.

\begin{lstlisting}
scores %>% 
  group_by(home_team_result)
\end{lstlisting}

<<>>=
home_team_result[1:3]

scores[1:3,]

scores<-scores%>% #adiciono a home_team_result no scores dataset
        mutate(home_team_result=home_team_result)

scores %>% 
  group_by(home_team_result)
@


The code above splits rows of scores into the following three groups:

win

lose

tie

When you print the first few rows of a grouped data frame, you'll see the grouping variable and the number of groups specified:

\begin{lstlisting}[language=R]
A tibble: 59 x 13
Groups:   home_team_result [3]
\end{lstlisting}

Once the data frame is grouped, you can perform operations on each group using the summarize() function.

To calculate the number of instances of each outcome in the home\_team\_result column, we can use n(), which counts the number of data frame rows in each group. The n() function is specific to dplyr, and can only be used within dplyr functions.

Let's assign the counts of rows in each group to the column header total:

\begin{lstlisting}[language=R]
scores %>% 
  group_by(home_team_result) %>% 
  summarize(total = n())
\end{lstlisting}

<<>>=
scores %>% 
  group_by(home_team_result) %>% 
  summarize(total = n())
@


The result is a data frame (a tibble, remember, since the original data frame was imported using readr) containing the total number of matches in each category of home\_team\_result:

\begin{lstlisting}[language=R]
A tibble: 3 x 2
  home_team_result   total
  chr                int
1 lose                20
2 tie                 12
3 win                 27
\end{lstlisting}

To quantify the number of matches that home teams won, lost, or tied, we just needed to count the number of rows in each group. You can also use summarize() to calculate summaries for specific variables, though.

For example, let's calculate the average number of goals scored by home teams during matches they won, lost, and tied. Instead of passing n() to summarize() to calculate the number of rows in each group, you can pass the mean() function to summarize() to calculate an average. However, it doesn't make sense to ask for the average of a data frame — we also need to specify a particular variable, home\_goals, within the mean() function:

\begin{lstlisting}[language=R]
scores %>% 
  group_by(home_team_result) %>% 
  summarize(avg_home_goals = mean(home_goals))    

# results

A tibble: 3 x 2
  home_team_result      avg_home_goals
  chr                    dbl
1 lose                  0.7  
2 tie                   0.667
3 win                   2
\end{lstlisting}

When you're done working with your grouped data frame, you should return it to its previous state by ungrouping it:

\begin{lstlisting}[language=R]
scores %>% 
    ungroup()
\end{lstlisting}

Now, it's your turn to practice using the group\_by() and summarize() functions to solve a split-apply-combine problem.

Instructions

There are a number of teams that played in multiple matches in the 2014 World Cup. Let's group the data frame by home\_country and calculate the total number of goals scored by each home country during the 2014 World Cup.

Use group\_by() to group scores by the home\_country variable

Use summarize() to calculate the total number of home\_goals scored by each home country using sum()

Chain the two expressions together using the pipe operator (\%$>$\%)

Save the resulting data frame as home\_goals\_sum

<<>>=
home_goals_sum<-scores %>%
    group_by(home_country) %>%
    summarize(sum(home_goals))

home_goals_sum[1:5,]
@

%===============================================================
\subsection{Summarizing a Data Frame by Multiple Variables}
%===============================================================

You've now learned to group a data frame by one variable and perform operations on each group.

However, what if you want to group your data frame by multiple variables? For example, maybe you want to calculate the total number of wins, losses, and ties for each home country (there are 30 home countries that played in the 2014 World Cup) in the scores data frame.

To perform this calculation, you would first group the data frame by home\_country and home\_team\_results:


\begin{lstlisting}[language=R]
scores %>%
    group_by(home_country, home_team_result)
\end{lstlisting}

<<>>=
scores %>%
    group_by(home_country, home_team_result)
@


This operation results in the scores data frame being separated into 30 groups — one for each home country.

You can then summarize the grouped scores data frame using n() to count the number of rows within each group.

\begin{lstlisting}[language=R]
scores %>%
    group_by(home_country, home_team_result) %>%
    summarize(total = n())
\end{lstlisting}

<<>>=
scores %>%
    group_by(home_country, home_team_result) %>%
    summarize(total = n())
@

The resulting data frame contains the number of wins, losses, and ties for each home country that played in the 2014 World Cup:

\begin{lstlisting}[language=R]
A tibble: 39 x 3
Groups:   home_country [?]
   home_country           home_team_result   total
   chr                    chr                int
 1 Algeria                tie                  1
 2 Argentina              win                  4
 3 Australia              lose                 2
 4 Belgium                win                  3
 5 Bosnia and Herzegovina win                  1
 6 Brazil                 lose                 2
 7 Brazil                 tie                  2
 8 Brazil                 win                  2
 9 Cameroon               lose                 2
10 Chile                  win                  1
 ... with 29 more rows
\end{lstlisting}



It is possible to group a data frame by as many variables as is necessary for your analysis. Variable columns are arranged in the output data frame in the order that they are listed in group\_by().

You can also specify multiple operations within the summarize() function at once. For example, if you wanted to calculate the minimum, maximum, and average number of goals scored by each home country, you could write the following:

\begin{lstlisting}[language=R]
scores %>%
    group_by(home_country) %>%
    summarize(min = min(home_goals), 
              max = max(home_goals), 
              avg = mean(home_goals))
\end{lstlisting}

<<>>=
scores %>%
    group_by(home_country) %>%
    summarize(min = min(home_goals), 
              max = max(home_goals), 
              avg = mean(home_goals))
@

The resulting data frame contains the minimum, maximum, and average number of home goals scored by each home country in the 2014 World Cup. Variable columns are added to the output data frame in the order that they are specified in summarize().

\begin{lstlisting}[language=R]
A tibble: 30 x 4
   home_country    min       max       mean
   chr             dbl       dbl       dbl
 1 Algeria          1        1         1   
 2 Argentina        1        2         1.25
 3 Australia        0        2         1   
 4 Belgium          1        2         1.67
 5 Bosnia...        3        3         3   
 6 Brazil           0        3         1.17
 7 Cameroon         0        1         0.5 
 8 Chile            3        3         3   
 9 Colombia         2        3         2.33
10 Costa Rica       0        1         0.5 
... with 20 more rows
\end{lstlisting}

Let's use group\_by() and summarize() to explore the 2014 World Cup data further by calculating summaries of the goals scored by away countries.

Instructions

Use the group\_by() and summarize() functions on the scores data frame to write an expression that returns a data frame containing the total (sum), average, minimum, and maximum away goals for each away country. Name the summary variables total, average, min, and max.

Store the resulting data frame as away\_results.

<<>>=
away_results<-scores%>%
        group_by(away_country) %>%
        summarize(total=sum(away_goals),
                  average=mean(away_goals),
                  min=min(away_goals),
                  max=max(away_goals))

away_results
@

%=====================================================================================
\subsection{Chaining Functions Together Using the Pipe Operator}
%====================================================================================

You were introduced to the pipe operator (\%$>$\%) in the first R course when you learned to use dplyr functions to perform basic operations on data frames. Now you've seen it again, as we use group\_by() and summarize() to perform data frame manipulations.

Here, we'll discuss the pipe operator in greater depth, and show you how to use it to maximize the efficiency and clarity of your code when working with R functions.

We've discussed the fact that often, your R code will consist of a series of operations performed using functions rather than control structures like for-loops. The point of the pipe is to help R users write code that chains functions together in a way that is easy to read and write.

The pipe originated with a package called maggritR. The tidyverse has adopted the pipe as a key feature of its packages, so loading tidyverse packages loads \%$>$\% automatically.

To understand how the pipe can help you make the best use of R when performing a series of operations, let's look at an example.

Let's say you wanted to analyze the scores data frame to figure out which home countries played in matches with the greatest number of total goals (away + home) scored. You are now familiar with dplyr functions for performing these data frame manipulations. Let's first perform them without using \%$>$\%.

First, you'd use mutate() to add a total\_goals column to scores and save the result as a new data frame, scores\_total:

\begin{lstlisting}[language=R]
scores_total <- mutate(scores, total_goals = home_goals + away_goals)
\end{lstlisting}

<<>>=
scores_total <- mutate(scores, total_goals = home_goals + away_goals)
@

Then, you'd group scores\_total by home\_country and save the result as a new data frame, scores\_group:

\begin{lstlisting}[language=R]
scores_group <- group_by(scores_total, home_country)
\end{lstlisting}

<<>>=
scores_group <- group_by(scores_total, home_country)
@


As you learned in this mission, once you've grouped the data, now you can use summarize() to calculate the sum (total) of the total goals scored in matches each home country played in. You'd save the output as a new variable, scores\_summary.

\begin{lstlisting}[language=R]
scores_summary <- summarize(scores_group, total = sum(total_goals))
\end{lstlisting}

Finally, to see which countries played in matches with the greatest number of goals scored, you could use the arrange() function to order scores\_summary in descending order by total (calculated in the last step):

\begin{lstlisting}[language=R]
arrange(scores_summary, desc(total))
\end{lstlisting}

<<>>=
arrange(scores_summary, desc(total))
@

Writing the code this way accomplishes your goal of seeing which home countries played in matches with the greatest number of total goals:

\begin{lstlisting}[language=R]
A tibble: 30 x 2
   home_country total
   chr             int
 1 Brazil          20
 2 Germany         12
 3 Switzerland     10
 4 Cameroon         9
 5 Australia        8
 6 Colombia         8
 7 Spain            8
 8 Belgium          7
 9 Uruguay          7
10 Argentina        6
# ... with 20 more rows
\end{lstlisting}

However, you had to keep track of several intermediate objects scored as new variables (scores\_total, scores\_group, scores\_summary) and they ended up cluttering the global environment. Here's a screenshot of the global environment window in RStudio after working through the exercise above:

While you had the option of overwriting scores with each new step, you may want to keep the original scores data frame in your environment. Overwriting scores each time would also make your code less clear, since it would be difficult to see what you're changing with each new line of code.

Using the pipe, however, allows you to write code that focuses on what you're doing in each step because you don't need to worry about creating intermediate objects or overwriting your original object:

\begin{lstlisting}[language=R]
scores %>%
  mutate(total_goals = sum(home_goals, away_goals)) %>%
  group_by(home_country) %>%
  summarise(total = sum(total_goals)) %>%
  arrange(desc(total))
\end{lstlisting}

<<>>=
scores %>%
  mutate(total_goals = sum(home_goals, away_goals)) %>%
  group_by(home_country) %>%
  summarise(total = sum(total_goals)) %>%
  arrange(desc(total))
@


So how does it work? Basically, \%$>$\% allows you to write code so that the output of a function is passed to the next function from left to right. We discussed earlier in this mission that most R functions do a lot of computing work for you behind the scenes, and you as a user interact with a "wrapper". The pipe is a good example of this. The magrittR package reorganizes code you write to overwrite an intermediate object.

Why not use the pipe operator for all your code? As you learn to use other packages in the tidyverse for data analysis work, you often will be able to write efficient code using \%$>$\%. However, there are some situations where you shouldn't rely on the pipe:

If you are writing very long chains of functions (more than ten or so steps), it makes sense to have an intermediate variable. This will help you if something goes awry and you need to figure out what's wrong.

Pipes work best for performing linear sequences of operations on single objects. If you're working with multiple objects or complex dependency structures (situations you'll encounter later on), the pipe isn't the tool for the job.

Let's practice chaining operations together using \%$>$\% to identify the highest-scoring games Brazil played in the 2014 World Cup.

Instructions

Create a new data frame, brazil\_goals, by performing the following operations:

Filter the scores data frame to retain only data on matches in which Brazil played (either as the home or the away team. Use the | operator to specify).

Add a new column, total\_goals, containing the total goals scored in each match (home\_goals + away\_goals).

Arrange the data frame by total\_goals so that the matches with the largest number of total goals is at the top of the data frame.

Chain the functions you use together using the \%$>$\% operator to avoid creating intermediate objects.

<<>>=
brazil_goals <- scores %>%
  filter(home_country == "Brazil" | away_country == "Brazil") %>%
  mutate(total_goals = home_goals + away_goals) %>%
  arrange(desc(total_goals))
brazil_goals[1:5,]
@
%==============================================================================
\subsection{Next Steps}
%==============================================================================

In this mission, you learned to use vectorized functions as alternatives to the control structures you learned about earlier in the course, and about why vectorization allows you to make the best use of R's functionality.

You're now able to use R to perform a number of common and important data analysis tasks that you'll use frequently:

Writing vectorized if-else expressions

Splitting data, applying functions to each group, and summarizing the results
Writing simplified code by chaining your functions together using the pipe operator
It's okay if you write code with a mix of vectorized and non-vectorized approaches. We encourage you to use whatever approach you feel most comfortable with to solve your problem, and then go back and think about how you solution might be improved using techniques like vectorization or pipes.

In the next mission, you'll expand your R knowledge as you learn to write your own functions to solve data analysis problems.

\newpage
%==================================================================================
\section{Writing custom functions}
\subsection{Introduction to Writing Your Own Functions}
%=================================================================================

In this course and the last, you've worked with a number of functions. Some are base R functions, like the following:

sum()

min()

max()

mean()

Some of the functions you've worked with are part of packages:

select()

filter()

arrange()

mutate()

All the functions you've seen so far have been written by someone else, and are useful for performing common data manipulation tasks.

However, if the operation you need to repeat is specific to your workflow, you can't count on a function existing in base R or in a user-contributed package.

This is where the ability to write your own functions will be necessary.

In this mission, you'll write custom functions to analyze FiveThirtyEight's data on the 2014 FIFA World Cup.

Let's load the data, "scores.csv" into R and get started writing functions.

Instructions

Use read\_csv() to import the 2014 World Cup data (saved as "scores.csv") into R.
Save it as a data frame called scores.

\begin{lstlisting}
scores<-read_csv("scores.csv")
\end{lstlisting}

%====================================================================================
\subsection{Anatomy of a Function}
%=====================================================================================

You learned earlier in this course that pre-written R functions are written in a compiled language (like Fortran or C) and have an R "wrapper" that users interact with. In this mission, you'll deepen your understanding of functions as you learn to write your own in R.

In R, functions have several components:

Body: The code inside the function.

Arguments: The list of inputs that control how you call the function. Arguments include the data to compute on and the computational details, such as omitting missing values.

Environment: The location (such as the global environment) where the function was created. This is the location where, when a function is called, R finds the values associated with it.

To illustrate a function's body and arguments, let's write a simple function to add three to a variable:


In this example, the add\_3() function arguments consist only of x, which represents the data input. The body of the function is x + 3.

<<>>=
add_3<-function(x){
x+3}
@

By default, the value returned by a function will be whatever the output of the last line that got executed is. If you want to manually specify that R should return something else, such as multiple objects, you can use return() in your function. We'll talk more about this in later courses.

The name of the function above is add\_3. The name you choose for your function should be informative — you want others you're sharing your code with (and yourself) to know what the function does.

When you call a function, the function executes in its own local environment which consists of a temporary copy of everything in the global environment plus whatever data was passed to the function as arguments. When the function finishes executing, the returned value is placed in the environment you called the function in, and the function's local environment is discarded.

To call the add\_3() function on a value, you would write:

\begin{lstlisting}[language=R]
add_3(x = 4)
\end{lstlisting}

<<>>=
add_3(x=4)
@

When you apply a function to data, you do not need to designate input variables using x =. You can simply write:

\begin{lstlisting}[language=R]
add_3(4)
\end{lstlisting}

<<>>=
add_3(4)
@


However, specifying the variables can be a good way to keep track of data inputs, as you will see when you write functions with more than one argument.

You can also call the add\_3() function on a vector, such as the home\_goals variable of the scores data frame:

\begin{lstlisting}[language=R]
add_3(x = scores$home_goals)

30 10 10 30 30 10 10 20 30 20 40 10 20 10  0  0  0 20 20  0 20  0 20 10 10 20 20 10 10 10 0 20 10 20  0  0  0  0 20 30 20  0 10 10 20 20 10 20 20 10 20 20  0  0 10 10  0  0 10
\end{lstlisting}

<<>>=
add_3(x = scores$home_goals)
@

Note that, in R, functions are objects. Once created, they are stored in the environment you created them in. Below, you can see where functions created in the global environment show up in RStudio:

Let's practice writing a function.

Instructions

Write a function to multiply x by 100 and give it a descriptive name.
Call your function on the away\_goals variable of the scores data frame.

Save the resulting vector as away\_by\_100.

<<>>=
fmult<-function(x){
x*100
}

away_by_100<-fmult(x= scores$away_goals)

away_by_100
@

%=======================================================
\subsection{When to Write a Function}
%======================================================

Now that you've seen how functions are written in R, let's talk about when you'll want to write them.

Let's look at an example from the 2014 World Cup data. If you wanted to calculate the proportion of all goals scored in 2014 that were scored during each match, you could write the following code:

\begin{lstlisting}[language=R]
scores$home_goals/sum(scores$home_goals) # home team 

scores$away_goals/sum(scores$away_goals) # away team
\end{lstlisting}
<<>>=
(scores$home_goals/sum(scores$home_goals))*100 # home team 

(scores$away_goals/sum(scores$away_goals))*100 # away team
@

In the example above, you would need to copy and paste lines of code while making minor changes (just the words "home" and "away"). This approach is time-consuming and prone to typing errors.

Instead of writing out the calculation multiple times, you could write a function.

When you write a function, it helps to think about performing the operation on a single element. Let's consider the proportion of 2014 World Cup away\_goals scored during the first match:

For the data frame in the diagram above, to calculate the proportion of total away goals scored by the away team in match one, you would perform the calculation:

<<>>=
1/14
@

Next, think about the inputs to the function. In this case, there is only one — the number of goals scored. We will call the variable argument x.

<<>>=
x/sum(x)
@

Once you've verified the code works, you can create the function. Use the syntax you learned earlier in the mission, and assign the function a name:

<<>>=
proportion_of_total <- function(x) {
  x/sum(x)
}
@

Now, you can apply the function to your variables of interest:

<<>>=
proportion_of_total(scores$home_goals)
proportion_of_total(scores$away_goals)
@

Instructions

The following code calculates the percentage of 2014 World Cup home and away goals scored during each match:


\begin{lstlisting}[language=R]
# home team 
(scores$home_goals/sum(scores$home_goals)) * 100

# away team 
(scores$away_goals/sum(scores$away_goals)) * 100
\end{lstlisting}

<<>>=
# home team 
(scores$home_goals/sum(scores$home_goals)) * 100

# away team 
(scores$away_goals/sum(scores$away_goals)) * 100
@

The code above is repetitive and can be improved by writing a function. Write a function that calculates the percentage of total goals scored in each match.

Call the function on the home\_goals and away\_goals variables of scores. Save the resulting vectors as home\_goals\_percentage and away\_goals\_percentage, respectively.

<<>>=
percentage_of_total <- function(x) {
  x/sum(x) * 100
}
    
home_goals_percentage <- percentage_of_total(scores$home_goals)
away_goals_percentage <- percentage_of_total(scores$away_goals)

home_goals_percentage

away_goals_percentage

@

%==========================================================================================
\subsection{Writing Functions with Two Variables as Arguments}
%=========================================================================================

The functions you've written so far in this mission have had one argument, x, since you were working with a single variable. However, functions can take multiple variables as arguments.

Previously, you wrote a function that took one variable as an argument to calculate the proportion of 2014 World Cup goals scored in each match.

Some instances require a function with multiple variables. For example, if you wanted to calculate the proportion of total goals scored by a team in a given match, you would need to write a function with two variables as arguments:home\_goals and away\_goals.

To calculate the proportion of total goals scored by the home team in the first match, you would perform the calculation:

\begin{lstlisting}[language=R]
home_goals/(home_goals + away_goals)
\end{lstlisting}

You can assign the two variables x and y.

To write the multivariable function, we can use the same syntax you learned for single variable functions.

\begin{lstlisting}[language=R]
proportion <- function(x,y) {
  (x/(x + y))
}
\end{lstlisting}

<<>>=
proportion <- function(x,y) {
  (x/(x + y))
}
@

As you write more complex functions, it can be useful to break out components of the function into named variables. This is helpful when others (and you, in the future) need to look at your code and remember what it does. For example, for the function above, you could assign x + y to the variable xy\_total:

\begin{lstlisting}[language=R]
proportion <- function(x,y) {
  xy_total = x + y  
  (x/xy_total)
}
\end{lstlisting}

<<>>=
proportion <- function(x,y) {
  xy_total = x + y  
  (x/xy_total)
}
@

This function defines a new variable, xy\_total during its execution, but only returns the value of the last line executed. If you think back to our discussion of local environments, xy\_total here is a local variable. If your global environment happened to already contain a variable called xy\_total, it would not be affected by executing this function.

To apply the function to the home\_goals and away\_goals variables, you would write:

\begin{lstlisting}[language=R]
proportion(x = scores$home_goals, y = scores$away_goals)

proportion(x = scores$away_goals, y = scores$home_goals)
\end{lstlisting}

<<>>=
proportion(x = scores$home_goals, y = scores$away_goals)

proportion(x = scores$away_goals, y = scores$home_goals)
@

Let's write a multivariate function to calculate the percentage of total goals that a team scored in a match.

Instructions

Write a two-variable function to calculate the percentage of total goals scored by a team for each match.

Use the function to calculate the percentage of total goals scored by the home team for all matches. Save the resulting vector as home\_percent.

<<>>=
porcentagem<-function(x,y){
  xy_total = x + y  
  (x/xy_total) * 100 }

home_percent<-porcentagem(x=scores$home_goals,y=scores$away_goals)

home_percent[1:5]

@

%=======================================================================================
\subsection{Writing Functions for Conditional Execution}
%=======================================================================================

Let's consider the function we wrote on the previous screen:

\begin{lstlisting}[language=R]
proportion <- function(x,y) {
  xy_total = x + y  
  (x/xy_total)
}
\end{lstlisting}

When we use it to calculate the proportion of total goals scored by the home team for each match:

\begin{lstlisting}[language=R]
proportion(x = scores$home_goals, y = scores$away_goals)
\end{lstlisting}

We get the following output:

<<>>=
proportion(x = scores$home_goals, y = scores$away_goals)
@

Notice the presence of the NaNs. NaN stands for "not a number", and here, it is the result of division by zero when neither team scored any goals. For example, no goals were scored by either team during the 17th match:

\begin{lstlisting}[language=R]
match_id  home_country home_goals away_country away_goals 
17          Brazil          0        Mexico         0
\end{lstlisting}

Therefore, calling the function proportion() would result in the following calculation:

\begin{lstlisting}[language=R]
total_goals = 0 + 0  
(0/0)
\end{lstlisting}

In mathematics, dividing by zero is not possible. Therefore, R cannot return a numeric value.

Let's say that, for matches where the total number of goals scored is zero, we want our proportion() function to return 0 instead of NaN.

Earlier in this course, you learned about using if-else statements as control structures to specify conditional execution of commands. You can include if-else statements in your functions to specify different actions depending on outcomes.

As an example, let's look at the first function you saw in this mission:

\begin{lstlisting}[language=R]
add_3 <- function(x) {add_3 <- function(x) {
  x + 3
}
\end{lstlisting}

Let's rewrite the function to do the following:

Add three to x when x is less than five 

Subtract three from x when x is greater than five.

To start, we'll write the if-else statement:

\begin{lstlisting}[language=R]
if(x < 5) {
  x + 3
} else {
  x - 3
}
\end{lstlisting}

Next, we can incorporate the if-else statement into a function by placing it between the braces ({}):

\begin{lstlisting}[language=R]
add_subtract_3 <- function(x) {
  if(x > 5) {
    x + 3
  } else {
    x - 3
  }
}
\end{lstlisting}

You can use a similar approach to write a function to calculate the proportion of a match's total goals scored by a team if total\_goals is greater than zero and return 0 if no goals were scored.

We'll start with the if-else statement:

\begin{lstlisting}[language=R]
if(x + y > 0) {
  xy_total = x + y 
  (x / xy_total) 
} else {
  0
}
\end{lstlisting}

It's a good idea to plug values for one match into the if-else statement to make sure your code is correct. Here, x is home\_goals, and y is away\_goals.

\begin{lstlisting}[language=R]
if(scores$home_goals[1] + scores$away_goals[1] > 0) {
  xy_total = scores$home_goals[1] + scores$away_goals[1]
  (scores$home_goals[1] / xy_total) 
} else {
  0
}
\end{lstlisting}

<<>>=
if(scores$home_goals[1] + scores$away_goals[1] > 0) {
  xy_total = scores$home_goals[1] + scores$away_goals[1]
  (scores$home_goals[1] / xy_total) 
} else {
  0
}
@

Next, we can write the function:

\begin{lstlisting}[language=R]
proportion_no_na <- function(x,y) {
  if(x + y > 0) {
    xy_total = x + y 
    (x / xy_total) 
  } else {
    0
  }
}
\end{lstlisting}

Note that when you write functions for conditional execution, you can't call them on vectors — just individual values. Later in this course, you'll learn some alternatives to for-loops for applying a function to all elements of a vector or list.

Let's practice writing functions that contain conditional expressions.

Instructions

Write a function that will:

Calculate the percentage of a match's total goals scored by a team if total\_goals is greater than zero.

Return 0 instead of NaN if total\_goals is zero.

Use the function to calculate the percentage of total goals scored by the away team during the 15th match.

<<>>=
proporcao_na<-function(x,y){
    if(x+y>0){
        xy_total<-x+y
        (x/xy_total)
        }else{
        0
    }
}
proporcao_na(x=scores$home_goals[15],y=scores$away_goals[15])
@

%======================================================================
\subsection{Functions with More Than Two Arguments}
%=====================================================================

So far in this mission, you've learned to write functions that take one or two variables as arguments. However, functions can take any number of variables as arguments.

Let's say we wanted to write a function to calculate the sum of two numbers and divide the sum by a third number. We'll call these variables x, y, and z, respectively. To perform this operation, we would need to write a function with three variables as arguments:

\begin{lstlisting}[language=R]
prop_xy_of_z <- function(x,y,z) {
  (x + y) / z
}
\end{lstlisting}

<<>>=
prop_xy_of_z <- function(x,y,z) {
  (x + y) / z
}
@

Applying the function prop\_xy\_of\_z to three input values results in the following:

<<>>=
prop_xy_of_z(4,6,25)
@

To illustrate another example of a multivariable function, let's look at the scores data frame. Let's say a friend who compiled the data made some errors and you'll need to fix them.

The home\_goals variable has had an extra goal added for the first twenty matches (match\_id $<=$ 20).

The away\_goals variable has one goal too few for the rest of the matches (match\_id $>$ 20).

To write a function to subtract one goal from home\_goals for the first twenty matches and add one goal to away\_goals for the remainder of the matches, you'll need to write a multivariable function.

The variables you'll need as arguments are:

match\_id (x)

home\_goals (y)

away\_goals (z)

As we did in the previous example, they're assigned variable names x, y, and z.

You have two actions to perform: subtracting one from home\_goals (y) and adding one to away\_goals (z).

\begin{lstlisting}[language=R]
y - 1
z + 1
\end{lstlisting}

You can use an if-else statement to perform two different actions for the two groups of matches:

match\_id $<=$ 20

The rest of the matches

\begin{lstlisting}[language=R]
if (x <= 20) {   # match id less than or equal to 20
  y - 1    # home goals - 1
} else {
  z + 1    # away goals + 1
}
\end{lstlisting}

Finally, you can write a function:

\begin{lstlisting}[language=R]
total_goals = 0 + 0  
(0/0)
adjust_yz <- function(x,y,z) {
  if (x <= 20) {
    y - 1 
  } else {
    z + 1
  }
}
\end{lstlisting}

To make sure the function works, let's apply it to a match with match\_id less than twenty. For match two, the function should subtract one from the home\_goals value of one:

\begin{lstlisting}[language=R]
adjust_yz(scores$match_id[2], scores$home_goals[2], scores$away_goals[2])
\end{lstlisting}

As expected, the result is zero.

Let's try the function for a match with match\_id greater than twenty. For match 30, the function should add one to the away\_goals value of three:

\begin{lstlisting}[language=R]
adjust_yz(scores$match_id[30], scores$home_goals[30], scores$away_goals[30])
\end{lstlisting}

As expected, the result is four.

Let's practice writing a multivariable function to make changes to home\_goals and away\_goals depending on match\_id.

Instructions

Write a multivariable function that performs the following:

For matches five through 10 (including 10), multiply home\_goals by two.

For all other matches, subtract one from away\_goals.

Use the function to calculate the actual goals scored by the away team during the first match. Save the result to match\_one.

Use the function to calculate the actual goals scored by the home team during the fifth match. Save the result to match\_five.


<<>>=
adjust_yz <- function(x,y,z) {
  if (x >= 5 & x <= 10) {
    y * 2 
  } else {
    z - 1
  }
}

match_one <- adjust_yz(x = scores$match_id[1], y = scores$home_goals[1], z = scores$away_goals[1])
match_five <- adjust_yz(x = scores$match_id[5], y = scores$home_goals[5], z = scores$away_goals[5])
@

%======================
\subsection{Next Steps}
%===========================

In this mission, you've learned to write your own single and multivariable functions to replace repetition in your code.

In some cases, functions you write in R will not operate like the vectorized examples of pre-written functions you saw earlier in this course. You won't be able to apply them to all elements of a vector without repeating the operation on each of the vector's elements.

In the next mission, you'll learn how to apply functions you have written to vectors and lists using a set of tools called functionals in place of for-loops.


%=====================================================
\section{Working with functionals}
\subsection{Introduction Functionals}
%=====================================================

Earlier in this course, you learned to work with vectorized R functions. These functions allowed you to efficiently perform operations on all elements of a vector.

For example, the mean() function takes a vector as input and calculates the average of its values.

\begin{lstlisting}[language=R]
mean(1:10)

5.5
\end{lstlisting}

<<>>=
mean(1:10)
@

Some of the functions you wrote yourself can also be called on vectors. For example, you wrote the following function to calculate the percentage of total goals scored in each match in the 2014 World Cup:

\begin{lstlisting}[language=R]
percentage_of_total <- function(x) {
  x/sum(x) * 100
}
\end{lstlisting}

<<>>=
percentage_of_total <- function(x) {
  x/sum(x) * 100
}
@

If you call the function on a vector, a vector of the same length as the input vector x is returned:

\begin{lstlisting}[language=R]
percentage_of_total(scores$home_goals)

3.947368 1.315789 1.315789 3.947368 3.947368 1.315789 1.315789 2.631579 3.947368 2.631579 5.263158 1.315789 2.631579 1.315789 0.000000 0.000000 0.000000 2.631579 2.631579 0.000000 2.631579 0.000000 2.631579 1.315789 1.315789 2.631579 2.631579 1.315789 1.315789 1.315789 0.000000 2.631579 1.315789 2.631579 0.000000 0.000000 0.000000 0.000000 2.631579 3.947368 2.631579 0.000000 1.315789 1.315789 2.631579 2.631579 1.315789 2.631579 2.631579 1.315789 2.631579 2.631579 0.000000 0.000000 1.315789 1.315789 0.000000 0.000000 1.315789
\end{lstlisting}

<<>>=
percentage_of_total(scores$home_goals)
@

Not all functions in R can be applied to all elements of a vector at once, though. For example, let's consider this function, containing an if-else statement for conditional execution, that you wrote in the previous mission:

\begin{lstlisting}[language=R]
percentage_no_na <- function(x,y) {
  if(x + y > 0) {
    xy_total = x + y 
    (x/xy_total) * 100
  } else {
    0
  }
}
\end{lstlisting}

<<>>=
percentage_no_na <- function(x,y) {
  if(x + y > 0) {
    xy_total = x + y 
    (x/xy_total) * 100
  } else {
    0
  }
}
@

If you try to apply the function to two vectors as input x and y arguments:

\begin{lstlisting}[language=R]
percentage_no_na(x = scores$home_goals, y = scores$away_goals)
\end{lstlisting}

<<>>=
percentage_no_na(x = scores$home_goals, y = scores$away_goals)
@

You'll receive a warning message:

\begin{lstlisting}[language=R]
Warning message:
In if (x + y > 0) { :
  the condition has length > 1 and only the first element will be used
\end{lstlisting}
  
This function is not vectorized — you need to repeatedly execute it on rows of the scores data frame.

You could do this using a for-loop:

\begin{lstlisting}[language=R]
percentage_home <- c()

for (i in 1:nrow(scores)) {  
  if(scores$home_goals[i] + scores$away_goals[i] > 0) {
    percentage_home <- c(percentage_home, (scores$home_goals[i]/(scores$home_goals[i] + scores$away_goals[i]) * 100))
  } else {
    percentage_home <- c(percentage_home, 0)
  }
}
\end{lstlisting}

Using a for-loop is not necessarily a bad choice here, but if you look at the code, it isn't very easy to see what's going on.

As an alternative to for-loops, you could use R's functionals. Functionals are a special kind of function. They take a function and a list or vector of data and apply it as inputs and return a list or vector as output:

Functionals eliminate the need for for-loops in many situations by allowing you to apply any function to all elements of a list or vector.

In this mission, you'll learn to work with functionals to replace for-loops in a number of data manipulation scenarios using the functions you wrote in the last mission as you analyzed FiveThirtyEight's data on the 2014 FIFA World Cup.

Let's import the World Cup data into R using read\_csv() and save it as a data frame named scores.

Instructions

Use read\_csv to import the scores.csv file into R. Save the data as a data frame called scores.

%o dataset já está importado


%======================================================================
\subsection{Working With Functionals From the Tidyverse purrr Package}
%======================================================================

In earlier courses, we discussed R's ever-expanding functionality — the result of user-contributed packages.

Base R includes a family of functionals, known as the "apply" family, that allow you to apply functions to elements of an object. However, there are some aspects of the apply functions that can make them somewhat cumbersome to work with:

The user interface syntax is inconsistent among the different functionals in the apply family.

The apply functionals output data in inconsistent formats, which can be confusing.
Instead, in this course, we'll focus on teaching tools for using functionals from a relatively recent addition to the tidyverse: The purrr package. The functionals in the purrr package can be used for the same purposes as the apply family of functionals, and their consistency in syntax and output makes them easier to use and allows for more legible code.

Let's install and load the package:

\begin{lstlisting}[language=R]
install.packages("purrr")
library(purrr)
\end{lstlisting}

We'll begin by introducing the purrr functional map(), which takes a vector or list, applies a single-variable function to its elements, and returns a list.

So you can clearly envision how map() works, we'll create the following short list containing home and away team goals for the first five matches of the 2014 World Cup:

\begin{lstlisting}[language=R]
match_results <- list(c(3,1), c(1,0), c(1,5), c(3,1), c(3,0))
​
names(match_results) <- c("match 1", "match 2", "match 3", "match 4", "match 5")
Here's what the list looks like:

$`match 1`
[1] 3 1
​
$`match 2`
[1] 1 0
​
$`match 3`
[1] 1 5
​
$`match 4`
[1] 3 1
​
$`match 5`
[1] 3 0
\end{lstlisting}

Let's calculate the total goals scored in each match by applying the sum() function to each match in the list match\_results.


To use the map() functional for this task, you would include the list or vector of data (match\_results) and the function (sum) as arguments:

\begin{lstlisting}[language=R]
map(match_results, sum)
\end{lstlisting}


The code above returns a list of total goals for each match:

\begin{lstlisting}[language=R]
$`match 1`
[1] 4
​
$`match 2`
[1] 1
​
$`match 3`
[1] 6
​
$`match 4`
[1] 4
​
\end{lstlisting}

It's important to note the list returned as output contains the same structure and names as the original list. This is a feature of functions in the purrr package that makes it a good choice for writing clear, intuitive code.

Let's practice using the map() functional.

Instructions

Calculate the lowest score (using the min() function) in each match in the match\_results list using the map() functional.

Save the resulting list as min\_scores.

<<>>=
match_results <- list(c(3,1), c(1,0), c(1,5), c(3,1), c(3,0))
names(match_results) <- c("match 1", "match 2", "match 3", "match 4", "match 5")
min_scores<-map(match_results,min)
@
%=======================================================
\subsection{Using Functionals to Apply Custom Functions}
%======================================================

You've now seen how to use the map() functional to apply a built-in function to a list. You can use functionals to apply any function to elements of a list or data frame.

Earlier, we wrote a function to calculate the proportion of 2014 World Cup goals that were scored during each match:

\begin{lstlisting}[language=R]
proportion_of_total <- function(x) {
  x/sum(x)
}
\end{lstlisting}

<<>>=
proportion_of_total <- function(x) {
  x/sum(x)
}
@

We then applied the function to two variables in scores:

\begin{lstlisting}[language=R]
proportion_of_total(scores$home_goals)
proportion_of_total(scores$away_goals)
\end{lstlisting}

<<>>=
proportion_of_total(scores$home_goals)
proportion_of_total(scores$away_goals)
@

As an alternative to writing out the two expressions, you could use the map() functional to apply the proportion\_of\_total() function to multiple variables of the scores data frame.

You can make use of functions for manipulating data frames in the dplyr package and functionals from the purrr package to write efficient code.

For example, if you wanted to apply the proportion_of_total() function to the home\_goals and away\_goals variables in the scores data frame, you could use select() to choose the variables you wanted to work with and map() to apply the function to them:


You would need to load the dplyr and purrr libraries, and you could write:

\begin{lstlisting}[language=R]
library(dplyr)
library(purrr)

scores %>%
  select(home_goals, away_goals) %>%
  map(proportion_of_total)
\end{lstlisting}

<<>>=
library(dplyr)
library(purrr)

scores %>%
  select(home_goals, away_goals) %>%
  map(proportion_of_total)
@


The map() functional applies the proportion\_of\_total() function to each element of the scores data frame — the home\_goals and away\_goals variable vectors. The result is a list of output vectors for each variable (recall that map() always returns a list):

\begin{lstlisting}[language=R]
$home_goals
 [1] 3.947368 1.315789 1.315789 3.947368 3.947368 1.315789 1.315789 2.631579 3.947368 2.631579 5.263158 1.315789
[13] 2.631579 1.315789 0.000000 0.000000 0.000000 2.631579 2.631579 0.000000 2.631579 0.000000 2.631579 1.315789
[25] 1.315789 2.631579 2.631579 1.315789 1.315789 1.315789 0.000000 2.631579 1.315789 2.631579 0.000000 0.000000
[37] 0.000000 0.000000 2.631579 3.947368 2.631579 0.000000 1.315789 1.315789 2.631579 2.631579 1.315789 2.631579
[49] 2.631579 1.315789 2.631579 2.631579 0.000000 0.000000 1.315789 1.315789 0.000000 0.000000 1.315789

$away_goals
 [1] 1.219512 0.000000 6.097561 1.219512 0.000000 3.658537 2.439024 1.219512 0.000000 1.219512 0.000000 2.439024
[13] 1.219512 1.219512 0.000000 4.878049 2.439024 3.658537 1.219512 0.000000 1.219512 1.219512 6.097561 0.000000
[25] 0.000000 2.439024 2.439024 0.000000 4.878049 3.658537 3.658537 0.000000 4.878049 1.219512 1.219512 0.000000
\end{lstlisting}

<<>>=
selectduasvar<-scores %>%
  select(home_goals, away_goals) %>%
  map(proportion_of_total)
  
selectduasvar
@

Although we were only applying the function to two variables in the scores data frame in this case, this approach would scale well for applying a single-variable function to a much larger list of variables.

Let's use map() to apply the percentage\_of\_total() function you wrote to multiple variables in the scores data frame.

Instructions

Earlier in this course, you wrote a function to calculate the percentage of total goals scored in each match of the 2014 World Cup:

\begin{lstlisting}[language=R]
percentage_of_total <- function(x) {
  x/sum(x) * 100
}
\end{lstlisting}

<<>>=
percentage_of_total <- function(x) {
  x/sum(x) * 100
}
@

Write an expression to perform the following operations on the scores data frame:
Select the home\_goals and away\_goals variables

Use map() to apply the percentage\_of\_total() function to the two variables
Store the output list as per\_goals\_output

<<>>=
percentage_of_total <- function(x) {
  x/sum(x) * 100
}
per_goals_output<-scores%>%
    select(home_goals,away_goals)%>%
    map(percentage_of_total)
@

%===================================================================
\subsection{Functionals to Return Vectors of Specified Types}
%===================================================================

You've seen that the map() functional always returns a list, and that it retains the names and structure of its inputs. This consistency is helpful for writing organized, predictable code.

In the previous example, when you used map() to apply the percentage\_of\_total function to two variables, you wanted to return a list of two vectors.

Sometimes, however, you'll want to specify output of a different type. For example, maybe you want to calculate the total goals in each match and return a vector instead of a list so you can add it to a data frame as a new variable.

The purrr package contains the following variants of the map() functional, which allow you to return a vector consisting of output of the specified data type:

map\_lgl() returns a logical vector

map\_int() returns an integer vector

map\_dbl() returns a double vector

map\_chr() returns a character vector

Remember that in R, integer and double data types are subsets of the numeric data type.

If you use the map\_dbl() functional to apply the sum() function to the match\_results list:

map\_dbl(match\_results, sum)
The result is a vector of double values with the name attributes retained:

match 1 match 2 match 3 match 4 match 5 
      4       1       6       4       3
      
Let's see what happens if you use the map\_chr() functional to apply the function sum() to all elements of the match\_results list.

Instructions

Use the map\_chr() functional to apply the function sum() to all elements of the match\_results list.

Save the resuting output as sum\_chr, and use the typeof() function to check the data type.

<<>>=
library(dplyr)
library(purrr)

match_results <- list(c(3,1), c(1,0), c(1,5), c(3,1), c(3,0))
names(match_results) <- c("match 1", "match 2", "match 3", "match 4", "match 5")

sum_chr<-map_chr(match_results,sum)
sum_chr
typeof(sum_chr)
@

%========================================
\subsection{Functionals for Two-Variable Functions}
%========================================

The map() functional can be used to apply any single-variable function to elements of a vector or list. But what about functions with more than one variable?

In the previous mission, we wrote the following two-variable function to calculate the proportion of total goals scored by a team in a given match:

\begin{lstlisting}[language=R]
proportion_no_na <- function(x,y) {
  if(x + y > 0) {
  xy_totals = x + y 
  (x / xy_total) 
  } else {
    0
  }
}
\end{lstlisting}

Recall that the function includes a conditional expression so that instances of NaN arising from division by zero will be replaced with 0.

When applying a function with two variable inputs, you'll need to use a different functional from the purrr package: map2().

The map2() functional takes two variables and a function as arguments and returns a list:

Syntax for map2() is somewhat different from syntax for map(), since there are two variables that must be specified before the function:

\begin{lstlisting}[language=R]
map2(variable_1, variable_2, function)
\end{lstlisting}

To apply the proportion\_no\_na function to calculate the proportion of each match's total goals scored by the home team, you would list the x variable (home\_goals), the y variable (away\_goals), and the function.

\begin{lstlisting}[language=R]
map2(scores$home_goals, scores$away_goals, proportion_no_na)
\end{lstlisting}

We will not use the pipe operator in this situation since we need to call map2() on multiple arguments and therefore cannot pass function output from left to right.

Like map(), map2() always returns a list. Here are the first five lines of the resulting list of output:

\begin{lstlisting}[language=R]
[[1]]
[1] 75
​
[[2]]
[1] 100
​
[[3]]
[1] 16.66667
​
[[4]]
[1] 75
​
[[5]]
[1] 100
\end{lstlisting}

Now, let's use map2() to apply the percentage\_no\_na function to variables in the scores data frame.

Instructions

Use map2() and the function percentage\_no\_na to calculate the percentage of total goals scored by the home team for each match.

Save the resulting list as percent\_goals\_home.

<<>>=
percentage_no_na <- function(x,y) {
  if(x + y > 0) {
    xy_total = x + y 
    (x/xy_total) * 100
  } else {
     0
  }
}
percent_goals_home <- map2(scores$home_goals, scores$away_goals, percentage_no_na)

percent_goals_home[1:3]
@
%=====================================================
\subsection{Functionals for Returning Vectors of Specific Types from Functions With Two Variables}
%=====================================================

When we use the map2() functional to apply a function to two variables, the output is always a list:

\begin{lstlisting}[language=R]
[[1]]
[1] 75
​
[[2]]
[1] 100
​
[[3]]
[1] 16.66667
​
[[4]]
[1] 75
​
[[5]]
[1] 100
\end{lstlisting}

Recall that this is also the case for map().

In the case of the map() example we looked at earlier in this mission, we wanted map() to return a list for each element of scores that we were applying the function to — the variables home_goals and away\_goals.

In this case, however, we may not want a list of 59 values as output. Instead, we would like a vector.

As you learned earlier in the course, there are variants of map() that are used to return a vector of a specific data type. The purrr package contains the same variants for map2():

map2\_lgl() returns a logical vector

map2\_int() returns an integer vector

map2\_dbl() returns a double vector

map2\_chr() returns a character vector

To apply the proportion\_no\_na function to return a vector of double (numeric) data, you would write:

\begin{lstlisting}[language=R]
scores$away_goals, proportion_no_na)
map2_dbl(scores$home_goals, scores$away_goals, proportion_no_na)
\end{lstlisting}

<<>>=
scores$away_goals, proportion_no_na)
map2_dbl(scores$home_goals, scores$away_goals, proportion_no_na)
@

The resulting output is a vector of numeric data:

\begin{lstlisting}[language=R]
[1] 0.7500000 1.0000000 0.1666667 0.7500000 1.0000000
 [6] 0.2500000 0.3333333 0.6666667 1.0000000 0.6666667
[11] 1.0000000 0.3333333 0.6666667 0.5000000 0.0000000
[16] 0.0000000 0.0000000 0.4000000 0.6666667 0.0000000
[21] 0.6666667 0.0000000 0.2857143 1.0000000 1.0000000
[26] 0.5000000 0.5000000 1.0000000 0.2000000 0.2500000
[31] 0.0000000 1.0000000 0.2000000 0.6666667 0.0000000
[36] 0.0000000 0.0000000 0.0000000 0.4000000 0.7500000
[41] 0.6666667 0.0000000 0.5000000 0.5000000 1.0000000
[46] 0.6666667 0.5000000 1.0000000 0.6666667 1.0000000
[51] 0.6666667 0.6666667 0.0000000 0.0000000 1.0000000
[56] 0.1250000 0.0000000 0.0000000 1.
\end{lstlisting}

Let's use map2\_dbl to create a new variable containing the percentage of total goals scored by the home team for each match.

Instructions

Use map2\_dbl() to create a new variable, percent\_goals\_home, containing the percentage of total goals scored by the home team for each match.

Use the percentage\_no\_na() function, which we have written for you.
Use mutate() to add percent\_goals\_home as a new variable to the scores data frame. Save the new data frame as scores\_2.

<<>>=
percentage_no_na <- function(x,y) {
  if(x+y > 0) {
    total_goals = x+y 
    (x/total_goals) * 100
  } else {
    0
  }
}
scores_2 <- scores %>% 
  mutate(percent_goals_home = map2_dbl(scores$home_goals,scores$away_goals, percentage_no_na))
  
scores_2[1:10]
@

%============================================================
\subsection{Functionals for Functions with More Than Two Variable Arguments}
%===========================================================

So far, you've learned to use purrr package functionals map() and map2() (as well as their variants for returning vectors) to apply functions with one or two arguments to multiple elements of a vector or list.

However, as you learned when you wrote your own functions in the previous mission, functions can take more than two variables as arguments.

In the last mission, we wrote a multivariable function to subtract one goal from home\_goals for the first twenty matches of the 2014 World Cup and add one goal to away\_goals for the remainder of the matches.

\begin{lstlisting}[language=R]
adjust_yz <- function(x,y,z) {
  if (x <= 20) {
    y - 1 
  } else {
    z + 1
  }
}
\end{lstlisting}

<<>>=
adjust_yz <- function(x,y,z) {
  if (x <= 20) {
    y - 1 
  } else {
    z + 1
  }
}
@

How would you apply this function to the scores data frame? The purrr package contains a functional for working with functions with any number of variables as arguments: pmap().


Working with the pmap() functional is somewhat different from working with map() and map\_2() because function arguments are provided as a list. The syntax for using pmap() to apply a function to multiple elements looks like:

\begin{lstlisting}[language=R]
scores$away_goals, proportion_no_na)
pmap(list_of_arguments, function)
\end{lstlisting}

<<>>=
scores$away_goals, proportion_no_na)
pmap(list_of_arguments, function)
@

As it does for map() and map2(), purrr includes variants of pmap() that return vectors of specific types:

pmap\_lgl() returns a logical vector

pmap\_int() returns an integer vector

pmap\_dbl() returns a double vector

pmap\_chr() returns a character vector

You may wonder why you wouldn't use the pmap() functional all the time instead of map() and map2(). The answer is that, because it is optimized to work with more computationally intensive functions, pmap() is slower than map() and map2(). This will make a difference when you begin working with larger data sets.

Let's use pmap\_dbl() to apply the adjust\_yz function to the scores data frame and return a numeric vector. First, we'll create a new list, args\_list, containing the variables we are working with:

\begin{lstlisting}[language=R]
args_list <- list(x = scores$match_id, y = scores$home_goals, z = scores$away_goals)
\end{lstlisting}

<<>>=
args_list <- list(x = scores$match_id, y = scores$home_goals, z = scores$away_goals)
@

Although you do not need to specify the variable letters in the list, this is helpful for keeping track of the function arguments.

Next, you'd use the pmap\_dbl() functional to apply the adjust\_yz function to the list of arguments:

\begin{lstlisting}[language=R]
pmap_dbl(args_list, adjust_yz)
\end{lstlisting}

<<>>=
pmap_dbl(args_list, adjust_yz)
@


The output is a vector of double data:

\begin{lstlisting}[language=R]
2  1 -4  2  3 -2 -1  1  3  1  4 -1  1  0  0 -4 -2 -1  2  0  2  0  2  1  1  2  2  1  1  1  0  2  1  2  0  0  0  0  2  3  2  0  1  1  2  2  1  2  2  1  2  2  0  0  1  1  0  0  1
\end{lstlisting}

In the previous mission, you wrote a function to perform the following:

For matches five through 10, multiply home\_goals by two.

For all other matches, subtract one from away\_goals.

\begin{lstlisting}[language=R]
adjust_yz_2 <- function(x,y,z) {
  if (x >= 5 & x <= 10) {
    y * 2 
  } else {
    z - 1
  }
}
\end{lstlisting}

<<>>=
adjust_yz_2 <- function(x,y,z) {
  if (x >= 5 & x <= 10) {
    y * 2 
  } else {
    z - 1
  }
}
@

Let's use pmap() to apply adjust\_yz\_2 to the scores data frame.

Instructions

Use the appropriate pmap() variant to apply adjust\_yz\_2 to the scores data and return a numeric vector.

Save the resulting vector as adjusted\_scores.

<<>>=
adjust_yz_2 <- function(x,y,z) {
  if (x >= 5 & x <= 10) {
    y * 2 
  } else {
    z - 1
  }
}

listadearg<-list(x=scores$match_id,y=scores$home_goals,z=scores$away_goals)

listadearg

adjusted_scores<-pmap_dbl(listadearg,adjust_yz_2)

adjusted_scores
@

%=============================================
\subsection{Next Steps}
%=============================================

In this mission, you've learned to use functionals to take the place of for-loops.

In this course so far, you've learned to make use of programming tools that give you flexibility when it comes to data manipulation and analysis. However, you've focused mainly on manipulating numeric data.

In the next few missions, you'll learn to wrangle string, or character, data in R. Learning to work with string data will enable you to work with a wide variety of data sets and provide you with more tools for solving data analysis problems.

\newpage

%=================================================
\section{Fundamentals of string manipulation}
\subsection{Working With Strings}
%================================================

In this course and the last, you've learned to write R code to manipulate data in a variety of ways:

Using arithmetic and comparison operators to perform calculations

Using control structures and functions to execute operations based on conditions

Repeating operations on elements of a data frame or list using loops and functionals

You've mainly learned to use these techniques to work with numeric data. However, data analysts and scientists frequently need to work with sequences of characters, otherwise known as string data, as well.

While you haven't learned to manipulate string data yet, you've seen it as part of the 2014 World Cup data set you've been working with in this course. For example, the home\_country variable of the scores data frame consists of string data:

\begin{lstlisting}[language=R]
scores$home_country
​
 [1] "Brazil" "Mexico" "Spain" "Chile" "Colombia"   
 [6] "Uruguay" "England" "Switzerland" "France" "Argentina"
 \end{lstlisting}
 
<<>>=
scores$home_country
@
 
Knowing how to manipulate strings will come in handy often. Sometimes you'll need to extract part of a string, such as a name, date, or time that's buried in a longer character string. Imagine you're presented with data in the following format and asked to calculate the average number of goals scored on each date:

\begin{lstlisting}[language=R]
[1] "Brazil beat Croatia on June 12 2014 with scores of 3 to 1"   
[2] "Mexico beat Cameroon on June 13 2014 with scores of 1 to 0"
[3] "Netherlands beat Spain on June 13 2014 with scores of 5 to 1"
[4] "Chile beat Australia on June 13 2014 with scores of 3 to 1"
[5] "Colombia beat Greece on June 14 2014 with scores of 3 to 0"
\end{lstlisting}


You would first need to extract the match dates and the scores from each string in order to perform the calculation.

In this mission, you'll learn to manipulate string components of FiveThirtyEight's data on the 2014 FIFA World Cup.

You'll work on performing string manipulations, as well as reviewing data analysis techniques including data frame manipulations and built-in functions for solving split-apply-combine problems.

Let's get started by importing the data.

Instructions

Import the World Cup data, "scores.csv", into R using read\_csv() and save it as a data frame named scores.

<<>>=
#os dados ja foram importados aqui no overleaf
@
%==============================================
\subsection{Subsetting Strings by Position}
%=============================================


Let's take a look at the first few rows of the scores data frame:
<<>>=
scores[1:5,]
@


In previous missions in this course, you've worked with the numeric components of the scores data frame: The match\_id, home\_goals, and away\_goals variables. In this mission, you'll learn to work with variables containing character data like match\_date, home\_country and away\_country.

You'll perform the following tasks:

Calculate the average number of goals scored during each of the two months in which 2014 World Cup matches were played: June and July.

Generate a new variable consisting of a summary of each match result.

As you learn to manipulate strings, you'll work with a new tidyverse package: stringr. The stringr package contains tools for combining, splitting, adding, and removing spaces from, and performing other useful manipulations with string data. Let's install and load the package:

\begin{lstlisting}[language=R]
install.packages("stringr")
library(stringr)
\end{lstlisting}

<<>>=
library(stringr)
@

Functions in the stringr package have consistent syntax — all begin with the prefix str\_, which makes working with the package especially convenient in RStudio because of its autocomplete feature.

Let's get started with the task of calculating the average number of total goals scored in each month.

You learned how to solve "split-apply-combine" problems like this earlier in the course using the dplyr functions group\_by() and summarize(). In this case, you could:

Use mutate() to create a new variable, total\_goals, by adding home\_goals and away\_goals

Group the scores data frame by month using group\_by()

Calculate the average total\_goals for each month using summarize()

As you look at the scores data frame, you'll see there's only one problem: There's a match_date variable that consists of the month and day on which a match was played. However, there's no month variable to use to group the data frame by.

This is the sort of problem string manipulation can be used to solve. You can use a few different methods to extract the month from match\_date and create a new match\_month variable.

Let's start by learning to use a function for subsetting strings: str\_sub().

The str\_sub() function takes a string, subsets it based on positions of characters within the string, and returns a new string containing only the characters between the specified positions:

Note that the string that is returned includes the characters in the positions you specify as well as those between them. All characters are included, including spaces.

The str\_sub() function is vectorized. You can apply it to a vector and return a new vector:


To subset the home\_country variable and return a new vector consisting of the first four letters of each country, you would specify positions from left to right and would write:

\begin{lstlisting}[language=R]
str_sub(scores$home_country, 1, 4)
\end{lstlisting}

<<>>=
str_sub(scores$home_country, 1, 4)
@

You can also specify positions from right to left by using a - before the position number.

If you wanted to return the last four letters of each country, you would write:

\begin{lstlisting}[language=R]
str_sub(scores$home_country, -4, -1) 
\end{lstlisting}

<<>>=
str_sub(scores$home_country, -4, -1) 
@

Let's use str\_sub() to return a vector containing the month in which each match was played.

Instructions

Use the str\_sub() function to extract the month from match\_date, and save the new vector as match\_month.

<<>>=
match_month<-str_sub(scores$match_date,-4,-1)

match_month
@
%==========================================
\subsection{Splitting Strings}
%==========================================

You've now created a vector containing the month in which each match was played by subsetting the match\_date variable:

<<>>=
scores$match_month[1:5]
@

Using the str\_sub() function and extracting the month from match\_date by position achieved your goal here, but you may have noticed it would not have worked if the month names were different lengths.

Let's say you had the following vector, match\_date_2:

<<>>=
scores$match_date_2[1:5]
@

If you tried to extract the month from match\_date\_2 using str\_sub() as you did for match\_date, the output vector would consist of the following

<<>>=
str_sub(scores$match_date_2, -4, -1) 
@

Let's learn about another technique for subsetting strings that isn't position-dependent — splitting strings using the str\_split() function.

The str\_split() function is used to split a string into pieces. The place where the string is split, such as a space, a comma, or another character or characters, is referred to as the delimeter.

For example, since match\_date\_2 contains days and months separated by a space, you can use str\_split() to separate it into day and month by specifying the space as the delimiter:

To split match\_date\_2 at the space between day and month, you would write:

<<>>=
str_split(scores$match_date_2, " ")
@

The str\_split() function output is, by default, a list:

<<>>=
l<-str_split(scores$match_date_2, " ")
l
@

However, you can simplify output into a matrix using the argument simplify = TRUE:

<<>>=
match_date_2_split <- str_split(scores$match_date_2, " ", simplify = TRUE)
@

Recall that you can index a matrix to extract columns. If you wanted to save the second column of the matrix match\_date\_2\_split as a new vector, you could write:

\begin{lstlisting}[language=R]
match_month <- match_date_2_split[,2]
\end{lstlisting}


Let's use the str\_split() function to separate the match\_date variable of the scores data frame into day and month.

Instructions

Use str\_split() to split match\_date to create a matrix, match\_matrix, containing day and month.

Use mutate() to add a new variable containing only the month in which each match was played, match\_month, to the scores data frame. Overwrite the original scores data frame with the one containing match\_month.

<<>>=
match_matrix <- str_split(scores$match_date, " ", simplify = TRUE)

scores <- scores %>%
 mutate(match_month = match_matrix[,2])
 
scores[1:5]
@

%============================================================
\subsection{Calculating Average Goals Per Month}
%===========================================================

Let's return to our initial goal of calculating the average number of total goals scored each month.

To perform this task, you'll make use of the new match\_month variable you created, as well as techniques you've learned previously in this course:

Creating a new data frame variable using mutate()

Using group\_by() and summarize() to solve a "split-apply-combine" problem

Using the pipe operator \%$>$\% to chain functions (if you choose)

The scores data frame now contains a new match\_month variable you can use to calculate monthly total goal averages.

Instructions

Follow the steps below to analyze the 2014 World Cup data to calculate a monthly average of total goals scored.

Create a new variable, total\_goals, that consists of the sum of home\_goals and away\_goals. Add it to the scores data frame.

Group the scores data frame by match\_month.

Summarize the grouped scores data frame to calculate the average number of total\_goals scored each month using summarize().

Save the results as avg\_monthly\_goals.


<<>>=
avg_monthly_goals <- scores %>%
  mutate(total_goals = home_goals + away_goals) %>%
  group_by(match_month) %>%
  summarize(mean(total_goals))

avg_monthly_goals
@

%==============================================
\subsection{Combining Strings}
%==============================================

Now you're able to subset strings to create new variables for performing analyses.

For the rest of the mission, we'll focus on a second task: Manipulating string data in the scores data frame to generate a new variable consisting of a summary of each match result.

Let's say you've been asked to create a summary of each match in the 2014 World Cup from the scores data frame. For each match, you need a summary in the following format:

\begin{lstlisting}[language=R]
"Argentina beat Switzerland on July 01 2014 with scores of 1 to 0"
\end{lstlisting}

You'll learn how to use stringr functions to manipulate string variables in the scores data frame to generate summaries for each match.

To begin, we'll introduce a function for combining strings: str\_c().

For example, let's use the str\_c() function to combine multiple string variables from the scores data frame into a single variable.

To combine the home\_country and away\_country strings, you would write:

<<>>=
str_c(scores$home_country, scores$away_country)
@

The first few rows of the output vector look like:

\begin{lstlisting}[language=R]
"BrazilCroatia" "MexicoCameroon" "SpainNetherlands"               
"ChileAustralia" "ColombiaGreece" "UruguayCosta Rica"
\end{lstlisting}

You can use the sep = argument within the str\_c() function to specify characters to place between the strings you're combining. In the following example, the code specifies output of a vector that contains the two countries separated by a space:

<<>>=
str_c(scores$home_country, scores$away_country, sep = " ")
@

In the following example, the code specifies that countries will be separated by the words "played against":

<<>>=
str_c(scores$home_country, scores$away_country, sep = " played against ")
@

Note the spaces on either side of "played against" in the code above. Spaces count as characters. If you don't include them, the results will look like Brazilplayed againstCroatia.

To practice using str\_c(), let's create a new variable containing information about the teams that played in each match and which team won.


Instructions

The scores data frame already contains a variable, win\_country, for the winning team. Create a new variable, lose\_country, for the losing team. For now, don't worry about instances in which the match result was a tie. You could write a custom function or use the dplyr if\_else() function to create the lose\_country variable. The choice is yours.

Add the lose\_country variable to the scores data frame — overwrite the original scores data frame with the one containing lose\_country.

Use the str\_c() function to create a new variable, team\_results, containing a summary of match results in the following format: win\_country beat lose\_country.

<<>>=
scores <- scores %>% 
        mutate(lose_country = if_else(win_country == home_country, away_country, home_country))
        
team_results <- str_c(scores$win_country, " beat ", scores$lose_country)

team_results
@

%==================================================
\subsection{String Manipulations for Reformatting Match Dates}
%=================================================

You've now learned to create a new variable, team\_results, that contains data in the format of the first portion (Argentina beat Switzerland) of the summary you're working on generating:

\begin{lstlisting}[language=R]
"Argentina beat Switzerland on July 01 2014 with scores of 1 to 0"
"Argentina beat Switzerland on July 01 2014 with scores of 1 to 0"
\end{lstlisting}

Next, let's focus on manipulating the match\_date provided in the scores data frame to get it to match the formatting required for the summary.

Earlier in this mission, you created a new variable, match\_month, containing the month in which each match was played and added it to the scores data frame:

\begin{lstlisting}[language=R]
match_matrix <- str_split(scores$match_date, " ", simplify = TRUE)

scores <- scores %>%
 mutate(match_month = match_month_matrix[,2])
\end{lstlisting}

Remember when you used str\_split() to separate the match\_date variable at the space between day and month, you used the simplify argument to specify a matrix as output.

Here are the first five rows of match\_matrix:

\begin{lstlisting}[language=R]
[,1] [,2]  
 [1,] "12" "June"
 [2,] "13" "June"
 [3,] "13" "June"
 [4,] "13" "June"
 [5,] "14" "June"
\end{lstlisting}

 
To create the match\_month variable, you indexed match\_matrix to select the second column.

Let's use a similar approach to extract the day of the month.

Instructions

Create a new variable, match\_day, by indexing to select the first column of match\_matrix.

Do not add the new variable to the scores data frame.

<<>>=
match_matrix <- str_split(scores$match_date, " ", simplify = TRUE)
match_day<-match_matrix[,1]

match_matrix[1:5]
@

%==============================================
\subsection{Padding Strings}
%==============================================

Let's take a look at the match\_day variable you just created:

\begin{lstlisting}[language=R]
"Argentina beat Switzerland on July 01 2014 with scores of 1 to 0"
"12" "13" "13" "13" "14" "14" "15" "15" "15" "15" "16" "16" "17" "17" "17" "18" "18" "18" "19" "19" "19" "20" "20" "21" "21" "21" "22" "22" "23" "23" "23" "23" "24" "24" "24" "24" "25" "25" "25" "25" "26" "26" "26" "28" "28" "29" "29" "30" "30" "1"  "1"  "4"  "4" "5"  "5"  "8"  "9" "12" "13"
\end{lstlisting}  

If you compare the format of the match\_day to the day of the month component of the summary:

\begin{lstlisting}[language=R]
"Argentina beat Switzerland on July 01 2014 with scores of 1 to 0"
\end{lstlisting}

You can see that unlike the days in the summary, the single-digit dates in the variable you created have only one digit instead of two:

\begin{lstlisting}[language=R]
"1"  "1"  "4"  "4" "5"  "5"  "8"  "9"
\end{lstlisting}


To match the format of the date in the summary, you'd need to add a zero before the existing characters in match\_day.

For this task, we'll introduce the stringr function str\_pad, which lets you specify characters to an existing string to make it a specified length.

For example, let's look at the example string variable match\_date\_2 from earlier in this mission:


\begin{lstlisting}[language=R]
match_date_2
​
"1 January" "20 February" "28 February"
"13 March" "15 April" "3 May"
\end{lstlisting}



If we split match\_date\_2 on the space between the day and month and simplify the output, we get a matrix with a column for day and month:



\begin{lstlisting}[language=R]
match_date_2_split <- str_split(match_date_2, " ", simplify = TRUE)
​
     [,1] [,2]      
[1,] "1"  "January" 
[2,] "20" "February"
[3,] "28" "February"
[4,] "13" "March"   
[5,] "15" "April"   
[6,] "3"  "May"
\end{lstlisting}

<<>>=
match_date_2_split
@


If you wanted all the days in the first column to have two digits, you could use str\_pad() to specify addition of a 0 to the left of every string with a length of less than two:


The function takes as arguments:

The string you're working with

The number of digits you want the string to be

The side you want to add characters to

The character(s) you want to add

To bring the length of all days of the month up to two by adding a zero to the left side of the strings, you would write:

<<>>=
vector_2 <- str_pad(vector_1, 2, side = "left", pad = "0")
@


You can check the length of all strings in a vector by using the function str\_length(). The str\_length() function returns a vector containing the number of characters in each string:

<<>>=
str_length(vector_2)
@


Let's use str\_pad() to change the format of the match\_day variable.

Instructions

Use str\_pad() to bring the length of all days of the match\_day variable you created to two by adding a zero to the left side of the strings.

Add the match\_day variable to the scores data frame. Overwrite the original scores data frame with the one containing match\_day.

Use str\_length() function to check that the length of all strings in the match\_day vector is two characters. Save the resulting vector as match\_day\_length.

<<>>=
match_matrix <- str_split(scores$match_date, " ", simplify = TRUE)

match_matrix

match_day <- match_matrix[,1]

scores <- scores %>%
        mutate(match_day = str_pad(match_day, 2, side = "left", pad = "0"))

scores[1:5]
  
match_day_length <- str_length(scores$match_day)

match_day_lenght
@

%============================================
\subsection{Creating New Variables}
%============================================

Now that you've used string manipulation combine strings and reformat dates, let's see what else you need to do to achieve the goal of generating match summaries.

Here's the scores data frame:

<<>>=
scores[1:5]
@

So far in this mission, you've added the following variables to the scores data frame:

match\_month

lose\_country

match\_day

You're nearly ready to use str\_c() to combine the required variables into a match summary variable:

However, to create summaries that match the required format, you still need to figure out how to specify winning and losing team goals.

Instructions

For this exercise, use the knowledge you have gained so far in this course to do the following:

Create a new variable, win\_goals, containing the winning country's goals for each match.

If the home country is the winning country, win\_goals should be equal to the home country's goals.

Create a new variable, lose\_goals, containing the losing country's goals for each match.

If the home country is the winning country, lose\_goals should be equal to the away country's goals.

Add both variables to the scores data frame, and overwrite the original scores data frame with the one containing your new variables.

<<>>=
win_goals<-if_else(scores$home_country==scores$win_country,scores$home_goals,scores$away_goals)
lose_goals<-if_else(scores$home_country==scores$win_country,scores$away_goals,scores$home_goals)

scores<-scores%>%
mutate(win_goals=win_goals)%>%
mutate(lose_goals=lose_goals)
@

%==============================================
\subsection{Combining Strings to Create Match Summaries}
%===============================================

Now that you've created the win\_goals and lose\_goals variables, you have all the pieces you need to create your match summary variable:


To create the summary variable, you can use the str\_c() function to combine the variables you created with additional strings that will be the same for each match.

When you use str\_c() to combine strings, the recycling rule is followed. For example, if you combine the scores data frame variable match\_id with the string "match number":

\begin{lstlisting}[language=R]
str_c("match number", scores$match_id, sep = " ")
\end{lstlisting}

The output will look like this:

\begin{lstlisting}[language=R]
"match number 1"  "match number 2"  "match number 3"  "match number 4"  "match number 5"
\end{lstlisting}


Let's create the match summaries.

Instructions

Use the str\_c() function to create a vector of summaries for each match in the 2014 World Cup in the format "Argentina beat Switzerland on July 01 2014 with scores of 1 to 0".

Save the vector of summaries as match\_summary.


<<>>=
match_summary<-str_c(scores$win_country," beat ",scores$lose_country, " on ", scores$match_month," ",scores$match_day," 2014 with scores of ",scores$win_goals," to ",scores$lose_goals)
@

%==========================================================
\subsection{Next Steps}
%=========================================================

You've now successfully generated summaries for the matches in the 2014 World Cup:

<<>>=
match_summary
@

In this mission, you learned some common techniques for string manipulation that will come in handy as you prepare data for analysis. You also got some practice using techniques for data frame manipulation and variable creation that you learned earlier in the course.

Now you've completed the first two courses in the R Data Analyst track, you've gained experience working with different data structures, using built-in and custom functions, and working with control structures and their alternatives in R.

In the next course, you'll add a new dimension to your data analysis skills as you learn fundamentals of data visualization in R.

%============================================================
\section{Data Visualization in R}
\subsection{Introduction to Data Visualization}
%===========================================================

In previous courses, you learned the basics of programming in R: Working with different data structures, using built-in and custom functions, and using control structures to execute code based on conditions.

You're now able to perform data analysis tasks including importing data, manipulating it, and calculating summaries.

In this course, you'll gain essential skills to take your data analysis abilities even further. You'll learn to use data visualization to make it easier to identify patterns in your data and plan analyses accordingly. In this mission, you'll:

Explore the principles of data visualization.

Learn to write R code to visualize trends in data in different ways.

Build intuition around when different types of visualizations will help you understand your data.

In previous courses, you learned to use tools in several packages in the tidyverse family. In this course, you'll learn to use one of the most popular tidyverse packages: ggplot2. The ggplot2 package is so popular among R users because of its consistent syntax and the efficiency with which you can use it to create high-quality visualizations.

In this mission, you'll create line graphs to visualize and understand changes in United States life expectancies over time.

The National Center for Health Statistics has been tracking United States mortality trends since 1900. They've compiled data on United States citizen life expectancy by race and sex.

Let's start by importing the data, which is stored as a file named "life\_expec.csv", into R.

Instructions

Use read\_csv() to read the "life\_expec.csv" file into R. Save it as a data frame named life_expec.

<<>>=
life_expec<-read.csv(file="life_expec.csv",head=TRUE,sep=",")

life_expec[1:5,]
@

%===============================================
\subsection{Introducing the Data}
%==============================================

Here are the first ten rows of the life\_expec data frame:

<<>>=
life_expec[1:10,]
@

Each column in the data frame contains a variable pertaining to the population of individuals born each year. Here's an explanation of each variable:

Year: The year of birth.

Race: The races represented in the measured population.

Sex: The sex of the measured population.

Avg\_Life\_Expec: The average life expectancy, in years, at birth of people born in a given year.

Age\_Adj\_Death\_Rate: The age adjusted death rate of people born in a given year. The age adjusted death rate is a metric that adjusts death rate for populations' age distributions to make population comparisons fair.

Since collection of these data began in 1900, we have over 100 years of data that we can use to study changes in average U.S. life expectancy over time.

You may suspect that, as health care has improved, people are living longer than they did earlier in the 20th century. As you scroll through the data frame, you'll see that, indeed, life expectancy has generally increased and death rate has decreased over time.

While scanning a data frame may give you some sense of general patterns, creating a visualization of the data allows for a more detailed analysis, such as envisioning when historical events led to temporarily decreased life expectancy. Exploring data visually is usually one of the first steps data scientists take when working with new data.

%==================================
\subsection{Using Plots to Visualize Patterns in Data}
%=================================

In the R courses you've completed so far, you have seen data represented as text stored in vectors, matrices, lists, and data frames.

In contrast, plots are visual representations that use graphics like dots, lines, and bars to help you look for patterns in data.

Here is an example of a plot representation of data. The table contains five rows of data for two variables, X and Y. The plot has an axis for each variable, and the data points on the plot represent the relationship between the X and Y variables.

There are many types of plots you can use to visualize data, and you'll learn how to work with several of them in this course. Selecting the appropriate plot for your data, and the questions you want to use it to answer, is an important skill that you'll hone over time.

Let's return to our goal of understanding changes in life expectancy over time. Put another way, we are interested in the relationship between life expectancy (the variable Avg\_Life\_Expec) and time (the variable Year).

For this task, we'll use a line chart, which is a type of plot especially useful for visualizing changes over time. A line chart displays information as a series of data points connected by a line:

Line graphs are useful for depicting data that are continuous, meaning the data can have any value. Average life expectancy, as measured in years, is an example of continuous data.

To create line charts and other types of data visualizations in this course, you'll learn to use the ggplot2 package.

Instructions

Load the ggplot2 package. We have already installed it for you.

<<>>=
library(ggplot2)
@
%=====================================================
\subsection{Data Visualization and the Grammar of Graphics}
%=====================================================

The gg in ggplot2 stands for "Grammar of Graphics", which refers to a system for data visualization first described by Leland Wilkinson.

Hadley Wickham, chief data scientist at RStudio, used the principles of the Grammar of Graphics to develop ggplot2 to allow systematic, consistent, time-efficient creation of data visualizations.

In this mission, you'll work to create a line chart. The way you'll use ggplot2 will involve taking a step-by-step, or "layered", approach to creating your graph.

You'll start with data:

line chart

You'll map the data to scales and a coordinate system, which generates axes (you'll learn more about this concept soon):

line chart

You'll specify geometric shapes to represent the data graphically:

line chart

You'll add any necessary annotations, such as axis labels, to your graph:

line chart

Layering the components described above will result in a visual representation of your data:

line chart

Let's dive into creating a line chart to visualize the change in U.S. life expectancy over time. To begin making a plot, use the ggplot() function and specify the data frame you'll be visualizing data from:

\begin{lstlisting}[language=R]
ggplot(data = data_frame)
\end{lstlisting}

This step creates a coordinate system that you can add layers to. While you do not need to assign the data frame to the variable data, we highly recommend doing so as you learn to use ggplot(). This will help you keep track of the different functions you will use to build visualizations. The graphic you'll see at this stage is an empty plot.

Instructions

Use the ggplot() function to create the first layer of your plot using the life\_expec data frame.

In order for our answer checking system to properly assess your answer, please assign the data frame to the variable data as we did in the example: data = data\_frame

<<>>=
ggplot(data=life_expec)
@

%=======================================
\subsection{Mapping Variables to Axes}
%=======================================

At this point, your graph isn't much to look at:

<<echo=FALSE, cache=TRUE>>=
ggplot(data=life_expec)
@

You've created an empty graph for your data that you will now add layers to.

The first layer you'll add is one to map your data points to scales and a coordinate system, which generates axes. To define the variables you want to map to your graph, you'll add a layer using aes(), which is short for "aesthetics", to your graph:

\begin{lstlisting}[language=R]
ggplot(data = data_frame,
  aes(x = variable_1, y = variable_2))
\end{lstlisting}

While you do not need to assign the variables you will be visualizing to x and y within aes(), we highly recommend you do so to avoid confusing them.

When graphing two-dimensional data, as we will do in this course, ggplot2 by default uses the Cartesian coordinate system. This means that your graphs have two axes:

As you saw previously, you can use the two axes to map points to specific locations:

How do you know which axis to use for which variable, though?

The answer to this question is informed by what you think the relationship between two variables is:

The variable that changes depending on the other variable is called the dependent variable. We assign this variable to the vertical axis, or y-axis.

The variable that changes independent of the other variable is called the independent variable, We assign this variable to the horizontal axis, or x-axis.

In the case of our life\_expec data, the Avg\_Life\_Expec changes as time progresses, and so we would consider it to be the dependent variable. The Year variable represents time, and is the independent variable:

Let's add a layer to your graph to map the Avg\_Life\_Expec and Year variables to a coordinate system.

Instructions

Add an aes() layer to your graph specifying Avg\_Life\_Expec as the dependent variable and Year as the independent variable.

You do not need to assign the variables you will be visualizing to x and y within aes(), but we highly recommend you do so to avoid confusing them.

<<>>=
ggplot(data=life_expec,aes(x=Year,y=Avg_Life_Expec))
@

%=========================================
\subsection{Adding Geometric Objects to Visualize Data Points}
%========================================

Now, your chart has a coordinate system and axes:

<<echo=FALSE, cache=TRUE>>=
ggplot(data=life_expec,aes(x=Year,y=Avg_Life_Expec))
@

With this foundation in place, the next step is to add geometric symbols to the graph to represent data points.

To add a line representing the relationship between the Year and Avg\_Life\_Expec variables to your graph, you'll add a geom\_line() layer to your graph:

\begin{lstlisting}[language=R]
ggplot(data = data_frame,
  aes(x = variable_1, y = variable_2)) +
  geom_line()
\end{lstlisting}

Notice how we add each new layer to the graph using a + at the end of the preceding line of code. This syntax is consistent for any type of visualization you'll create using ggplot2.

Using ggplot2, you can add geometric objects of different types to a graph depending on what type of data you're working with and the relationships between variables you're looking to explore. We'll learn how to use several more of them for data visualization later in the course.

Let's add a layer to your graph to allow you to visualize the data.

Instructions

Add a layer to your graph to illustrate the relationship between Year and Avg\_Life\_Expec.

<<>>=
ggplot(data=life_expec,aes(x = Year,y = Avg_Life_Expec))+
       geom_line()
@
%===========================================
\subsection{Selecting Data for Visualization}
%===========================================

You have now produced a graph with the relationship between Year and Avg\_Life\_Expec represented by a line:

<<echo=FALSE, cache=TRUE>>=
ggplot(data=life_expec,aes(x = Year,y = Avg_Life_Expec))+
       geom_line()
@

However, the graph you've created appears to have multiple data points for Avg\_Life\_Expec for each instance of Year. Let's take a look at a single year from the life\_expec data frame to see what's going on:

\begin{lstlisting}[language=R]
life_expec %>%
  filter(Year == 2000)
\end{lstlisting}

For the year 2000, there are nine data points:

<<echo=FALSE, cache=TRUE>>=
life_expec %>%
  filter(Year == 2000)
@

This is because, for each year, average life expectancies for multiple populations (by sex and race) are included in the data set.

To get a sense for the change over time of life expectancy for the entire U.S. population, let's use data for all races and both sexes to create the line graph.

From previous courses, you have experience using the dplyr function filter() to select a subset of a data set based on values of one or more variables.

Let's create a new line graph containing only average life expectancy data for the entire U.S. population.

Instructions

Create a new data frame, life\_expec\_filter, containing only rows for which the Race variable has the value "All Races" and the Sex variable has the value "Both Sexes".

We have loaded the dplyr package already.

Create a line graph that displays the relationship between Avg\_Life\_Expec and Year.

<<>>=
life_expec_filter<-life_expec%>%
filter(Race=="All Races" & Sex=="Both Sexes")

life_expec_filter[1:5,]

ggplot(data=life_expec,aes(x=Year,y=Avg_Life_Expec))+
        geom_line()
@

%===============================
\subsection{Adding Graph Titles and Changing Axis Labels}
%===============================

Here's the line graph you've created:

<<echo=FALSE, cache=TRUE>>=

ggplot(data = life_expec_filter,
  aes(x = Year, y = Avg_Life_Expec)) +
  geom_line()
@

This visualization of the relationship between Avg\_Life\_Expec and Year allows for the quick detection of some interesting patterns:

Generally, average life expectancy of the U.S. population has been increasing over time.

Before the 1950s, life expectancy fluctuated substantially from year to year.

In the 1920s, life expectancy dropped dramatically, and then increased once again.

Do you have any knowledge of world and U.S. history that may explain some of these patterns? We'll give that more thought as we progress through the mission.

Now that you have an interesting line graph illustrating relationships between your variables of interest, it's likely you'll want to share it. When creating data visualizations, it's good practice to make sure that the visual can "stand alone". That is, if someone were to find your graph, they should be able to clearly understand what the visualization represents.

One way to ensure that your graph is easy to understand is by adding a title to it. You can do so by adding another layer to your graph using the argument labs(), short for "labels":

\begin{lstlisting}[language=R]
ggplot(data = data_frame, aes(x = variable_1, y = variable_2)) +
  geom_line() +
  labs(title = "Title of Graph")
\end{lstlisting}

Using labs(), you can specify the graph title with the syntax title =.

A good graph title should provide those looking at your graph with information about the data to help them fully understand the visual. For the line graph you're working on, an example of an informative title would be, "United States Life Expectancy: 100 Years of Change." This title communicates to your readers what the goal of the visualization is: To understand U.S. life expectancy over time.

It's also important to make sure that someone who looks at your graph can understand the data that are being represented. In the case of the graph you've been working on, it may be unclear what that y-axis label, Avg\_Life\_Expec, refers to.

To change axis labels, you can also use the labs() argument. To specify new labels for the x- or y-axis, use the syntax x = or y = within labs().

\begin{lstlisting}[language=R]
ggplot(data = data_frame, aes(x = variable_1, y = variable_2)) +
  geom_line() +
   labs(title = "Title of Graph", x = "new x label", y = "new y label")
\end{lstlisting}
   
When you assign axis labels, it's good practice to be very descriptive. In the case of the y-axis label on the line graph you're working on, an example of a descriptive axis label is, "Average Life Expectancy (years)". 

Notice that the label includes the units, "years", in which the data are expressed. Including units in your axis labels is important for clearly communicating the type of data you used to create the graph.

Let's add a descriptive title and axis labels to your line graph.

Instructions

Give your graph the descriptive title that communicates the goal of the visualization: "United States Life Expectancy: 100 Years of Change"
Give the y-axis this label: "Average Life Expectancy (Years)"

<<>>=
ggplot(data=life_expec,aes(x=Year,y=Avg_Life_Expec))+
geom_line()+
labs(title="United States Life Expectancy: 100 Years of Change",x="Year",y="Average Life Expectancy (Years)")
@

%====================================
\subsection{Refining Graph Aesthetics}
%=======================================

Your line graph is now clear and descriptive — you can study it to understand patterns in U.S. life expectancy data.

<<echo=FALSE, cache=TRUE>>=
ggplot(data = life_expec_filter,  aes(x = Year, y = Avg_Life_Expec)) +
  geom_line() +
  labs(title = "United States Life Expectancy: 100 Years of Change", y = "Average Life Expectancy (Years)")
@

Before we conclude this mission, you'll learn to make a few more changes to your line graph to improve its aesthetics.

The line graph's gray background and white grid lines are unnecessary for understanding the data and are a bit distracting. Let's simplify the graph background to help the line representation of the data stand out.

To modify non-data ggplot2 graph components, including background color, you can add a layer to your graph using theme().

Within the theme() layer, you'll use the argument panel.background = element\_rect("background\_color") to specify the color of the background rectangle (which is what "rect" stands for).

\begin{lstlisting}[language=R]
ggplot(data = data_frame, aes(x = variable_1, y = variable_2)) +
  geom_line() +
  labs(title = "Title of Graph", x = "new x label", y = "new y label") + 
  theme(panel.background = element_rect(fill = "background_color"))
\end{lstlisting}

Let's change the background of your line graph to make it less distracting.

Instructions

Change the background color of your line graph to white.

<<>>=
ggplot(data=life_expec_filter,aes(x=Year,y=Avg_Life_Expec))+
geom_line()+
labs(title = "United States Life Expectancy: 100 Years of Change", y = "Average Life Expectancy (Years)")+
theme(panel.background=element_rect(fill="gray"))#pode usar white, green, black...
@

%===================================================
\subsection{Using Your Line Graph to Understand the Data}
%===================================================

You've now created a clear, informative visualization of the life\_expec data:

<<echo=FALSE, cache=TRUE>>=
ggplot(data=life_expec_filter,aes(x=Year,y=Avg_Life_Expec))+
geom_line()+
labs(title = "United States Life Expectancy: 100 Years of Change", y = "Average Life Expectancy (Years)")+
theme(panel.background=element_rect(fill="white"))
@

Your line graph makes it easy to identify interesting features of the data that would have been harder to envision when looking at a table of data. Let's take a look at some of them.

First, we can see that, generally, the average U.S. life expectancy has increased over time.

However, notice the sharp drop in life expectancy around the year 1920, from about 55 to under 40 years. What could have cause this? A bit of research reveals that, in 1918, there was a deadly influenza epidemic that affected the U.S. population. This could explain the rapid decrease in average life expectancy.

It's also interesting to observe that average life expectancy fluctuated between 1900 and 1950 before becoming more stable from year to year after about 1950. Do you have any ideas about possible causes?

In this mission, you've taken raw data in a .csv file, imported it into R, manipulated it to select a relevant subset, and created a line graph to visualize patterns in the data. You're well on your way to mastering R for data analysis.

%======================================
\section{Creating Multiple Line Graphs}
\subsection{Visualizing Data for Multiple Populations}
%======================================


In the previous mission, you created a line graph to visualize changes over time in average U.S. life expectancy since 1900:

<<echo=FALSE, cache=TRUE>>=
ggplot(data=life_expec_filter,aes(x=Year,y=Avg_Life_Expec))+
geom_line()+
labs(title = "United States Life Expectancy: 100 Years of Change", y = "Average Life Expectancy (Years)")+
theme(panel.background=element_rect(fill="white"))
@
The data you used to create this graph is averaged across populations: American men and women of different races.

Now that you have a sense for general U.S. life expectancy trends, let's dig deeper into the data. You can ask more nuanced questions, such as whether there are differences in life expectancy between men and women or for Americans of different races.

In this mission, you'll learn to create line graphs to visualize differences in how the life expectancies of different American populations have changed over the past 100 years.

Let's start by importing the data into R. We have loaded the readr package for you.

Instructions

Import the "life\_expec.csv" file into R. Save it as a data frame named life\_expec.

<<>>=
#Ja esta carregado no overleaf
@

%=====================================================
\subsection{Manipulating the Data for Visualization}
%====================================================

Due to a combination of biological and social factors, the life expectancy for men is often somewhat lower than it is for women. Let's use the life\_expec data to explore how life expectancies for men and women have changed over the past 100 years in the United States.

In the previous mission, when you investigated life expectancies averaged across Americans of different sexes and races, you used filter() to create a new data frame containing only rows for which:

Values of the Race variable were "All Races"

Values of the Sex variable were "Both Sexes"

Remember from the previous mission that, for each year, the life\_expec data frame contains data for different U.S. populations: Americans of different races and sexes.

As we explore differences in life expectancy by sex, you will need to select a subset of the life\_expec data that contains observations for the populations of U.S. men and women.

You'll need to filter life\_expec to retain rows for which values of the Sex variable are either Female or Male and, since we are not yet investigating life expectancies for different races, values of Race are All Races.

Let's create a new data frame containing only the data you'll use to visualize changes in U.S. men's and women's life expectancies over time.

Instructions

Create a new data frame, life\_expec\_sex, containing only rows for which the Sex variable has the value "Female" or "Male" and the Race variable has the value "All Races."

We have loaded the dplyr package for you already.

<<>>=
life_expec_sex <- life_expec %>%
  filter(Race == "All Races" & Sex != "Both Sexes")

life_expec_sex[1:5,]
@

%===================================================
\subsection{Graphing Life Expectancies for Men and Women: Multiple Panels}
%==================================================

The new life\_expec\_sex data frame you created contains life expectancy data for men and women.

One way to compare the changes over time for the life expectancies of the two populations is to create a separate line graph for each.

If you create a line graph of the data using code similar to what you wrote in the previous mission:

\begin{lstlisting}[language=R]
ggplot(data = life_expec_sex,
  aes(x = Year, y = Avg_Life_Expec)) +
  geom_line()
\end{lstlisting}

The graph generated has two observations for each year: One for men and one for women. All observations are connected by a line, making the line graph appear to depict year-to-year fluxtuations in life expectancy instead of data for two separate populations:

<<echo=FALSE, cache=TRUE>>=
ggplot(data = life_expec_sex,
  aes(x = Year, y = Avg_Life_Expec)) +
  geom_line()
@

One way to improve the clarity of this line graph is to plot life expectancy data for men and women on different axes using multiple graph panels. The two panels would look like this:


[gráfico]

You can create line graphs on multiple, adjacent panels from the same data set by adding a new layer to your graph: facet\_wrap().

The facet\_wrap() function splits data into subplots based on values of a variable in your data set.

For example, the life\_expec\_sex data frame contains two values, "Male" and "Female", for the variable Sex:

If you add a layer to your graph to create multiple panels using facet\_wrap(), the resulting graph will have two panels:

The syntax for adding a facet\_wrap() layer to your graph looks like this:

\begin{lstlisting}[language=R]
ggplot(data = life_expec_sex,
  aes(x = Year, y = Avg_Life_Expec)) +
  geom_line() +
  facet_wrap(~Sex)
\end{lstlisting}

<<>>=
ggplot(data = life_expec_sex,
  aes(x = Year, y = Avg_Life_Expec)) +
  geom_line() +
  facet_wrap(~Sex)
@
  
By default, adding a layer to your graph using facet\_wrap(~Variable) creates two panels side by side, as shown in the graph above. However, you can specify alternative arrangements of the panels using the arguments ncol = or nrow = within facet\_wrap().

The ncol and nrow arguments allow you to specify the number of rows or columns of panels in your visualization. If you wrote the following code:

\begin{lstlisting}[language=R]
ggplot(data = life_expec_sex,
  aes(x = Year, y = Avg_Life_Expec)) +
  geom_line() +
  facet_wrap(~Sex, ncol = 2)
\end{lstlisting}

<<>>=
ggplot(data = life_expec_sex,
  aes(x = Year, y = Avg_Life_Expec)) +
  geom_line() +
  facet_wrap(~Sex, ncol = 2)
@

The resulting graph would be identical to the one above, since the panels will be arranged in two columns.

However, you could create a graph with panels stacked one on top of the other by specifying either ncol = 1 or nrow = 2.

Let's visualize U.S. women's and men's life expectancies on separate panels so you can compare how they have changed over time.

Instructions

Use the life\_expec\_sex data frame to create line graphs of men's and women's life expectancies over time.

Add a facet\_wrap() layer to graph men's and women's life expectancies on separate graph panels. Create a graph with panels stacked vertically, one on top of the other.

In order for our answer checking system to properly assess your answer, please use the following syntax:

Assign the data frame to the variable data (data = data\_frame)

Assign the variables you will be visualizing to x and y within aes() (x = variable\_1, y = variable\_2)

Specify the number of columns in the facet\_wrap() call with ncol (do not specify nrow).

<<>>=
ggplot(data=life_expec,aes(x=Year,y=Avg_Life_Expec))+
geom_line()+
facet_wrap(~Sex,ncol=1)
@

%===================================
\subsection{Graphing Life Expectancies for Men and Women on the Same Axes}
%==================================

Let's take a look at the graph you created:

<<echo=FALSE,cache=TRUE>>=
ggplot(data=life_expec,aes(x=Year,y=Avg_Life_Expec))+
geom_line()+
facet_wrap(~Sex,ncol=1)
@

From this visualization, it's clear that women's and men's life expectancies have followed some similar patterns over the past century. For example, both display a sharp dip around the time of the 1918 flu pandemic.

Comparing the life expectancy changes over time depicted in the two panels of this graph is easier than looking at a table of data, but it's still difficult to understand whether there are differences in men's and women's life expectancies.

This visualization can be improved by plotting men's and women's life expectancy over time on the same axis instead of on two separate ones.

Instead of adding a layer to the graph to create two separate panels, you can specify that you want to plot multiple lines within the aes() layer, where you mapped the data to the axes.

Although up until now we have only introduced the axis arguments that can be used to define x and y variables on a two-dimensionl graph, the aes() layer can also be used to map additional variables to your graph using aesthetic properties like color, shape, and size.

For example, you can plot men's and women's life expectancies on the same set of axes and differentiate them by using different styles of lines:

To create a line graph with different values of the Sex variable shown using different styles of lines, you'd use the syntax lty = Sex. The argument lty stands for "line type":

<<>>=
ggplot(data = life_expec_sex) +
  aes(x = Year, y = Avg_Life_Expec, lty = Sex) +
  geom_line()
@

\newpage
In addition to line type, you can also differentiate lines for different values of a variable using color by using the argument color =.

In the graph above, notice there is a box containing information about which line type matches which values of the Sex variable. This is referred to as a legend. Chart legends contain a list of variables that appear in a graph and an example of their appearance. Legends are important to include so the person looking at your graph understands it. Graphs you create using ggplot2 include a legend by default.

Let's create a line graph to visualize changes in men's and women's life expectancies on the same axis.

Instructions

Create a line graph with the change in men's and women's life expectancies over time represented by lines of different colors. For now, use the default ggplot2 colors.

<<>>=
ggplot(data=life_expec_sex,aes(x=Year,y=Avg_Life_Expec,color=Sex))+
       geom_line()
@

%=======================
\subsection{Graphing a Subset of Data}
%======================
As you look at the new graph you created, you can see the differences in changes in men's and women's life expectancies over time more clearly than you could when you plotted them on different panels:

<<echo=FALSE,cache=TRUE>>=
ggplot(data=life_expec_sex,aes(x=Year,y=Avg_Life_Expec,color=Sex))+
       geom_line()
@

Although life expectancies for U.S. men and women followed similar patterns over the past 100 years, in general, women have tended to live longer.

Relatively recently, since about 1950, life expectancies for men and women have steadily and gradually increased.

Before 1950, though, life expectancies appear to have fluctuated quite a bit from year to year. Why might this be?

When you want to hone in on an interesting subset of your data for further investigation, one way to do so is to set scale limits. Changing the scale limits changes the range of your axes so you can display only a portion of your data.

For example, let's say you wanted to create a graph displaying only the 1918 dip in life expectancy due to influenza.


We could do so by changing the scale limits to produce this graph:

In graph above, the x-axis years range from 1915 to 1920, and the y-axis life expectancies range from 35 to 60 years old. We have zoomed in on this portion of the graph by writing the following code to change the scale limits:

<<>>=
ggplot(data = life_expec_sex, 
  aes(x = Year, y = Avg_Life_Expec, color = Sex)) +
  geom_line() +
  xlim(1915, 1920) +
  ylim(35, 60)
@


By default, when you use ggplot() to create a graph, all observations will be included. Adding xlim() and ylim() layers to the graph allows you to specify ranges to display only a subset of the data.

Looking at the graph of life expectancies for the years 1915 to 1920 allows you to clearly visualize the devastating effect that the flu pandemic had on life expectancies.

Earlier, we discussed the interesting differences in life expectancy fluctuations before and after 1950. Let's create a graph focused on life expectancy data from before 1950.

Instructions

Add a new layer to the line graph of men's and women's life expectancies to hone in on the years between 1900 and 1950.


<<>>=
ggplot(data=life_expec_sex,aes(x=Year,y=Avg_Life_Expec,color=Sex))+
geom_line()+
xlim(1900,1950)
@


%===================================
\subsection{Exploring the Data Further}
%====================================

By adding a layer to change the scale limits of your graph, you've created a line graph to visualize changes in men's and women's life expectances from 1900 to 1950:

<<echo=FALSE,cache=TRUE>>=
ggplot(data=life_expec_sex,aes(x=Year,y=Avg_Life_Expec,color=Sex))+
geom_line()+
xlim(1900,1950)
@

This visualization can allow you to take a closer look at the year-to-year variability in life expectancy during the first half of the twentieth century.

What do you think could be some potential causes? Perhaps a greater impact of infectious diseases prior to medical advances such as vaccines for polio, measles, and influenza? This could be an interesting topic to study, and demonstrates some of the types of questions that arise when you visualize data graphically instead of looking at it in tabular form.

Let's see what other interesting questions visualizing these data can raise.

Earlier in this mission, you selected data to create line graphs to help understand life expectancy differences between men and women. To focus on that question, you selected data that were averaged across populations of Americans of different races.

We have now investigated differences in life expectancy between men and women, and we can taken an even more granular view of the available data by looking at differences between life expectancies of black and white Americans.

To do this, you will need to use a different subset of data from the life\_expec data frame:

Values of Sex that are either "Male" or "Female"

Values of Race that are either "Black" or "White"

Put another way, you will want to exclude averaged data:

Values of Sex that are "Both Sexes"

Values of Race that are "All Races"

Let's filter the life\_expec data frame to retain only values of the Sex and Race variables that you'll include in your visualization of U.S. life expectancy by race and sex.

Instructions

Create a new data frame, life\_expec\_sex\_race, that contains values of Sex that are either "Male" or "Female" and values of Race that are either "Black" or "White."

<<>>=
life_expec_sex_race <- life_expec %>%
  filter((Sex == "Female" | Sex == "Male") & (Race == "Black" | Race == "White"))
 
life_expec_sex_race[1:5,]
@
%===================================
\subsection{Manipulating Multiple Line Graph Aesthetics}
%===================================

The life\_expec\_sex\_race data frame contains data on life expectancies of U.S. men and women of different races:

<<echo=FALSE,cache=TRUE>>=
life_expec_sex_race[1:5,]
@

Notice there are four observations for each year: Black women, black men, white women, and white men. This means you have four lines to plot.

What is the best way to present line graphs of these data?

One method is to plot four lines on a single set of axes.

To create a line graph with a line for each combination of Sex and Race variable values, you can specify multiple aesthetic parameters within the aes() layer.

For example, to create a graph in which lines representing life expectancies are

Different colors for populations of different sexes

Different line styles for populations of different races

You would write:

<<>>=
ggplot(data = life_expec_sex_race, 
  aes(x = Year, y = Avg_Life_Expec, color = Sex, lty = Race)) +
  geom_line()
@

The resulting graph has four lines that represent:

Black women

Black men

White women

White men


The graph legend provides information on the type of line that represents the two values for the Race and Sex variables.

So far, you have used the default colors and line types when working in the aes() layer. However, ggplot2 allows you to customize these arguments extensively:

This guide contains R colors labeled with names you can use to reference them.

Here is a guide to line types in R.

As you've now seen is often the case with creating graphs with ggplot2, modifying line colors and types involves adding another layer to your graph. To change the two colors you used in the graph above to represent men and women, you'd add a layer called scale_color_manual().

Let's change the colors representing men's and women's life expectancies to "magenta" and "orange":

<<>>=
ggplot(data = life_expec_sex_race, 
  aes(x = Year, y = Avg_Life_Expec, color = Sex, lty = Race)) +
  geom_line() +
  scale_color_manual(values = c("magenta", "orange"))
@

The resulting graph represents women's life expectancies with magenta lines and men's life expectancies with orange lines.

To change the line types representing black and white Americans' life expectancies, you'll need to add another layer: scale_linetype_manual(). To change the line types in the graph to "longdash" and "dotdash", you would write:

<<>>=
ggplot(data = life_expec_sex_race, 
  aes(x = Year, y = Avg_Life_Expec, color = Sex, lty = Race)) +
  geom_line() +
  scale_color_manual(values = c("magenta", "orange")) +
  scale_linetype_manual(values = c("longdash", "dotdash"))
@

The resulting graph represents black and white Americans' life expectancies with lines of different dash patterns.

When creating line graphs, it's important that the graph allows the viewer to clearly see what you, its creator, are trying to convey. In the graph example where values of the Race variable are both represented by dashed lines, it's difficult to see differences between the populations. It would have been better in this case to use line types that are more distinct.

As you gain practice creating line graphs and other types of data visualizations, you will become skilled at using aesthetics that represent your data clearly. You'll learn more about the art of storytelling with data in an upcoming course.

For now, let's practice using different line type and color combinations to visualize life expectancy data.

Instructions

Using the life\_expec\_sex\_race data frame, create a line graph to investigate differences in how life expectancies of the following populations of Americans changed between 1900 and 2014:

Black women

Black men

White women

White men

Differentiate between the two sexes using the following colors:

values=c("darkgreen", "darkorchid"))

Differentiate between the two races using the following line types:

values = c(1,4))

<<>>=
ggplot(data=life_expec_sex_race,aes(x=Year,y=Avg_Life_Expec,color=Sex,lty=Race))+
geom_line()+
scale_color_manual(values = c("darkgreen", "darkorchid")) +
scale_linetype_manual(values = c(1,4))
@

%====================================
\subsection{Deciding How to Present the Data}
%====================================

Now that you've practiced creating an aesthetically clear line graph, let's take a look at it and see what we can learn about the life expectancies of different U.S. populations:

<<echo=FALSE,cache=TRUE>>=
ggplot(data=life_expec_sex_race,aes(x=Year,y=Avg_Life_Expec,color=Sex,lty=Race))+
geom_line()+
scale_color_manual(values = c("darkgreen", "darkorchid")) +
scale_linetype_manual(values = c(1,4))
@

As we noted earlier in this mission, life expectancies for men tend to be lower than those for women.

Breaking the data down further into populations of black and white Americans reveals that, within each population, the pattern of women living longer than men holds true.

However, it's clear from the graph that in general, white women live longer than black women, and white men live longer than black men. This pattern is likely due to socioeconomic inequality in the U.S., which negatively impacts the lives of black Americans.

It is also interesting to note that while life expectancies for white women and men have generally not fluctuated much since about 1950, life expectancies for black women and men continue to fluctuate from year to year.

We can learn a lot by looking at the graph you created. However, it can make some parts of the graph, such as the 1918 life expectancy dip, difficult to see clearly.

Let's try another way to present this data that involves using both the facet\_wrap() and aes() layers.

You can create a graph with separate panels for the Race variable and two lines, one for each value of the Sex variable, per panel:

The code you would write to create this graph is:

<<>>=
ggplot(data = life_expec_sex_race, 
  aes(x = Year, y = Avg_Life_Expec, color = Sex)) +
  geom_line() + 
  facet_wrap(~Race, ncol = 1)
@

You can also choose to create a graph with separate panels for values of the Sex variable and two lines, one for each value of the Race variable, per panel.

The way you choose to graph your data ultimately depends on the questions you are trying to answer, and often requires some trial and error.

In the case of this data set, if you were most interested in the question of how men's and women's life expectancy changes compare, you may choose to create plot panels for the Race variable and graph men's and women's life expectancies on the same axes to allow for more nuanced comparisons.

If you were more interested in the question of how black and white Americans' life expectancy changes compare, you may create a graph with the opposite configuration.

Most commonly, you will try both approaches, and select the graph that best allows you to visualize trends in your data. The consistent, systematic syntax of ggplot2 will allow you to create multiple graphs as part of your workflow without taking up too much of your time.

As we conclude this mission, let's create a graph that incorporates the skills you've learned so far in this course.

Instructions

Create a line graph to visualize changes in the life expectancies of the following U.S. populations between 1900 and 2014:

Black women

Black men

White women

White men

Use the following line types:

values = c(1,4))

Design your graph so that it has a white background.

Give your graph the title: "United States Life Expectancy: 100 Years of Change"

Give the y-axis the title: "Average Life Expectancy (Years)"

<<>>=
ggplot(data = life_expec_sex_race, 
  aes(x = Year, y = Avg_Life_Expec, lty = Race)) +
  geom_line() + 
  scale_linetype_manual(values = c(1,4)) +
  facet_wrap(~Sex, ncol = 2) + 
  labs(title = "United States Life Expectancy: 100 Years of Change", y = "Average Life Expectancy (Years)") +
  theme(panel.background = element_rect(fill = "white"))
@

%==============================
\subsection{Next Steps}
%==============================

In this mission, you've learned methods for creating multiple line graphs to visualize data in different ways. You've also begun learning about techniques to maximize the clarity of your visuals and how these techniques will vary depending on the questions you're asking about your data.

<<echo=FALSE,cache=TRUE>>=
ggplot(data = life_expec_sex_race, 
  aes(x = Year, y = Avg_Life_Expec, lty = Race)) +
  geom_line() + 
  scale_linetype_manual(values = c(1,4)) +
  facet_wrap(~Sex, ncol = 2) + 
  labs(title = "United States Life Expectancy: 100 Years of Change", y = "Average Life Expectancy (Years)") +
  theme(panel.background = element_rect(fill = "white"))
@

In the next mission, you'll learn to visualize and explore data using new types of visualizations that will allow you to understand data distributions and differences between groups: Histograms, bar charts, and box plots.

%===============================
\section{Bar Charts, Histograms, and Box Plots}
\subsection{Visualizing Distributions to Investigate Movie Review Bias}


When Hollywood releases new movies, Metacritic, Fandango, Rotten Tomatoes, and IMDB use different systems to calculate ratings based on the reviews by movie critics and consumers.

Which of these sites should you consult when deciding whether to see a movie? Understanding how the different sites' movie reviews compare to one another is a good start.

Fandango has been suspected of releasing inflated ratings to increase ticket sales. After they found that some films that garnered poor ratings elsewhere were rated highly on Fandango, analysts from FiveThirtyEight investigated and published an article about bias in movie ratings.

To conduct the investigation, the team compiled data for 147 films from 2015 with reviews from movie critics and consumers.

In this mission, you'll use this data and ggplot2 to visualize reviews from Metacritic, Fandango, Rotten Tomatoes, and IMDB to get a sense for differences in the way the four sites compute movie ratings.

We have made a subset of the data available for you to work with in this mission in a file named "movie\_reviews.csv". The file contains three columns:

Film: Movie name and release year

Rating\_Site: The site that calculated the rating (Rotten\_Tomatoes, Metacritic, IMDB, or Fandango).

Rating: The assigned movie rating
Let's start by importing the data into R.

Instructions

We have loaded the readr package for you. Import the "movie\_reviews.csv" file into R and save it as a data frame named reviews.

<<>>=
reviews<-read.csv(file="movie_reviews.csv",head=TRUE,sep=",")

str(reviews)

reviews[1:5,]
@

%=======================================
\subsection{Comparing Averages Among Rating Sites}
%=======================================

The reviews data frame contains four ratings, one from each movie rating site, for each film:

<<echo=FALSE,cache=TRUE>>=
reviews[1:5,]
@

Let's start by getting a sense for how reviews reported by the four sites compare.

You can approach this problem by calculating the average ratings for each rating site. To do this, you could group the reviews data frame into one group for each value of Rating\_Site and calculate the average of Rating for each group.

Recall from the R Intermediate course that such problems, where you perform summary calculations on grouped data, are known as "split-apply-combine" problems.

Once you've calculated average ratings for each site, we'll introduce you to a new type of graph for visualizing comparisons among groups, or categories, of data.

Let's calculate average ratings for each movie rating site.

Instructions

Use group\_by() to group the reviews data frame by Rating\_Site.

Use summarize() to calculate the average Rating for each Rating\_Site. Save the summary data frame as review\_avgs.

We have already loaded the dplyr package for you.

<<>>=
review_avgs<-reviews %>%
group_by(Rating_Site)%>%
summarize(avg=mean(Rating))

@

%===============
\subsection{Visualizing Differences Among Groups Using Bar Charts}
%===================

You've now created a new summary data frame, review\_avgs, with an average rating for each movie rating site:

<<echo=FALSE,cache=TRUE>>=
review_avgs[1:5,]
@

In the last two missions, when we were interested in understanding how life expectancy changed over time, you learned to create line graphs. Line graphs are useful for depicting changes in a dependent variable (life expectancy) over time (the independent variable).

In this mission, instead of changes over time, we are interested in the differences between four groups: The movie review sites. You'll learn to use different types of visualizations to understand the facets of the data you're interested in.

The first type of data visualization you'll learn about in this mission is a bar chart. Bar charts represent grouped data summeries using bars with heights proportional to values of a summary variable such as the average:

Like line graphs, bar charts depict the relationship between two variables. In the example bar chart above, groups are indicated on the x-axis since they are the independent variable. The average for each group, the dependent variable, is on the y-axis.

To create a bar chart to visualize the average ratings for each movie rating site, you would use the review\_avgs data frame you created when you grouped and summarized the reviews data frame.

The syntax for the data and aesthetics layers you'll specify when creating a bar chart with ggplot2 is the same as the syntax you learned when creating line graphs. You'll specify the review\_avgs data frame as the data layer, and the rating\_site and avg variables as x and y, respectively.

<<>>=
ggplot(data = review_avgs, aes(x = Rating_Site, y = avg))+
geom_bar(stat="identity")
@

The layer that distinguishes a bar chart from a line graph is the layer in which you'll specify the geometric shape used to display the data. While before you used geom\_line(), now you'll use geom_bar():

\begin{lstlisting}[language=R]
geom_bar(stat = "identity")
\end{lstlisting}


In the code above, we specify stat = "identity" within the geom\_bar() layer. This is because, by default, using geom\_bar() creates a bar graph where the height of the bars corresponds to the number of values in the specified y-variable. Using stat = "identity" overrides the default behavior and creates bars equal to the value of the y-variable, the average.

Let's practice creating a bar chart to display the differences in average movie ratings among review sites.

Instructions

Use the ggplot function from the ggplot2 package to create a bar chart depicting the average movie ratings for Rotten Tomatoes, IMDB, Metacritic, and Fandango. We have loaded the ggplot2 package for you.

Use the review\_avgs data frame that contains your calculated average ratings for each site.


<<>>=
ggplot(data=review_avgs,aes(x=Rating_Site,y=avg))+
geom_bar(stat="identity")
@

%========================
\subsection{Using Histograms to Understand Distributions}
%=======================

Let's take a look at the bar chart you created:


<<fig.pos="h", fig.height=3.7, fig.width=3.7, fig.cap="", echo=FALSE,cache=TRUE>>=
ggplot(data=review_avgs,aes(x=Rating_Site,y=avg))+
geom_bar(stat="identity")
@

As you look at the chart, you can clearly see that Fandango has a higher average movie rating than the other three sites. Does this mean Fandango tends to give higher ratings?

As you consider that question, let's think about what the bar chart does not show us. It makes sense to wonder if Fandango's average movie rating is higher than those of the other sites because it tends to give all movies good ratings, or because it gave some movies average ratings and a small number of movies excellent ratings.

However, the bar graph does not provide this information.

The average of a set of numbers does not tell us anyting about the spread of the numbers that were used to calculate the average. For example, the values of these two variables both have an average of 5:

Variable 1: 5 5 5 5 5 4 5 5 6 5

Variable 2: 20 9 1 2 8 4 9 5 7

However, while values of Variable 1 are distributed between 4 and 6, values of Variable 2 are distributed between 1 and 20. The values of Variable 2 are much more spread out than those of Variable 1.

We'll spend the rest of this mission taking a more nuanced look at the movie rating data by learning about ways to visualize how values of variables are distributed, or spread.

One such type of visual is a histogram. Unlike bar charts and line graphs, histograms are used to understand characteristics of one variable rather than the relationship between two variables.

Histograms depict the frequency with which values of a variable occur, otherwise known as the distribution of the variable. For example, here is a histogram showing the distribution of all values of the Rating variable of the reviews data frame:

On the x-axis is the Rating variable. This histogram has aggregated, or "binned", values of the Rating variable into five categories:

0.5-1.5

1.5-2.5

2.5-3.5

3.5-4.5

4.5-5.5

On the y-axis is a variable that is calculated automatically when you create the histogram: count. The count variable represents the number of values of the Rating variable that fall into each of the five categories on the x-axis.

This histogram tells us that many values of the Rating variable fall into the 2.5-3.5 and 3.5-4.5 categories. Very few fall into the 0.5-1.5 and 4.5-5.5 categories.

To visualize data using a histogram, the syntax for the data and aesthetics layers are similar to what you have used to generate line graphs and bar charts:

<<fig.pos="h", fig.height=3.7, fig.width=3.7, fig.cap="">>=
ggplot(data = reviews, 
  aes(x = Rating)) +
  geom_histogram(binwidth = 1)
@

Within the aes() layer, you only need to specify the independent variable. Remember when you create a histogram, the dependent variable count is calculated for you.

The geom\_histogram() layer specifies creation of a histogram to represent the independent variable. The argument binwidth = 1 specifies the size of the categories used to bin the values of the independent variable.

Within the geom\_histogram() layer, you can use two different arguments to specify the number of categories for binning the independent variable.

binwidth = allows you to specify the size of the bins, and is useful for instances, such as this example, where you want categories to span specific intervals.

bins = allows you to specify the number of bins, which can be useful to experiment with when deciding how much detail you want to use to display your data.

If you don't use any arguments within the geom\_histogram() layer, ggplot2 will use a default number of bins.

Let's experiment with different numbers of bins to display the Rating variable.

Instructions

Create a histogram to show the distribution of all values of the Rating variable in the reviews data frame.

Specify 30 bins to categorize values of the independent variable.

<<fig.pos="h", fig.height=3.7, fig.width=3.7, fig.cap="">>=
ggplot(data=reviews,aes(x=Rating))+
geom_histogram(bins=30)
@

%================================
\subsection{Comparing Distributions of Multiple Variables: Faceted Plots}
%================================


From the histogram you created, you can see that increasing the number of bins produces a visualization of the data with greater detail:

<<echo=FALSE,cache=TRUE, fig.pos="h", fig.height=3.7, fig.width=3.7, fig.cap="">>=
ggplot(data=reviews,aes(x=Rating))+
geom_histogram(bins=30)
@

Histograms allow you to visualize the shape of a distribution — where values of the data are clustered. Most values of Rating are clustered between 3.5 and 4.5.

This histogram tells us about the distribution of all values of the Rating variable, but what we really want to investigate is how ratings for different rating sites differ.

One way to compare Rating distributions for the four sites is to create a faceted plot, as you learned to do for line graphs.

Recall that to create a faceted plot for categories of a variable, you can add a layer to your graph using facet\_wrap():

<<>>=
facet_wrap(~Rating_Site)
@

Let's visualize differences in the distributions of ratings for each movie rating site.

Instructions

Add a layer to the histogram you created on the last screen to create a faceted graph containing four histograms of the distribution of Rating for each site:

Rotten Tomatoes

IMDB

Metacritic

Fandango

Use nrow = 2 within the facet\_wrap() layer to specify a two-by-two arrangement of the histograms.


<<fig.pos="h", fig.height=3.7, fig.width=3.7, fig.cap="">>=
ggplot(data=reviews,aes(x=Rating))+
geom_histogram(bins=30)+
facet_wrap(~Rating_Site,nrow=2)
@

%===================
\subsection{Comparing Distributions of Multiple Variables: Specifying Aesthetics}
%==================

The four histograms in your faceted plot show differences in the distributions for each rating site:

<<echo=FALSE,cache=TRUE, fig.pos="h", fig.height=3.7, fig.width=3.7, fig.cap="">>=
ggplot(data=reviews,aes(x=Rating))+
geom_histogram(bins=30)+
facet_wrap(~Rating_Site,nrow=2)
@

The distributions of Rating for Rotten Tomatoes and Metacritic indicate that those two sites are more likely to give movies poor ratings than Fandango or IMDB, which have most values of Rating clustered over 3.

Comparing these distributions suggests some sites give poor ratings more often than others. For example, the difference between the distributions of Ratings for Fandango and Rotten Tomatoes is very clear. However, Fandango and IMDB have distributions that look similar. Is there a better way to visualize differences between them?

Remember that when you created line charts, plotting multiple variables on the same set of axes was useful for creating a more nuanced comparison. Similarly, we can plot histograms for the four rating sites on the same set of axes.

As you did for line graphs, you can distinguish values associated with different variables by mapping them to different colors within the aes() layer:

<<>>=
ggplot(data = reviews, aes(x = Rating, color = Rating_Site)) +
  geom_histogram(bins = 30)
@

When creating histograms (or bar charts), using the argument color = within aes() maps your specified variable to bar outlines of different colors:

In the histogram above, the number of values of Rating for each value of Rating\_Site are indicated by bars outlined by different colors.

Another option for using aesthetics to map values of Rating to different values of Rating\_Site is to use the argument fill = instead of color =. Instead of outlines, fill = depicts bars filled in with different colors. Let's use this option to visualize differences in Rating distributions of the four sites.

Instructions

Create a histogram depicting the distribution of Ratings for each site using bars filled with different colors.

<<fig.pos="h", fig.height=3.7, fig.width=5.7, fig.cap="">>=
ggplot(data=reviews,aes(x=Rating,fill=Rating_Site))+
geom_histogram(bins=30)
@

%==================================
\subsection{Visualizing Averages and Variation}
%==================================

Let's look at the histogram you created:

<<echo=FALSE,cache=TRUE, fig.pos="h", fig.height=3.7, fig.width=5.7, fig.cap="">>=
ggplot(data=reviews,aes(x=Rating,fill=Rating_Site))+
geom_histogram(bins=30)
@

Visualizing the distributions of Rankings for each rating site makes it clear that Fandango is more likely to rate movies highly than the other sites are, which supports the argument that it is biased toward assigning higher ratings.

You'll often use histograms in your data science career for initial explorations of your data. Knowing how to visualize and interpret distributions will become increasingly important later on when you learn about statistics and modeling.

Now that you're able to make bar charts to visualize data summaries and histograms to visualize data distributions, we'll introduce you to a type of plot for visualizing both the center of and the variation in your data.

Like bar graphs, box plots provide a summary of data by group. Like histograms, they provide information about how data are spread.

Take this box plot, for example:

Groups are indicated on the x-axis since they are the independent variable. The example dependent variable is on the y-axis. Before we discuss technical details of what the different components of the box plot depict on the next screen, let's get a general sense for what it can tell you about data.

The boxes for Group\_1 and Group\_3 are narrower than the box for Group\_2. This tells us that the values of Variable for Group\_2 are more spread out than they are for the other groups.

The black line in the middle of the boxes represents the value at the center of the data. For Group\_2 and Group\_3, this value falls in the center of the boxes. This tells us that the values that are larger and smaller than the middle value are about equally spread out.

For Group\_1, the black line is closer to the top of the box. This tells you that the values that are larger than the middle value are close together, while those smaller than the middle value are more spread out.

To create a box plot using ggplot2, the syntax for creating the data layer and mapping data to x and y variables is familiar.

<<>>=
ggplot(data = reviews,
  aes(x = Rating_Site, y = Rating))
@

You'll add a geom\_boxplot() layer to specify creation of a box plot.

Let's create a box plot of ratings for each site in the reviews data frame.

Instructions

Create a box plot to visualize summaries of values of the Rating variable for each value of Rating\_Site.

Add a geom\_boxplot() layer to specify creation of a box pot.

<<fig.pos="h", fig.height=3.7, fig.width=5.7, fig.cap="">>=
ggplot(data=reviews,aes(x=Rating_Site,y=Rating))+
geom_boxplot()
@

%==================================
\subsection{Anatomy of a Box Plot}
%==================================

Here's the box plot you've created:


<<echo=FALSE,cache=TRUE,fig.pos="h", fig.height=3.7, fig.width=5.7, fig.cap="">>=
ggplot(data=reviews,aes(x=Rating_Site,y=Rating))+
geom_boxplot()
@

In general, you can see that the box representing Fandango ratings is higher up on the y-axis than those for the other sites. You can also see the Rotten Tomatoes ratings appear to be more spread out, which is consistent with what you saw when we plotted the data using histograms.

While you've been able to glean some information from this box plot, let's dig deeper into the individual components to fully understand all they can tell us about data.

Box plots present what is known to statisticians as a five-number summary. The five numbers refer to percentiles of the data you're working with:

The five percentiles summarized by a box plot are:

The largest value: Represented by the top of the black line extending from the top of the box. These lines are also known as "whiskers".

The third quartile (Q3): Represented by the top of the box. Seventy-five percent of the values are smaller than the third quartile.

The median: Represented by the thick black line. The median is the value that falls in the middle of the data.

The first quartile (Q1): Represented by the bottom of the box. Twenty-five percent of the values are smaller than the first quartile.

The smallest value: Represented by the bottom of the black line extending from the bottom of the box.

The white box, bounded by Q3 and Q1, is referred to as the Interquartile Range or IQR. The IQR encompasses 50 percent of the data, and is calculated by subtracting Q1 from Q3.

In the box plot you created, notice there are some points that fall below the bottom of the black lines that represent the smallest values. These points are referred to as outliers because they are outside the range of what would be expected based on the rest of the data.

When you make a box plot using ggplot2, data points that fall below Q1 − 1.5 IQR or above Q3 + 1.5 IQR are defined as outliers. This definition is based on the work of statisticians, and you'll learn more about it in later courses.

Now that you've delved into the meaning of the components of a box plot, what can you learn about the movie rating data? Here are some observations:

Values of Rating for Rotten Tomatoes are spread out, indicating they regularly give movies ratings that range from poor to excellent.

The range of values of Rating for Fandango and IMDB are both quite narrow. Fandango's lowest reviews are around 2.5, whle outliers indicate that IMDB has some reviews that are between 2 and 2.4.

Fandango's median for values of Rating is higher than the median of the other sites, indicating Fandango tends to give higher ratings.

Does the box plot you made support the idea that Fandango's reviews are biased? Which site do you think would provide the most unbiased reviews?

In this mission, you've done some interesting work to visualize movie ratings data and possibly draw some conclusions about potential ratings bias. Let's create a final, uncluttered version of the plot that you can share with friends.

Instructions

In the previous exercise, you created a box plot to visualize summaries of ratings for Fandango, IMDB, Metacritic, and Rotten Tomatoes.

Add layers to your plot so it fits the following specifications:

White panel background

The plot title: "Comparison of Movie Ratings"


<<fig.pos="h", fig.height=3.7, fig.width=5.7, fig.cap="">>=
ggplot(data=reviews,aes(x=Rating_Site,y=Rating))+
geom_boxplot()+
labs(title="Comparison of Movie Ratings")+
theme(panel.background=element_rect(fill="white"))
@

\newpage
%==========================
\subsection{Deciding on a Visualization}
%==========================
In this mission, as we investigated possible movie rating bias, you've learned to represent the same data in three different ways:

Bar Charts:

<<fig.pos="h", fig.height=2.7, fig.width=5.7, fig.cap="">>=
ggplot(data=review_avgs,aes(x=Rating_Site,y=avg))+
geom_bar(stat="identity")
@

Histograms:

<<fig.pos="h", fig.height=2.7, fig.width=5.7, fig.cap="">>=
ggplot(data=reviews,aes(x=Rating,fill=Rating_Site))+
geom_histogram(bins=30)
@

Box Plots:

<<fig.pos="h", fig.height=2.7, fig.width=5.7, fig.cap="">>=
ggplot(data=reviews,aes(x=Rating_Site,y=Rating))+
geom_boxplot()+
labs(title="Comparison of Movie Ratings")+
theme(panel.background=element_rect(fill="white"))
@

As we discussed earlier in this course, building intuition around when to use different types of visualizations to understand your data is an important skill you will develop.

When should you use the three types of plots you learned about in this mission? You will probably explore different options for visualizing each new data set, and doing so is a good idea. However, here are some general guidelines:

Bar charts may be used for showing a quick summary of your data, such as averages or counts of the number of instances of a value that occur for a given variable.

Histograms are useful for visualizing distributions of data when you want to know the shape of a distribution (in other words, where most values are clustered).

Box plots provide an informative summary of the shape, spread, and center of your data.

%=====================================================
\section{Scatter Plots for Exploratory Analysis}
\subsection{Importing and Modifying Data}
%=====================================================

In the previous mission, you analyzed movie rating data to look for evidence of bias. You did this by looking at differences among ratings released by four movie rating sites using histograms and box plots.

Visualizing the differences among the sites' ratings suggested that some sites, especially Fandango, tend to give mostly good ratings and very few poor ones:

Discovering that Fandango tends to give higher ratings leads to another question: How do Fandango's movie ratings compare to those of the other sites? We now know that Fandango's ratings are higher overall, but do they generally agree with other sites in terms of relative film quality?

In this mission, you'll work on answering that question as you visualize relationships between ratings released by Fandango and the other three sites.

Once again, you'll be working with the movie review data compiled by FiveThirtyEight.

In the previous mission, we made a subset of the data available to you in a format conducive to creating histograms and box plots.

In this mission, you'll be working with the raw movie data set and making some modifications to it yourself.

Let's import and modify the data.

Instructions

We have loaded the readr and dplyr packages for you.

Import the "movie\_reviews\_2.csv" file into R and save it as a data frame.

Create a new data frame, reviews\_2, containing only the following columns:

FILM

RT\_user\_norm


Metacritic\_user\_nom (Note the misspelling "nom")

`IMDB\_norm

Fandango\_Ratingvalue

Give the columns new names to make them easier to work with:
FILM

Rotten\_Tomatoes

Metacritic

IMDB

Fandango

<<>>=
reviews_2<-read.csv(file="movie_reviews_2.csv",head=TRUE,sep=",")

str(reviews_2)
@

<<>>=
reviews_2<-reviews_2%>%
select(FILM, RT_user_norm, Metacritic_user_nom, IMDB_norm, Fandango_Ratingvalue) %>%
rename(Rotten_Tomatoes = RT_user_norm, Metacritic = Metacritic_user_nom, IMDB = IMDB_norm, Fandango = Fandango_Ratingvalue)

str(reviews_2)

reviews_2[1:5,]

@

%=====================================
\subsection{Understanding Relationships Between Variables}
%====================================

Now that you've selected columns from the raw data and renamed variables, let's take a look at the new data frame, reviews\_2. The data are structured with a column for each site's rating for each film:

<<echo=FALSE,cache=TRUE>>=
reviews_2[1:5,]
@

In this mission, you'll be comparing each film's Fandango rating to those of the other sites to see how well they agree. To accomplish this, you'll learn to work with a new type of data visualization called scatter plots.

Scatter plots represent data using points that have the value of one variable determining the position on the x-axis, and the value of the other variable determining the position on the y-axis:

When you work with scatter plots, the variables on the x- and y-axes do not need to be assigned roles of "independent" and "dependent." In other words, you do not necessarily have to suspect the values of one of the variables depend on the values of the other — you are just looking for any sort of relationship between them.

Let's look at some examples of scatter plots that suggest different types of relationships between variables.

The two variables, Variable\_1 and Variable\_2, that are depicted in this scatter plot appear to have a strong, positive relationship:

You can tell the relationship is positive because as values of Variable\_1 increase, so do values of Variable\_2. The relationship appears to be strong because the points are clustered close together instead of spread out.

In contrast, in this scatter plot, Variable\_1 and Variable\_2 appear to have a weak relationship:

While the values of Variable\_2 generally increase with values of Variable\_1 (a positive relationship), the points are spread farther apart than in the previous example.

Scatter plots can also indicate negative relationships between variables, in which one variable decreases as another increases. In this example, Variable\_1 and Variable\_2 appear to have a strong, negative relationship.

In this example, the relationship between Variable\_1 and Variable\_2 seems to be negative as well, though weaker than in the previous example:

In addition to allowing for visualization of relationships between variables, scatter plots can also demonstrate a lack of relationship between variables. In this scatter plot representing values of Variable\_1 and Variable\_2, the points are arranged in a shapeless cloud, indicating there is not likely a relationship between the two variables:


Whether a relationship is strong or weak is subjective — it depends on the person making the interpretation. You'll learn to more precisely define relationships between variables in our upcoming statistics courses. For now, we'll focus on understanding general patterns using scatter plots.

To create a scatter plot using ggplot2, you'll:

Specify the two variables for which you want to investigate a relationship in the aes() layer.

Add a geom\_point() layer to specify use of points to represent each pair of variable values.

\begin{lstlisting}[language=R]
ggplot(data = Example_Data,
  aes(x = Variable_1, y = Variable_2)) +
  geom_point()
\end{lstlisting}

Let's create a scatter plot to see how well Fandango's movie ratings compare to Rotten Tomatoes' for the films in reviews\_2.

Instructions

Create a scatter plot to investigate the relationship between movie rating scores for Fandango (as x axis) and Rotten Tomatoes (as y axis).

<<fig.pos="h", fig.height=3, fig.width=5.7, fig.cap="">>=
ggplot(data=reviews_2,aes(x=Fandango,y=Rotten_Tomatoes))+
geom_point()
@

\newpage
%=====================
\subsection{Creating Informative Scatter Plots}
%========================

What can we learn from your scatter plot about the relationship between Fandango and Rotten Tomatoes ratings? Let's take a look:

<<echo=FALSE,cache=TRUE,fig.pos="h", fig.height=3, fig.width=5.7, fig.cap="">>=
ggplot(data=reviews_2,aes(x=Fandango,y=Rotten_Tomatoes))+
geom_point()
@

First, let's focus on the axes. They reflect the spread of values for each site that you visualized using histograms and box plots. Fandango, on the x-axis, has values ranging from 3 to 4.5 while Rotten Tomatoes, on the y-axis, has values ranging from 1 to 4.

Next, look at the pattern of the points. The points are spread out, but generally, they trend upwards. Recall that this indicates a weak, positive relationship between movie ratings for Fandango and Rotten Tomatoes.

Overall, we can determine from this plot that while Fandango tends to give higher scores overall, the two sites often agree on relative movie quality.

There are a few layers you can add to your plot to make it easier to interpret.

Adjusting Axis Ranges

To make the difference in the range of rating values for Fandango and Rotten Tomatoes easier to visualize, you can specify the same range of values for the x- and y-axes:

<<echo=FALSE,cache=TRUE,fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
ggplot(data=reviews_2,aes(x=Fandango,y=Rotten_Tomatoes))+
geom_point()
@

You can explicitly specify a scatter plot's x- and y-axis ranges by adding a separate layer for each to your plot:

\begin{lstlisting}[language=R]
plot +
  xlim(1,5) +
  ylim(1,5)
\end{lstlisting}

The code above specifies ranges, or limits, of 1 through 5 for the x (xlim()) and y (ylim()) axes.

Making Points Transparent

Notice vertical "lines" of overlapping points on the graph:


The points are arranged this way because Fandango scores are rounded down to two digits, and therefore points are not offset from one another:

<<echo=FALSE,cache=TRUE>>=
reviews_2[1:5,]
@

This can make the density of points on the plot difficult to see. To improve this feature of your scatter plots, you can make the points transparent by adding the argument alpha = to the geom\_point() layer:

\begin{lstlisting}[language=R]
geom_point(alpha = 0.3)
\end{lstlisting}

An alpha value of 1 specifies complete opacity, or points that can't be seen through. An alpha value of 0 specifies complete transparency, or points that are completely see-through. Intermediate values specify varying degrees of transparency. Usually, alpha values of 0.2 to 0.5 will help make overlapping points easier to see.

Let's modify the scatter plot you created to make it easier to interpret.

Instructions

Add new layes and modify existing layers of your scatter plot so it meets the following specifications:

The x- and y-axes range from 1 to 5.

The points have a transparency of alpha = 0.3.

The graph background is white.

<<fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
ggplot(data=reviews_2,aes(x=Fandango,y=Rotten_Tomatoes))+
geom_point(alpha=0.3)+
xlim(1,5)+
ylim(1,5)+
theme(panel.background=element_rect(fill="white"))
@
\newpage
%====================================================
\subsection{Creating Multiple Scatter Plots}
%====================================================

The new scatter plot you made allows for visualization of:

The relationship between Fandango and Rotten Tomatoes scores

The difference in score ranges for the two sites

The places where points overlap so that you can see how dense they are

<<echo=FALSE,cache=TRUE, fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
ggplot(data=reviews_2,aes(x=Fandango,y=Rotten_Tomatoes))+
geom_point(alpha=0.3)+
xlim(1,5)+
ylim(1,5)+
theme(panel.background=element_rect(fill="white"))
@

Let's return to our initial question: How do Fandango's ratings for each film compare to those of the other sites?

To answer it, let's create scatter plots to depict the relationship of Fandango's ratings with those of IMDB and Metacritic.

Instructions

Create two new scatter plots:

A comparison of ratings from Fandango and IMDB

A comparison of ratings from Fandango and Metacritic

Use the techniques you learned earlier to create plots with:

The same axis limits (1-5)

A white background

Partially transparent points (alpha = 0.3)

<<fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
ggplot(data = reviews_2,
  aes(x = Fandango, y = IMDB)) +
  geom_point(alpha = 0.3) +
  xlim(1,5) +
  ylim(1,5) +
  theme(panel.background = element_rect(fill = "white"))

ggplot(data = reviews_2,
  aes(x = Fandango, y = Metacritic)) +
  geom_point(alpha = 0.3) +
  xlim(1,5) +
  ylim(1,5) +
  theme(panel.background = element_rect(fill = "white"))
@

\newpage

%==================================
\subsection{Write a Function to Create Multiple Scatter Plots}
%====================================

You've now created three scatter plots to compare Fandango's ratings with those of the other three sites.

When you created the scatter plots, did you find youself copying and pasting blocks of code? Perhaps you did, since the code to create the three plots is very similar:

<<fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
ggplot(data = reviews_2,
  aes(x = Fandango, y = Rotten_Tomatoes)) +
  geom_point(alpha = 0.3) +
  xlim(1,5) +
  ylim(1,5) +
  theme(panel.background = element_rect(fill = "white"))

ggplot(data = reviews_2,
  aes(x = Fandango, y = IMDB)) +
  geom_point(alpha = 0.3) +
  xlim(1,5) +
  ylim(1,5) +
  theme(panel.background = element_rect(fill = "white"))

ggplot(data = reviews_2,
  aes(x = Fandango, y = Metacritic)) +
  geom_point(alpha = 0.3) +
  xlim(1,5) +
  ylim(1,5) +
  theme(panel.background = element_rect(fill = "white"))
@

Recall from earlier courses that when you find yourself repeatedly copying and pasting, there is likely a more efficient solution.

You can use what you've learned about writing custom functions and visualizing data with ggplot2 to write a function to create a scatter plot. Then, you can use your knowledge of functionals to apply your function to the data and create multiple scatter plots at once.

Let's start by writing the function.

Recall that it can be helpful to start by writing the code inside the function first. Instead of using the aes() layer to map movie sites to the axes, you'll specify generic x and y variables:

\begin{lstlisting}[language=R]
ggplot(data = reviews_2, aes(x = x, y = y)) +
    geom_point(alpha = 0.3) +
    xlim(1,5) +
    ylim(1,5) +
    theme(panel.background = element_rect(fill = "white"))
\end{lstlisting}


When writing a function to create plots, there is one change you should make to the code above. Instead of using aes() to map variables to axes, use aes\_string() instead. Using aes\_string() allows you to pass vectors of variable names into your function for efficiency.

Once we've written the function, we can use a functional from the purrr package to apply the create\_scatter() function to the site ratings we want to look at relationships between.

Since create\_scatter() is a two-variable function, we need to use the functional map2(). Remember that map2() takes two variables and a function as arguments and returns a list. In this case, the input function is create\_scatter(). What variables do we specify, though?

Let's remind ourselves of the output we want to obtain using the create\_scatter function. We want a list of three scatter plots of relationships between site ratings:

Fandango and Rotten Tomatoes

Fandango and IMDB

Fandango and Metacritic

Either the x or y variable will always be Fandango. Let's assign the Fandango variable to the x-axis variable:

\begin{lstlisting}[language=R]
x_var <- "Fandango"
\end{lstlisting}

The other variable, on the y-axis, will consist of the three sites we want to compare Fandango against: Rotten Tomatoes, IMDB, and Metacritic. We'll assign the associated variables to y\_var.

\begin{lstlisting}[language=R]
y_var <- c("Rotten_Tomatoes", "IMDB", "Metacritic")
\end{lstlisting}

In instances where you don't want to have to type all the variable names into vectors, you can index the data frame to select specific rows and use the names() function to extract row names:

\begin{lstlisting}[language=R]
x_var <- names(reviews_2)[5]
y_var <- names(reviews_2)[2:4]
\end{lstlisting}

Now that we've discussed how to write the function and use a functional to apply it to the variables of interest, let's create the three scatter plots.

\newpage

Instructions

Write a function that creates a scatter plot from the input variables x and y.

Remember to change aes() to aes\_string().

Use the map2() functional and the function you wrote to visualize relationships between ratings of the following pairs of sites:

Fandango and Rotten Tomatoes

Fandango and IMDB

Fandango and Metacritic

We have already loaded the purrr package for you.

<<fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
create_scatter <- function(x, y) {
  ggplot(data = reviews_2) + 
    aes_string(x = x, y = y) +
    geom_point(alpha = 0.3) +
    xlim(1,5) +
    ylim(1,5) +
    theme(panel.background = element_rect(fill = "white"))
}

x_var <- names(reviews_2)[5]
y_var <- names(reviews_2)[2:4]

map2(x_var, y_var, create_scatter)
@


\newpage


\newpage
%===========================================================
\subsection{Learning from Scatter Plots}
%===========================================================

You have now written a function and used functionals to create multiple scatter plots:

<<fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
# write function
create_scatter = function(x, y) {
  ggplot(data = reviews_2) + 
    aes_string(x = x, y = y) +
    geom_point(alpha = 0.3) +
    xlim(1,5) +
    ylim(1,5) +
    theme(panel.background = element_rect(fill = "white"))
}

# create vectors of variable names
x_var <- names(reviews_2)[5]
y_var <- names(reviews_2)[2:4]

# apply the function to create the plots
ratings_comparisons <- map2(x_var, y_var, create_scatter)
@

While this approach improved the efficiency of your code in this mission, imagine how much time it would save if you needed to create dozens or hundreds of scatter plots!

As you work on personal data science projects, you can also apply these techniques to the creation of other types of data visualizations using ggplot2.

Here are the three plots you've created to explore the relationships between Fandango's movie ratings and the ratings of the three other sites:

Let's return to our question from earlier in this mission: How do Fandango's film ratings compare to those of the other sites?

We can make some observations:

The plots show that ratings for all three sites are weakly positively related to Fandango's ratings. This means that, in general, Fandango and the other sites often agreed on which movies were good and which were not, despite Fandango assigning higher ratings overall.

The Rotten Tomatoes and IMDB ratings seem to be more strongly related to Fandango's than the Metacritic ratings.

As you look at the scatter plots you created, how would you answer the question?

Does this information help you decide which movie rating site to use?

\newpage

%==============================
\section{Guided Project: Analyzing Forest Fire Data}
\subsection{Exploring Data Through Visualizations: Independent Investigations}
%==============================

In this course, you've learned to visualize data to understand it better. You've used a variety of types of visuals to answer questions about changes over time, data distributions, and relationships between variables.

In your career as a data analyst or scientist, you'll use these data visualization techniques frequently to familiarize yourself with new data sets, come up with questions to ask, and plan analyses.

In this guided project, your task is to use these techniques, as well as data analysis skills you gained in earlier courses, to explore data on forest fires.

We'll provide some guidance, but you'll have the freedom to explore questions independently as well. We recommend creating a script in RStudio for this project. Feel free to review RStudio installation and use in our RStudio mission in Introduction to Programming in R.

Dealing with getting stuck and seeking help are very important skills for every data scientist. If you find yourself with questions while working on the project, there are resources you can turn to:

Connect with others in the Dataquest Community.

Try searching for answers to your question using resources like Stack Overflow or R-bloggers.

To get started, import the data set, "forestfires.csv", into R as a data frame. You can download it \href{https://archive.ics.uci.edu/ml/machine-learning-databases/forest-fires/}{here.}

Don't forget to load the readr package first. If you haven't already, you will need to install it.

Our advice here is to try first. Don't hesitate to look at the documentation of packages and functions, and use Stackoverflow. And, only if you are stuck taking a look at the \href{https://github.com/dataquestio/solutions/blob/master/Mission277Solutions.Rmd}{solution notebook.}

<<>>=
forestfires<-read.csv(file="forestfires.csv",head=TRUE,sep=",")

str(forestfires)

forestfires[1:5,]
@

%================================================
\subsection{The Importance of Forest Fire Data}
%================================================

Forest fires can create ecological problems and endanger human lives and property. Understanding when they occur and what causes them is important for managing them.

The data you'll be working with in this guided project is associated with a scientific research paper on predicting the occurrence of forest fires in Portugal using modeling techniques.

You will learn how to conduct this type of predictive modeling in later courses. In this project, though, you'll be performing exploratory analyses on the data to better understand it. Remember, exploring data visually is often the first step data scientists take when working with new data.

Take a look at the data frame. You can display the first ten rows of the data in the console, or you can view the entire data frame as a tab in RStudio's top left pane using View(data\_frame).

Here are descriptions of the variables in the data set and the range of values for each taken from the paper:

X: X-axis spatial coordinate within the Montesinho park map: 1 to 9

Y: Y-axis spatial coordinate within the Montesinho park map: 2 to 9

month: Month of the year: 'jan' to 'dec'

day: Day of the week: 'mon' to 'sun'

FFMC: Fine Fuel Moisture Code index from the FWI system: 18.7 to 96.20

DMC: Duff Moisture Code index from the FWI system: 1.1 to 291.3

DC: Drought Code index from the FWI system: 7.9 to 860.6
ISI: Initial Spread Index from the FWI system: 0.0 to 56.10

temp: Temperature in Celsius degrees: 2.2 to 33.30

RH: Relative humidity in percentage: 15.0 to 100

wind: Wind speed in km/h: 0.40 to 9.40

rain: Outside rain in mm/m2 : 0.0 to 6.4

area: The burned area of the forest (in ha): 0.00 to 1090.84

The X and Y variables are coordinates of fire locations. While we have not yet worked with visualizing spatial data, you will learn to do so in an upcoming course. We will put this concept aside for now.

The acronym FWI stands for "fire weather index", a method used by scientists to quantify risk factors for forest fires. You can read more about the FWI system and the variables included in this data set here if you'd like.

As you look at the data, what are some questions that come to mind?

We'll guide you through using data visualizations to answer some questions, but you are welcome to ask and answer your own, as well.

%===================================
\subsection{When Do Most Forest Fires Occur?}
%==================================

When it comes to understanding forest fires and what can be done to manage them, it is helpful to have an idea of when the fires are most likely to occur.

Take a look at the data. Which variables can help you understand when forest fires tend to occur?

There are two variables that have to do with time: \fbox{month} and \fbox{day}. We can ask the questions:

During which months are forest fires most common?

On which days of the week are forest fires most common?

To answer these questions, create two bar charts:

One showing the number of forest fires occuring during each month

<<fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
ggplot(data = forestfires, aes(x = month, y = FFMC))+
geom_bar(stat="identity")
@

Another showing the number of forest fires occurring on each day of the week

<<fig.pos="h",fig.height=3,fig.width=6,fig.cap="">>=
ggplot(data=forestfires,aes(x=day,y=FFMC))+
geom_bar(stat="identity")
@

Since you need to count the number of fire occurrences per month or per day, it makes sense to begin by splitting the data into groups (by month or day), applying the n() function to count the number of observations in each group, and saving the resulting summary as a data frame. 

<<>>=
fires_by_month <- forestfires %>%
  group_by(month) %>%
  summarize(total_fires = n())
  
fires_by_month
@

<<>>=
fires_by_DOW <- forestfires %>%
  group_by(day) %>%
  summarize(total_fires = n())
  
fires_by_DOW
@


If you'd like to review the syntax for operations like this, you can revisit the Vectorized Functions mission in Intermediate R Programming, or the Bar Charts, Histograms, and Box Plots mission in this course.

Then, you can use that data frame to create your bar chart.

<<fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
ggplot(data = fires_by_month) +
  aes(x = month, y = total_fires) +
  geom_bar(stat = "identity")  +
  theme(panel.background = element_rect(fill = "white"), 
        axis.line = element_line(size = 0.25, 
                                 colour = "black"))
@

<<fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
ggplot(data = fires_by_DOW) +
  aes(x = day, y = total_fires) +
  geom_bar(stat = "identity") +
  theme(panel.background = element_rect(fill = "white"), 
        axis.line = element_line(size = 0.25, 
                                 colour = "black")) 
@


Remember that to use group\_by() and summarize(), you will need the dplyr package. To create the bar graphs, you will need the ggplot2 package. Recall that you need to have the packages installed (you only need to do this once) and loaded (you need to do this for each new RStudio session).

\newpage

%=============================================================
\subsection{Working With Factor Data}
%=============================================================

Do your bar charts look something like these?

\textcolor{red}{[\href{https://app.dataquest.io/m/277/guided-project\%3A-analyzing-forest-fire-data/4/working-with-factor-data}{ver os gráficos da plataforma]}

These charts let you see some trends. August and September certainly have the most fires, and Wednesdays seems to have fewer fires than other days of the week.

Look at the order of the month and day variables on the x-axis. Does the fact they are not in chronological order make it hard for you to interpret the bar charts?

You can specify a certain order for values of these variables by changing their data type to factor. We haven't worked with this data type previously, and will revisit it in greater depth in future courses. For now, know that factor data consists of a limited number of different values, and you can specify these values' order using the argument levels = and a vector of values.

Recall that to change the data type of a column, you can use the mutate() function from the dplyr package.

To change the data type of month to factor and specify the order of months, you would write:

\begin{lstlisting}[language=R]
forestfires <- forestfires %>%
  mutate(month = factor(month, levels = c("jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec")))
\end{lstlisting}

 
Try creating the bar charts using the reordered month and day variables.

<<>>=
#organizo os dados do eixo por mes e dia em sequencia
forestfires <- forestfires %>%
  mutate(month = factor(month, levels = c("jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec")), 
         day = factor(day, levels = c("sun", "mon", "tue", "wed", "thu", "fri", "sat")))
         
forestfires$month[1:12]

forestfires$day[1:7]

@

<<fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
ggplot(data = fires_by_month) +
  aes(x = month, y = total_fires) +
  geom_bar(stat = "identity")  +
  theme(panel.background = element_rect(fill = "white"), 
        axis.line = element_line(size = 0.25, 
                                 colour = "black"))
@

<<fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
ggplot(data = fires_by_DOW) +
  aes(x = day, y = total_fires) +
  geom_bar(stat = "identity") +
  theme(panel.background = element_rect(fill = "white"), 
        axis.line = element_line(size = 0.25, 
                                 colour = "black")) 
@

As you create your bar charts, feel free to explore different aesthetics such as adding graph titles. You'll learn much more about manipulating the appearance of your visuals in our upcoming "Telling Stories With Data" course.

\newpage

%======================================
\subsection{Why Do Forest Fires Occur When They Do?}
%======================================

Let's have a look at the bar graphs with the reordered month and day variables:

\href{https://app.dataquest.io/m/277/guided-project\%3A-analyzing-forest-fire-data/5/why-do-forest-fires-occur-when-they-do}{\textcolor{red}{[ver a página do curso]}}

As you look at the graphs, what can you determine about when forest fires are more likely to occur?

It's clear that August and September, late summer months in the Northern hemisphere, see more forest fires than other months.

It also looks as though Friday, Saturday, and Sunday have more forest fires than days in the middle of the week. Why do you think this may be?

To explore causes of the temporal patterns of forest fire occurrence the bar charts reveal, we can look more closely at how the variables that relate to forest fires vary by month and by day of the week.

Create box plots to visualize the distribution of the following variables by month and by day of the week:

FFMC

DMC

DC

ISI

temp

RH

wind

rain

Recall that you can make producing multiple plots much more efficient by following these steps:

Writing a function

Creating vectors of variable names

Applying the function to the variable vectors using functionals from the purrr package

We recommend writing two functions:

One for visualizing distributions by month

Another for visualizing distributions by day of the week

Then, create vectors containing names of the x and y variables and use the map2() functional to apply the functions to the vectors.

<<>>=
## Write the function
create_boxplots <- function(x, y) {
  ggplot(data = forestfires) + 
    aes_string(x = x, y = y) +
    geom_boxplot() +
    theme(panel.background = element_rect(fill = "white"))
}
## Assign x and y variable names 
x_var_month <- names(forestfires)[3] ## month
x_var_day <- names(forestfires)[4] ## day
y_var <- names(forestfires)[5:12]

## use the map() function to apply the function to the variables of interest

month_box <- map2(x_var_month, y_var, create_boxplots) ## visualize variables by month

day_box <- map2(x_var_day, y_var, create_boxplots) ## visualize variables by day
@


Remember, you can always refer to the previous missions in this course to review syntax for writing functions to create plots.


\textcolor{red}{[só a título de exemplo, plotei uma variável no mês, pra ver como fica. Repare que agora a ordem dos meses e dos dias está correta. Dá pra melhorar usando gráficos um do lado do outro como ensinado na seção do ggplot]}

<<fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
ggplot(data=forestfires,aes(x=month,y=DMC))+
geom_boxplot()
@

<<fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
ggplot(data=forestfires,aes(x=month,y=DMC))+
geom_bar(stat="identity")
@


<<fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
ggplot(data=forestfires,aes(x=day,y=DMC))+
geom_boxplot()
@

<<fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
ggplot(data=forestfires,aes(x=day,y=DMC))+
geom_bar(stat="identity")
@

\newpage

%========================================================
\subsection{What Variables Are Related To Forest Fire Severity?}
%========================================================

Your box plots may look something like ours. Let's talk about how we can interpret them.

Let's look first at the distributions of variables by day of the week:

\textcolor{red}{\href{https://app.dataquest.io/m/277/guided-project\%3A-analyzing-forest-fire-data/6/what-variables-are-related-to-forest-fire-severity}{ver a seção do curso [clique aqui]}}

What observations can you make? First, it's clear from looking at the solid black lines in the centers of the box plots that medians for each variable seem to be quite consistent across days of the week. The size of the boxes are also consistent across days, suggesting that the ranges of data values are similar.

The number of outlier points and the length of the box whiskers representing high and low points vary from day to day. However, there do not seem to be any patterns that suggest that the variables differ by day of the week, despite the fact that the number of forest fires appears to be higher on weekends. Does this tell you anything about what some possible causes of that pattern may be?

It's interesting to look at plot of the the rain variable. A few very high values make it so the y-axis range is large enough to make the rest of the data appear to be close to zero. You could deal with this by changing the y-axis range (adding a ylim() layer) if you wanted to see the distributions more clearly.

Let's look at the distributions of variables by month:

Unlike the variable distributions by days of the week, almost all the variables display clear differences among months.

We will talk about a few, and we encourage you to visit the FWI Information site and do some research on your own to learn more about the other variables.

The temp variable shows a pattern of being higher during the summer months. We can also see that the DC variable, which stands for "drought code" and is a measure of how dry conditions are, is high during the late summer months. Do these variables' patterns make sense when you consider the months when fires are most common?

We've looked at patterns of variable distributions across months and days of the week. While variables don't seem to show interesting patterns when viewed by day of the week, there are interesting differences among months that look like they have the potential to explain why more forest fires occur in the late summer months.

Let's investigate further. Which variables are related to forest fire severity?

In this data set, the area variable contains data on the number of hectares of forest that burned during the forest fire. Perhaps we can use this variable as an indicator of the severity of the fire. The idea is that worse fires will result in a larger burned area.

Let's create scatter plots to see what can be learned about relationships between the area burned by a forest fire and the following variables:

FFMC: Fine Fuel Moisture Code index from the FWI system: 18.7 to 96.20

DMC: Duff Moisture Code index from the FWI system: 1.1 to 291.3

DC: Drought Code index from the FWI system: 7.9 to 860.6

ISI: Initial Spread Index from the FWI system: 0.0 to 56.10

temp: Temperature in Celsius degrees: 2.2 to 33.30

RH: Relative humidity in percentage: 15.0 to 100

wind: Wind speed in km/h: 0.40 to 9.40

rain: Outside rain in mm/m2 : 0.0 to 6.4

In the previous mission, when you created scatter plots, it didn't matter which movie rating sites were on the x- and y-axes.

In this case, we're interested in whether the variables above may affect forest fire area. For that reason, you should place area on the y-axes and the other variables on the x-axes of your scatter plots.

<<>>=
## write the function 
create_scatterplots = function(x, y) {
  ggplot(data = forestfires) + 
    aes_string(x = x, y = y) +
    geom_point() +
    theme(panel.background = element_rect(fill = "white"))
}
## Assign x and y variable names 

x_var_scatter <- names(forestfires)[5:12] # da quinta a decima segunda coluna
y_var_scatter <- names(forestfires)[13] # somente coluna 13

## use the map() function to apply the function to the variables of interest

scatters <- map2(x_var_scatter, y_var_scatter, create_scatterplots)
@

Remember that, to make multiple scatter plots, you can write a function and apply it to your variables of interest using a functional. You can always refer to the previous missions in this course to review syntax for writing functions to create plots.

\textcolor{red}{Aqui eu crio alguns scatters soh pra testar}

<<fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
ggplot(data=forestfires,aes(x=month,y=DC))+
geom_point()
@

<<fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
ggplot(data=forestfires,aes(x=DC,y=area))+
geom_point()
@

%======================================================
\subsection{Deciding on Subsets of Data for Scatter Plots}
%======================================================

Let's interpret your scatter plots, which may look similar to these:

\textcolor{red}{\href{https://app.dataquest.io/m/277/guided-project\%3A-analyzing-forest-fire-data/7/deciding-on-subsets-of-data-for-scatter-plots}{ver a pagina do curso}}

It's hard to understand relationships between variables when you look at these plots. There are a few points representing very large values of area, and many points representing values of area that are zero or close to zero. As a result, most points are clustered around the bottom of the plots.

A histogram of the area variable values clearly illustrates the distribution and why the scatter plots look the way they do:

<<fig.pos="h", fig.height=3, fig.width=5.9, fig.cap="">>=
ggplot(data = forestfires, aes(x = area)) +
  geom_histogram(binwidth = 20)
@

To more clearly visualize relationships between variables, you can experiment with filtering the data frame by values of area and plotting subsets:

All data except for rows with very high values of area

All data except for rows with zero values of area

Data with values of area that fall within a specified range

Do you see any interesting relationships between forest fire area and the other variables you investigated?

If you do not see any interesting relationships, what might that tell you about our assumption that forest fire area is related to forest fire severity?


%======================
\subsection{Next Steps}
%========================

Based on the data visualizations you created as you worked on this guided project, what have you learned about forest fires and variables related to their occurrence? If you find this data set interesting, we encourage you to continue exploring it on your own.

We also encourage you to begin independently \href{https://www.dataquest.io/blog/free-datasets-for-projects/}{seeking out data sets that interest you}, importing them into RStudio, and exploring them using the techniques you've learned in the past three courses.

You've come a long way. At this point in your learning journey, you're able to import data into R, explore it by creating visualizations, and perform analyses using built-in functions, writing your own functions, and using control structures and functionals for efficiency.

In the next course, you'll gain experience with a critically important skillset for data professionals: Data cleaning. You'll wrangle a real-world, messy data set and use it to answer questions about demographics and standardized test scores in New York City.

Curious to see what other students have done on this project? \href{https://community.dataquest.io/tags/c/social/share/49/277}{Head over to our Community to check them out}. While you are there, please remember to show some love and give your own feedback!

And of course, we welcome you to share your own project and show off your hard work. Head over to our Community to share your finished Guided Project!

%===================================
\vspace{2cm}

\textcolor{red}{\textbf{ver o proximo documento para dar continuidade neste e-book nome:}}

\vspace{2cm}

\begin{center}
\textcolor{red}{\textit{\textbf{Programação em R (dataquest.io) parte 2}}}}
\end{center}


%===================================









%=====================================================
\newpage
%=====================================================

\begin{thebibliography}{99}
\bibitem{oliveira} Oliveira, G. \textbf{Treinamento ferramenta R}., Curso EAD FERRAMENTA R, Aprenda Virtual, 2014.  

\bibitem{gujarati} Gujarati, D.,N. \textbf{Basic Econometrics}, fourth edition, McGraw-HiII/lrwin, 2003.

\bibitem{overleaf} Overleaf: Online \LaTeX Editor. Disponível em Overleaf.com 

\bibitem{xie} Xie, Y. \textbf{Dynamic Documents with R and knitr} 2nd edition, 2015.


\end{thebibliography}










%===================================================
\end{document}
